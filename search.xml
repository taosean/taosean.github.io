<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>匈牙利算法</title>
      <link href="/2021/03/08/Hungarian-algorithm/"/>
      <url>/2021/03/08/Hungarian-algorithm/</url>
      
        <content type="html"><![CDATA[<p>一些有关匈牙利算法的文章。</p><a id="more"></a><p><a href="https://blog.csdn.net/u013384984/article/details/90718287" target="_blank" rel="noopener">匈牙利算法-看这篇绝对就够了！</a></p><p><a href="https://blog.csdn.net/C20180630/article/details/70175814" target="_blank" rel="noopener">二分图匹配——匈牙利算法和KM算法</a></p><p><a href="https://blog.csdn.net/u013384984/article/details/90718287" target="_blank" rel="noopener">趣写算法系列之–匈牙利算法</a></p><h3 id="矩阵处理相关代码可以看-sklearn-中的-liear_assignmentpy"><a class="markdownIt-Anchor" href="#矩阵处理相关代码可以看-sklearn-中的-liear_assignmentpy"></a> 矩阵处理相关，代码可以看 sklearn 中的 liear_assignment.py</h3><p><a href="https://www.feiyilin.com/munkres.html" target="_blank" rel="noopener">Munkres Algorithm For Assignment Problem: A Tutorial</a></p><p><a href="https://blog.csdn.net/u014754127/article/details/78086014" target="_blank" rel="noopener">Hungarian Algorithm匈牙利算法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hungarian algorithm </tag>
            
            <tag> 二分图 </tag>
            
            <tag> 最大匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】进程？线程？小朋友你是否有很多问号？</title>
      <link href="/2021/01/05/Process-and-Thread-1/"/>
      <url>/2021/01/05/Process-and-Thread-1/</url>
      
        <content type="html"><![CDATA[<p>本文转载自<a href="https://mp.weixin.qq.com/s/4uhfJeYwQgzd6A6nTBj_Gg" target="_blank" rel="noopener">这篇文章</a></p><a id="more"></a><p><img src="menu.jpg" alt="目录"></p><h1 id="什么是进程"><a class="markdownIt-Anchor" href="#什么是进程"></a> 什么是进程？</h1><p><strong>标准定义</strong>：进程是一个具有一定独立功能的程序在一个数据集合上依次动态执行的过程。进程是一个正在执行程序的实例，包括程序计数器、寄存器和程序变量的当前值。</p><p>简单来说<strong>进程就是一个程序的执行流程，内部保存程序运行所需的资源</strong></p><p>在操作系统中可以有多个进程在运行，可对于CPU来说，同一时刻，一个CPU只能运行一个进程，但在某一时间段内，CPU将这一时间段拆分成更短的时间片，CPU不停地在各个进程间游走，这就给人一种并行的错觉，像CPU可以同时运行多个进程一样，这就是伪并行。</p><hr><h1 id="进程和程序有什么联系"><a class="markdownIt-Anchor" href="#进程和程序有什么联系"></a> 进程和程序有什么联系？</h1><p>一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</p><ul><li>程序是产生进程的基础</li><li>程序的每次运行产生不同的进程</li><li>进程是程序功能的体现</li><li>通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序</li></ul><hr><h1 id="进程和程序有什么区别"><a class="markdownIt-Anchor" href="#进程和程序有什么区别"></a> 进程和程序有什么区别？</h1><p><strong>进程是动态的，程序是静态的</strong>：程序是有序代码的集合，进程是程序的执行。</p><p><strong>进程是暂时的，程序是永久的</strong>：进程是一个状态变化的过程，程序可长久保存。</p><p><strong>进程和程序的组成不同</strong>：进程的组成包括程序、数据和进程控制块（进程状态信息）。</p><hr><h1 id="进程有什么特点"><a class="markdownIt-Anchor" href="#进程有什么特点"></a> 进程有什么特点？</h1><p><strong>动态性</strong>：可动态地创建和结束进程</p><p><strong>并发性</strong>：可以被独立的调度并占用处理机并发运行</p><p><strong>独立性</strong>：不同进程的工作不相互影响</p><p><strong>制约性</strong>：因访问共享资源或进程间同步而产生制约</p><hr><h1 id="进程如何创建"><a class="markdownIt-Anchor" href="#进程如何创建"></a> 进程如何创建？</h1><p>有什么事件会触发进程的创建呢？</p><p><strong>系统初始化</strong>：当启动操作系统时，通常会创建很多进程，有些是同用户交互并替他们完成工作的前台进程，其它的都是后台进程，后台进程和特定用户没有关系，但也提供某些专门的功能，例如接收邮件等，这种功能的进程也称为守护进程。计划任务是个典型的守护进程，它每分钟运行一次来检查是否有工作需要它完成。如果有工作要做，它就会完成此工作，然后进入休眠状态，直到下一次检查时刻的到来。</p><p><strong>正在运行的程序执行了创建进程的系统调用</strong>：在一个进程中又创建了一个新的进程，这种情况很常见。</p><p><strong>用户请求创建一个新进程</strong>：这种情况相信每个人都见过，用电脑时双击某个应用图标，就会有至少一个进程被创建。</p><p><strong>一个批处理作业的初始化</strong>：这种情形不常见，仅在大型机的批处理系统中应用，用户在这种系统中提交批处理作业，在操作系统认为有资源可运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。</p><p>归根到底：在UNIX系统中，只有fork系统调用才可以创建新进程，使用方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"父进程\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程创建之后，父子进程都有<strong>各自不同的地址空间</strong>，其中一个进程在其地址空间的修改对另一个进程不可见。子进程的初始化空间是父进程的一个副本，这里涉及两个不同地址空间，不可写的内存区是共享的，某些UNIX的实现使程序正文在两者间共享，因为它是不可修改的。</p><p>还有一种<strong>写时复制</strong>共享技术，子进程共享父进程的所有内存，一旦两者之一想要修改部分内存，则这块内存被复制确保修改发生在当前进程的私有内存区域。</p><hr><h1 id="进程为何终止"><a class="markdownIt-Anchor" href="#进程为何终止"></a> 进程为何终止？</h1><p>有什么事件会触发进程的终止呢？</p><p><strong>正常退出</strong>（自愿）：进程完成了工作正常终止，UNIX中退出进程的系统调用是exit。</p><p><strong>出错退出</strong>（自愿）：进程发现了错误而退出。可以看如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123; <span class="comment">// 有错误就退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>严重错误</strong>（非自愿）：进程发生了严重的错误而不得不退出，通常是程序的错误导致，例如执行了一条非法指令，引用不存在的内存，或者除数是0等，出现这些错误时进程默认会退出。而有些时候如果用户想自行处理某种类型的错误，发生不同类型错误时进程会收到不同类型的信号，用户注册处理不同信号的函数即可。</p><p><strong>被其它进程杀死</strong>（非自愿）：其它进程执行kill系统调用通知操作系统杀死某个进程。</p><hr><h1 id="操作系统如何进行进程管理"><a class="markdownIt-Anchor" href="#操作系统如何进行进程管理"></a> 操作系统如何进行进程管理？</h1><p>这里就不得不提到一个数据结构：进程控制块（PCB），<strong>操作系统为每个进程都维护一个PCB</strong>，用来保存与该进程有关的各种状态信息。进程可以抽象理解为就是一个PCB，<strong>PCB是进程存在的唯一标志</strong>，操作系统用PCB来描述进程的基本情况以及运行变化的过程，进程的任何状态变化都会通过PCB来体现。</p><p><strong>PCB包含进程状态的重要信息</strong>，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其它在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未中断过一样。后一小节会具体介绍PCB。</p><p>提到进程管理，有一个概念我们必须要知道，就是<strong>中断向量</strong>，中断向量是指中断服务程序的入口地址。一个进程在执行过程中可能会被中断无数次，但是每次中断后，被中断的进程都要返回到与中断发生前完全相同的状态。</p><p>中断发生后操作系统最底层做了什么呢？</p><blockquote><p>1）硬件压入堆栈程序计数器等；<br>2）硬件从中断向量装入新的程序计数器；<br>3）汇编语言过程保存寄存器值；<br>4）汇编语言过程设置新的堆栈；<br>5）C中断服务例程运行（典型的读和缓冲输入）；<br>6）调度程序决定下一个将运行的进程；<br>7）C过程返回到汇编代码；<br>8）汇编语言过程开始运行新的当前进程。</p></blockquote><hr><h1 id="进程控制块中存储了什么信息"><a class="markdownIt-Anchor" href="#进程控制块中存储了什么信息"></a> 进程控制块中存储了什么信息？</h1><p><strong>进程标识信息</strong>：如本进程的标识，本进程的父进程标识，用户标识等。</p><p><strong>处理机状态信息保护区</strong>：用于保存进程的运行现场信息。</p><ul><li>用户可见寄存器：用户程序可以使用的数据、地址等寄存器。</li><li>控制和状态寄存器：程序计数器，程序状态字。</li><li>栈指针：过程调用、系统调用、中断处理和返回时需要用到它。</li></ul><p><strong>进程控制信息</strong>：</p><ul><li>调度和状态信息：用于操作系统调度进程使用。</li><li>进程间通信信息：为支持进程间与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中。</li><li>存储管理信息：包含有指向本进程映像存储空间的数据结构。</li><li>进程所用资源：说明由进程打开使用的系统资源，如打开的文件等。</li><li>有关数据结构连接信息：进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。</li></ul><hr><h1 id="进程如何进行生命周期管理"><a class="markdownIt-Anchor" href="#进程如何进行生命周期管理"></a> 进程如何进行生命周期管理？</h1><p><strong>进程创建</strong>：</p><p>创建进程有三个主要事件：</p><ul><li>系统初始化</li><li>用户请求创建一个新进程</li><li>一个正在运行的进程执行创建进程的系统调用</li></ul><p><strong>进程运行</strong>：内核选择一个就绪的进程，让它占用处理机并运行，这里就涉及到了进程的调度策略，选择哪个进程调度？为什么选择调度这个进程呢？（莫慌，下面会介绍哈）</p><p><strong>进程等待</strong>：</p><ul><li>在以下情况下进程会等待（阻塞）：</li><li>请求并等待系统服务，无法马上完成</li><li>启动某种操作，无法马上完成</li><li>需要的数据没有到达</li></ul><p><strong>注意：进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生</strong>。</p><p><strong>进程唤醒</strong>：<br>进程只能被别的进程或操作系统唤醒，唤醒进程的原因有：</p><ul><li>被阻塞进程需要的资源可被满足</li><li>被阻塞进程等待的事件到达</li><li>将该进程的PCB插入到就绪队列</li></ul><p><strong>进程结束</strong>：<br>在以下四种情况下进程会结束：</p><ul><li>自愿型正常退出</li><li>自愿型错误退出</li><li>强制型致命错误退出</li><li>强制型被其它进程杀死退出</li></ul><hr><h1 id="进程都有什么状态"><a class="markdownIt-Anchor" href="#进程都有什么状态"></a> 进程都有什么状态？</h1><p>不同系统设置的进程状态是不同的，多数系统中的进程在生命结束前有三种基本状态，进程只会处于三种基本状态之一：</p><p><strong>运行状态</strong>：进程正在处理机上运行时就处在运行状态，该时刻进程时钟占用着CPU；</p><p><strong>就绪状态</strong>：万事俱备，只欠东风，进程已经获得了除处理机之外的一切所需资源，一旦得到处理机就可以运行；就绪态中的进程其实可以运行，但因为其它进程正在占用着CPU而暂时停止运行；</p><p><strong>等待状态（阻塞状态）</strong>：进程正在等待某一事件而暂停运行，等待某个资源或者等待输入输出完成。除非某种外部事件发生，否则阻塞态的进程不能运行；</p><p>进程状态变化图如下：<br><img src="status.jpg" alt="进程状态变化图"></p><p>在操作系统发现进程不能继续运行下去时，进程因为等待输入而被阻塞，进程从<strong>运行态转换到阻塞态</strong>！</p><p>调度程序选择了另一个进程执行时，当前程序就会从<strong>运行态转换到就绪态</strong>！</p><p>被调度程序选择的程序会从<strong>就绪态转换到运行态</strong>！</p><p>当阻塞态的进程等待的一个外部事件发生时，就会从<strong>阻塞态转换到就绪态</strong>，此时如果没有其他进程运行时，则立刻从<strong>就绪态转换到运行态</strong>！</p><p>有些与进程管理相关的系统调用读者有必要了解一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pid=fork(); // 创建一个与父进程一样的子进程</span><br><span class="line"></span><br><span class="line">pid=waitpid(); // 等待子进程终止</span><br><span class="line"></span><br><span class="line">s=execve(); // 替换进程的核心映像</span><br><span class="line"></span><br><span class="line">exit(); // 终止进程运行并返回状态值</span><br><span class="line"></span><br><span class="line">s=sigaction(); // 定义信号处理的动作</span><br><span class="line"></span><br><span class="line">s=sigprocmask(); // 检查或更换信号掩码</span><br><span class="line"></span><br><span class="line">s=sigpending(); // 获得阻塞信号集合</span><br><span class="line"></span><br><span class="line">s=sigsuspend(); // 替换信号掩码或挂起进程</span><br><span class="line"></span><br><span class="line">alarm(); // 设置定时器</span><br><span class="line"></span><br><span class="line">pause(); // 挂起调用程序直到下一个信号出现</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>某些系统设置下进程还会有其它状态：<br>创建状态：进程正在被创建还没被转到就绪状态之前的状态；<br>结束状态：进程正在从系统中消失时的状态。</p><hr><h1 id="什么是进程挂起为什么会出现进程挂起"><a class="markdownIt-Anchor" href="#什么是进程挂起为什么会出现进程挂起"></a> 什么是进程挂起？为什么会出现进程挂起？</h1><p>进程挂起就是为了合理且充分的利用系统资源，把一个进程从内存转到外存。进程在挂起状态时，意味着进程没有占用内存空间，处在挂起状态的进程映射在磁盘上。进程挂起通常有两种状态：</p><ul><li><p>阻塞挂起状态：进程在外存并等待某事件的出现；</p></li><li><p>就绪挂起状态：进程在外存，但只要进入内存即可运行。</p></li></ul><p>有什么与进程挂起相关的状态转换？</p><p>进程挂起可能有以下几种情况：</p><p><strong>阻塞到阻塞挂起</strong>：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程；</p><p><strong>就绪到就绪挂起</strong>：当有高优先级阻塞进程或低优先级就绪进程时，系统会选择挂起低优先级就绪进程；</p><p><strong>运行到就绪挂起</strong>：对于抢占式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；</p><p><strong>阻塞挂起到就绪挂起</strong>：当有阻塞挂起进程有相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。</p><p><strong>有进程挂起那就有进程解挂：指一个进程从外存转到内存，相关状态有</strong>：</p><p><strong>就绪挂起到就绪</strong>：没有就绪进程或就绪挂起进程优先级高于就绪进程时，就会进行这种转换；</p><p><strong>阻塞挂起到阻塞</strong>：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起进程转换为阻塞进程。</p><hr><h1 id="什么是进程调度操作系统对于进程调度都有什么策略"><a class="markdownIt-Anchor" href="#什么是进程调度操作系统对于进程调度都有什么策略"></a> 什么是进程调度？操作系统对于进程调度都有什么策略？</h1><p>当系统中有多个进程同时竞争CPU，如果只有一个CPU可用，那同一时刻只会有一个进程处于运行状态，操作系统必须要选择下一个要运行的是哪个进程，在操作系统中，完成选择工作的这部分称为调度程序，该程序使用的算法称作<strong>调度算法</strong>。</p><p><strong>什么时候进行调度？</strong></p><ol><li>系统调用创建一个新进程后，需要决定是运行父进程还是运行子进程。</li><li>一个进程退出时需要做出调度决策，需要决定下一个运行的是哪个进程。</li><li>当一个进程阻塞在I/O和信号量或者由于其它原因阻塞时，必须选择另一个进程运行。</li><li>当一个I/O中断发生时，如果中断来自IO设备，而该设备现在完成了工作，某些被阻塞的等待该IO的进程就成为可运行的就绪进程了，是否让新就绪的进程运行，或者让中断发生时运行的进程继续运行，或者让某个其它进程运行，这就取决于调度程序的抉择了。</li></ol><p><strong>调度算法分类</strong>：</p><p><strong>非抢占式调度算法</strong>：挑选一个进程，然后让该进程运行直至被阻塞，或者直到该进程自动释放CPU，即使该进程运行了若干个小时，它也不会被强迫挂起。这样做的结果是，在时钟中断发生时不会进行调度，在处理完时钟中断后，如果没有更高优先级的进程等待，则被中断的进程会继续执行。简单来说，<strong>调度程序必须等待事件结束</strong>。</p><p>非抢占方式引起进程调度的条件：</p><ul><li>进程执行结束，或发生某个事件而不能继续执行</li><li>正在运行的进程因有I/O请求而暂停执行</li><li>进程通信或同步过程中执行了某些原语操作（wait、block等）</li></ul><p><strong>抢占式调度算法</strong>：挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行，进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便CPU控制返回给调度程序，如果没有可用的时钟，那么非抢占式调度就是唯一的选择。简单来说，<strong>就是当前运行的进程在事件没结束时就可以被换出，防止单一进程长时间独占CPU资源</strong>。下面会介绍很多抢占式调度算法：优先级算法、短作业优先算法、轮转算法等。</p><p><strong>调度策略</strong>：不同系统环境下有不同的调度策略算法。调度算法也是有KPI的，对调度算法首先提的需求就是：</p><ul><li><strong>公平</strong>：调度算法需要给每个进程公平的CPU份额，相似的进程应该得到相似的服务，对一个进程给予较其它等价的进程更多的CPU时间是不公平的，被普通水平的应届生工资倒挂也是不公平的！</li><li><strong>执行力</strong>：每一个策略必须强制执行，需要保证规定的策略一定要被执行。</li><li><strong>平衡</strong>：需要保证系统的所有部分尽可能都忙碌。</li></ul><p>但是因为不同的应用有不同的目标，不同的系统中，调度程序的优化也是不同的，大体可以分为三种环境：</p><br><p><strong>批处理系统</strong></p><blockquote><p>批处理系统的管理者为了掌握系统的工作状态，主要关注三个指标：</p><ul><li>吞吐量：是系统每小时完成的作业数量</li><li>周转时间：指从一个作业提交到完成的平均时间</li><li>CPU利用率：尽可能让CPU忙碌，但又不能过量</li></ul><p><strong>调度算法</strong>：</p><p><strong>先来先服务</strong><br>先来后到嘛，就像平时去商店买东西需要排队一样，使用该算法，进程按照它们请求CPU的顺序来使用CPU，该算法最大的优点就是简单易于实现，太容易的不一定是好的，该算法也有很大的<strong>缺点</strong>：平均等待时间波动较大，时间短的任务可能排队排在了时间长的任务后面。举个生活中的例子，排着队去取快递，如果每个人都很快取出来快递还好，如果前面有几个人磨磨唧唧到快递柜前才拿出手机打开app，再找半分钟它的取件码，就会严重拖慢后面的人取快递的速度，同理排着队的进程如果每个进程都很快就运行完还好，如果其中有一个得到了CPU的进程运行时候磨磨唧唧很长时间都运行不完，那后面的进程基本上就没有机会运行了！</p><p><strong>最短作业优先</strong><br>该调度算法是非抢占式的算法，每个进程执行期间不会被打断，每次都选择执行时间最短的进程来调度，但问题来了，操作系统怎么可能知道进程具体的执行时间呢，所以该算法注定是基于预测性质的理想化算法，而且有违公平性，而且可能导致运行时间长的任务得不到调度。</p><p><strong>最短剩余时间优先</strong><br>该调度算法是抢占式的算法，是最短作业优先的抢占版本，在进程运行期间，如果来了个更短时间的进程，那就转而去把CPU时间调度给这个更短时间的进程，它的缺点和最短作业优先算法类似。</p></blockquote><br><p><strong>交互式系统</strong></p><blockquote><p>对于交互系统最重要的指标就是响应时间和均衡性啦：</p><ul><li>响应时间：一个请求被提交到产生第一次响应所花费的时间。你给别人发微信别人看后不回复你或者几个小时后才回复你，你是什么感受，这还是交互式吗？</li><li>均衡性：减少平均响应时间的波动。需要符合固有期望和预期，你给别人发微信，他有时候秒回复，有时候几个小时后才回复。在交互式系统中，可预测性比高差异低平均更重要。</li></ul><p><strong>调度算法：</strong></p><p><strong>轮转调度</strong><br>每个进程被分配一个时间段，称为时间片，即CPU做到雨露均沾，轮流翻各个进程的牌子，这段时间宠幸进程A，下一段时间宠幸进程B，再下一段时间宠幸进程C，确保每个进程都可以获得CPU时间，如果CPU时间特别短的话，在外部看来像是同时宠幸了所有进程一样。那么问题来了，这个时间片究竟多长时间好呢？如果时间片设的太短会导致过多的进程切换，频繁的上下文切换会降低CPU效率，而如果时间片设的太长又可能对短的交互请求的响应时间变长，通常将时间片设为20-50ms是个比较合理的折中，大佬们的经验规则时维持上下文切换的开销处于1%以内。</p><p><strong>优先级调度</strong><br>上面的轮转调度算法是默认每个进程都同等重要，都有相同优先级，然而有时候进程需要设置优先级，例如某些播放视频的前台进程可以优先于某些收发邮件的后台守护进程被调度，在优先级调度算法中，每个优先级都有相应的队列，队列里面装着对应优先级的进程，首先在高优先级队列中进行轮转调度，当高优先级队列为空时，转而去低优先级队列中进行轮转调度，如果高优先级队列始终不为空，那么低优先级的进程很可能就会饥饿到很久不能被调度。</p><p><strong>多级队列</strong><br>多级队列算法与优先级调度算法不同，优先级算法中每个进程分配的是相同的时间片，而在多级队列算法中，不同队列中的进程分配给不同的时间片，当一个进程用完分配的时间片后就移动到下一个队列中，这样可以更好的避免上下文频繁切换。举例：有一个进程需要100个时间片，如果每次调度都给分配一个时间片，则需要100次上下文切换，这样CPU运行效率较低，通过多级队列算法，可以考虑最开始给这个进程分配1个时间片，然后被换出，下次分给它2个时间片，再换出，之后分给它4、8、16、64个时间片，这样分配的话，该进程只需要7次交换就可以运行完成，相比100次上下文切换运行效率高了不少，但顾此就会失彼，那些需要交互的进程得到响应的速度就会下降。</p><p><strong>最短进程优先</strong><br>交互式系统中应用最短进程优先算法其实是非常适合的，每次都选择执行时间最短的进程进行调度，这样可以使任务的响应时间最短，但这里有个任务，还没有运行呢，我怎么知道进程的运行时间呢？根本没办法非常准确的再当前可运行进程中找出最短的那个进程。有一种办法就是根据进程过去的行为进行预测，但这能证明是个好办法吗？</p><p><strong>保证调度</strong><br>这种调度算法就是向用户做出明确的可行的性能保证，然后去实现它。一种很实际的可实现的保证就是确保N个用户中每个用户都获得CPU处理能力的1/N，类似的，保证N个进程中每个进程都获得1/N的CPU时间。</p><p><strong>彩票调度</strong><br>彩票调度算法基本思想是为进程提供各种资源（CPU时间）的彩票，一旦需要做出调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源，很明显，拥有彩票越多的进程，获得资源的可能性越大。该算法在程序喵看来可以理解为股票算法，将CPU的使用权分成若干股，假设共100股分给了3个进程，给这些进程分别分配20、30、50股，那么它们大体上会按照股权比例（20：30：50）划分CPU的使用。</p><p><strong>公平分享调度</strong><br>假设有系统两个用户，用户1启动了1个进程，用户2启动了9个进程，如果使用轮转调度算法，那么用户1将获得10%的CPU时间，用户2将获得90%的CPU时间，这对用户来说公平吗？如果给每个用户分配50%的CPU时间，那么用户2中的进程获得的CPU时间明显比用户1中的进程短，这对进程来说公平吗？这就取决于怎么定义公平啦？</p></blockquote><br><p><strong>实时系统</strong></p><blockquote><p>实时系统顾名思义，最关键的指标当然是实时啦：</p><ul><li>满足截止时间：需要在规定deadline前完成作业；</li><li>可预测性：可预测性是指在系统运行的任何时刻，在任何情况下，实时系统的资源调配策略都能为争夺资源的任务合理的分配资源，使每个实时任务都能得到满足。</li></ul><p><strong>调度算法分类</strong>：</p><p><strong>硬实时</strong><br>必须在deadline之前完成工作，如果delay，可能会发生灾难性或发生严重的后果；</p><p><strong>软实时</strong><br>必须在deadline之前完成工作，但如果偶尔delay了，也可以容忍。</p><p><strong>调度算法</strong>：</p><p><strong>单调速率调度</strong><br>采用抢占式、静态优先级的策略，调度周期性任务。<br>每个任务最开始都被配置好了优先级，当较低优先级的进程正在运行并且有较高优先级的进程可以运行时，较高优先级的进程将会抢占低优先级的进程。在进入系统时，每个周期性任务都会分配一个优先级，周期越短，优先级越高。这种策略的理由是：更频繁的需要CPU的任务应该被分配更高的优先级。</p><p><strong>最早截止时间调度</strong><br>根据截止时间动态分配优先级，截止时间越早的进程优先级越高。</p><p>该算法中，当一个进程可以运行时，它应该向操作系统通知截止时间，根据截止时间的早晚，系统会为该进程调整优先级，以便满足可运行进程的截止时间要求。它与单调速率调度算法的区别就是一个是静态优先级，一个是动态优先级。</p></blockquote><p><strong>如何配置调度策略</strong>？<br>调度算法有很多种，各有优缺点，操作系统自己很少能做出最优的选择，那么可以把选择权交给用户，由用户根据实际情况来选择适合的调度算法，这就叫策略与机制分离，调度机制位于内核，调度策略由用户进程决定，将调度算法以某种形式参数化，由用户进程来选择参数从而决定内核使用哪种调度算法。</p><hr><h1 id="操作系统怎么完成进程调度"><a class="markdownIt-Anchor" href="#操作系统怎么完成进程调度"></a> 操作系统怎么完成进程调度？</h1><p>进程的每次变化都会有相应的状态，而操作系统维护了一组状态队列，表示系统中所有进程的当前状态；不同的状态有不同的队列，有就绪队列阻塞队列等，每个进程的PCB都根据它的状态加入到相应的队列中，当一个进程的状态发生变化时，它的PCB会从一个状态队列中脱离出来加入到另一个状态队列。</p><p><img src="scheduling.jpg" alt="进程调度"></p><p>注意图中同一种状态为什么有多个队列呢？因为进程有优先级概念，相同状态的不同队列的优先级不同。</p><hr><h1 id="什么是线程"><a class="markdownIt-Anchor" href="#什么是线程"></a> 什么是线程？</h1><p>线程是进程当中的一条执行流程，这几乎就是进程的定义，一个进程内可以有多个子执行流程，即线程。可以从两个方面重新理解进程：</p><ul><li>从资源组合的角度：进程把一组相关的资源组合起来，构成一个资源平台环境，包括地址空间（代码段、数据段），打开的文件等各种资源</li><li>从运行的角度：代码在这个资源平台上的执行流程，然而线程貌似也是这样，但是进程比线程多了资源内容列表样式：那就有一个公式：进程 = 线程 + 共享资源</li></ul><hr><h1 id="为什么使用线程"><a class="markdownIt-Anchor" href="#为什么使用线程"></a> 为什么使用线程？</h1><p>因为要并发编程，在许多情形中同时发生着许多活动，而某些活动有时候会被阻塞，通过将这些活动分解成可以准并行运行的多个顺序流程是必须的，而如果使用多进程方式进行并发编程，进程间的通信也很复杂，并且<strong>维护进程的系统开销较大</strong>：创建进程时分配资源建立PCB，撤销进程时回收资源撤销PCB，进程切换时保存当前进程的状态信息。所以为了使并发编程的开销尽量小，所以引入多线程编程，可以并发执行也可以<strong>共享相同的地址空间</strong>。并行实体拥有共享同一地址空间和所有可用数据的能力，这是多进程模型所不具备的能力。</p><p>使用线程有如下优点：</p><ul><li>可以多个线程存在于同一个进程中</li><li>各个线程之间可以并发的执行</li><li>各个线程之间可以共享地址空间和文件等资源</li><li>线程比进程更轻量级，创建线程撤销线程比创建撤销进程要快的多，在许多系统中，创建一个线程速度是创建一个进程速度的10-100倍。</li><li>如果多个线程是CPU密集型的，并不能很好的获得更好的性能，但如果多个线程是IO密集型的，线程存在着大量的计算和大量的IO处理，有多个线程允许这些活动彼此重叠进行，从而会加快整体程序的执行速度。</li></ul><p>但也有<strong>缺点</strong>：</p><ul><li>一旦一个线程崩溃，会导致其所属进程的所有线程崩溃。</li><li>由于各个线程共享相同的地址空间，那么读写数据可能会导致竞争关系，因此对同一块数据的读写需要采取某些同步机制来避免线程不安全问题。</li></ul><hr><h1 id="什么时候用进程-线程"><a class="markdownIt-Anchor" href="#什么时候用进程-线程"></a> 什么时候用进程、线程？</h1><ol><li>进程是资源分配单位，线程是CPU调度单位；</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li><li>线程同样具有就绪阻塞和执行三种基本状态，同样具有状态之间的转换关系；</li><li>线程能减少并发执行的时间和空间开销：<ul><li>线程的创建时间比进程短</li><li>线程的终止时间比进程短</li><li>同一进程内的线程切换时间比进程短</li><li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信</li></ul></li></ol><p><strong>结论</strong>：可以在强调性能时候使用线程，如果追求更好的容错性可以考虑使用多进程，google浏览器据说就是用的多进程编程。在多CPU系统中，多线程是有益的，在这样的系统中，通常情况下可以做到真正的并行。</p><p><strong>C/C++中如何使用多线程编程？</strong></p><p>POSIX使用如下线程封装函数来操作线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_create               创建一个新线程</span><br><span class="line">pthread_exit                 结束调用的线程</span><br><span class="line">pthread_join                 等待一个特定的线程退出</span><br><span class="line">pthread_yield                释放CPU来运行另外一个线程</span><br><span class="line">pthread_attr_init            创建并初始化一个线程的属性结构</span><br><span class="line">pthread_attr_destroy         删除一个线程的属性结构</span><br></pre></td></tr></table></figure><p>后两个函数是有关线程属性的调用。pthread_attr_init建立关联一个线程的属性结构并初始化成默认值，这些值（优先级等）可以通过修改属性结构中的对应值来改变；pthread_attr_destroy会删除一个线程的属性结构，释放它占用的内存，它不会影响调用它的线程，线程依然会继续存在。</p><p>C++中有std::thread和async，可以很方便地操作多线程，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">r</span><span class="params">(F)</span></span>;</span><br><span class="line">    r.detach();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">20</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="线程是如何实现的"><a class="markdownIt-Anchor" href="#线程是如何实现的"></a> 线程是如何实现的？</h1><p>线程的实现可分为用户线程和内核线程：</p><p><strong>用户线程</strong>：在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建终止同步和调度等。</p><p><img src="user_thread.jpg" alt="用户线程"></p><p>用户线程有如下优点：</p><ul><li>由于用户线程的维护由相应进程来完成（通过线程库函数），不需要操作系统内核了解内核了解用户线程的存在，可用于不支持线程技术的多进程操作系统。</li><li>每个进程都需要它自己私有的线程控制块列表，用来跟踪记录它的各个线程的状态信息（PC，栈指针，寄存器），TCB由线程库函数来维护；</li><li>用户线程的切换也是由线程库函数来完成，无需用户态/核心态切换，所以速度特别快；</li><li>允许每个进程拥有自定义的线程调度算法；</li></ul><p>但用户线程也有<strong>缺点</strong>：</p><ul><li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待。</li><li>当一个线程开始运行后，除非它主动交出CPU的使用权，否则它所在进程当中的其它线程将无法运行；</li><li>由于时间片分配给进程，与其它进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢</li></ul><p><strong>内核线程</strong>：是指在操作系统的内核中实现的一种线程机制，由操作系统的内核来完成线程的创建终止和管理。</p><p><img src="kernel_thread.jpg" alt="内核线程"></p><p><strong>特点：</strong></p><ul><li>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB TCB）；</li><li>线程的创建终止和切换都是通过系统调用内核函数的方式来进行，由内核来完成，因此系统开销较大；</li><li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其它内核线程的运行；</li><li>时间片分配给线程，多线程的进程获得更多CPU时间；</li></ul><p><em><strong>tips</strong></em><br>由于在内核中创建或撤销线程的代价比较大，某些系统采取复用的方式回收线程，当某个线程被撤销时，就把它标记不可运行，但是内核数据结构没有受到任何影响，如果后续又需要创建一个新线程时，就重新启动被标记为不可运行的旧线程，从而节省一些开销。</p><p><strong>注意</strong><br>尽管使用内核线程可以解决很多问题，但还有些问题，例如：当一个多线程的进程创建一个新的进程时会发生什么？新进程是拥有与原进程相同数量的线程还是只有一个线程？在很多情况下，最好的选择取决于进程计划下一步做什么？如果它要调用exec启动一个新程序，或许一个线程正合适，但如果它继续运行，那么最好复制所有的线程。</p><p><strong>轻量级进程</strong>：它是内核支持的用户线程模型，一个进程可以有多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。</p><p><img src="LWP.jpg" alt="轻量级进程"></p><p>在Linux下是没有真正的线程的，它所谓的线程其实就是使用进程来实现的，就是所谓的轻量级进程，其实就是进程，都是通过clone接口调用创建的，只不过两者传递的参数不同，通过参数决定子进程和父进程共享的资源种类和数量，进而有了普通进程和轻量级进程的区别。</p><hr><h1 id="什么是上下文切换"><a class="markdownIt-Anchor" href="#什么是上下文切换"></a> 什么是上下文切换？</h1><p>上下文切换指的是操作系统停止当前运行进程（从运行状态改变成其它状态）并且调度其它进程（就绪态转变成运行状态）。操作系统必须在切换之前存储许多部分的进程上下文，必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过，同时切换上下文这个过程必须快速，因为上下文切换操作是非常频繁的。那<strong>上下文指的是什么呢</strong>？指的是任务所有共享资源的工作现场，每一个共享资源都有一个<strong>工作现场</strong>，包括用于处理函数调用、局部变量分配以及工作现场保护的栈顶指针，和用于指令执行等功能的各种寄存器。</p><p><strong>注意</strong><br>这里所说的进程切换导致上下文切换其实不太准确，准确的说应该是任务的切换导致上下文切换，这里的任务可以是进程也可以是线程，准确的说线程才是CPU调度的基本单位，但是因为各个资料都这么解释上下文切换，所以上面也暂时这么介绍，只要读者心里有这个概念就好。</p><p><img src="context.png" alt="上下文切换"></p><hr><h1 id="进程间通信有几种方式"><a class="markdownIt-Anchor" href="#进程间通信有几种方式"></a> 进程间通信有几种方式？</h1><p>由于各个进程不共享相同的地址空间，任何一个进程的全局变量在另一个进程中都不可见，所以如果想要在进程之间传递数据就需要通过内核，在内核中开辟出一块区域，该区域对多个进程都可见，即可用于进程间通信。有读者可能有疑问了，文件方式也是进程间通信啊，也要在内核开辟区域吗？这里说的内核区域其实是一段缓冲区，文件方式传输数据也有内核缓冲区的参与（零拷贝除外）。</p><p><img src="IPC.jpg" alt="进程间通信"></p><p>如何开辟这种公共区域来进行进程间通信呢？</p><p><strong>匿名管道</strong></p><p>匿名管道就是<strong>pipe</strong>，pipe只能在父子进程间通信，而且数据只能<strong>单向流动</strong>（半双工通信）。</p><p><strong>使用方式</strong>：<br>1）父进程创建管道，会得到两个文件描述符，分别指向管道的两端；<br>2）父进程创建子进程，从而子进程也有两个文件描述符指向同一管道；<br>3）父进程可写数据到管道，子进程就可从管道中读出数据，从而实现进程间通信，下面的示例代码中通过pipe实现了每秒钟父进程向子进程都发送消息的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(_pipe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pipe\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        close(_pipe[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> _mesg[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(_mesg, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(_mesg));</span><br><span class="line">            read(_pipe[<span class="number">0</span>], _mesg, <span class="keyword">sizeof</span>(_mesg));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, _mesg);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">        close(_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> *mesg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            mesg = <span class="string">"父进程来写消息了"</span>;</span><br><span class="line">            write(_pipe[<span class="number">1</span>], mesg, <span class="built_in">strlen</span>(mesg) + <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们平时也经常使用关于管道的命令行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | less</span><br></pre></td></tr></table></figure><p>该命令行的流向图如下：</p><p><img src="unnamed_pipe.jpg" alt="命令行流向图"></p><p>1：创建管道<br>2：为ls创建一个进程，设置stdout为管理写端<br>3：为less创建一个进程，设置stdin为管道读端</p><p><strong>高级管道</strong><br>通过<strong>popen</strong>将另一个程序当作一个新的进程在当前进程中启动，它算作当前进程的子进程，高级管道只能用在有亲缘关系的进程间通信，这种亲缘关系通常指父子进程，下面的GetCmdResult函数可以获取某个Linux命令执行的结果，实现方式就是通过popen。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetCmdResult</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;cmd, <span class="keyword">int</span> max_size = <span class="number">10240</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *data = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(max_size);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"malloc fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, max_size);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_buffer = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[max_buffer];</span><br><span class="line">    <span class="comment">// 将标准错误重定向到标准输出</span></span><br><span class="line">    FILE *fdp = popen((cmd + <span class="string">" 2&gt;&amp;1"</span>).c_str(), <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">int</span> data_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fdp) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!feof(fdp)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fgets(buffer, max_buffer, fdp)) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buffer);</span><br><span class="line">                <span class="keyword">if</span> (data_len + len &gt; max_size) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"data size larger than "</span> &lt;&lt; max_size;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(data + data_len, buffer, len);</span><br><span class="line">                data_len += len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pclose(fdp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">ret</span><span class="params">(data, data_len)</span></span>;</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命名管道</strong><br>匿名管道有个缺点就是通信的进程一定要有亲缘关系，而命名管道就不需要这种限制。</p><p>命名管道其实就是一种特殊类型的文件，所谓的命名其实就是文件名，文件对各个进程都可见，通过命名管道创建好特殊文件后，就可以实现进程间通信。</p><p>可以通过mkfifo创建一个特殊的类型的文件，参数读者看名字应该就了解，一个是文件名，一个是文件的读写权限：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>当返回值为0时，表示该命名管道创建成功，至于如何通信，其实就是个读写文件的问题！</p><p><strong>消息队列</strong><br>队列想必大家都知道，像FIFO一样，这里可以有多个进程写入数据，也可以有多个进程从队列里读出数据，但消息队列有一点比FIFO还更高级，它读消息不一定要使用先进先出的顺序，每个消息可以赋予类型，可以按消息的类型读取，不是指定类型的数据还存在队列中。本质上MessageQueue是存放在内核中的消息链表，每个消息队列链表会由消息队列标识符表示，这个消息队列存于内核中，只有主动的删除该消息队列或者内核重启时，消息队列才会被删除。</p><p>在Linux中消息队列相关的函数调用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建和访问一个消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span>, key, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 用来把消息添加到消息队列中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsend</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">const</span> <span class="keyword">void</span> *msg_ptr, <span class="keyword">size_t</span> msg_sz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// msg_ptr是结构体数据的指针，结构第一个字段要有个类型：struct Msg &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> message_type;</span><br><span class="line">    <span class="comment">// 想要传输的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 从消息队列中获取消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">void</span> *msg_ptr, <span class="keyword">size_t</span> msg_st, <span class="keyword">long</span> <span class="keyword">int</span> msgtype, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 用来控制消息队列，不同的command参数有不同的控制方式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">int</span> command, struct msgid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZ 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msg_type;</span><br><span class="line">    <span class="keyword">char</span> text[BUFFER_SIZ];</span><br><span class="line">&#125; MsgWrapper;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MsgWrapper data;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msgtype = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1024</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (msgid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgget error \n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msgid, (<span class="keyword">void</span> *)&amp;data, BUFFER_SIZ, msgtype, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"error "</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"read data "</span> &lt;&lt; data.text &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(data.text) &gt; <span class="number">6</span>) &#123;  <span class="comment">// 发送超过6个字符的数据，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgctl(msgid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgctl error \n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Receive ok \n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MsgWrapper data;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msgtype = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1024</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (msgid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgget error \n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data.msg_type = msgtype;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(data.text, <span class="number">0</span>, BUFFER_SIZ);</span><br><span class="line">        <span class="keyword">char</span> a = <span class="string">'a'</span> + i;</span><br><span class="line">        <span class="built_in">memset</span>(data.text, a, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msgid, (<span class="keyword">void</span> *)&amp;data, BUFFER_SIZ, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgsnd error \n"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(data.text, <span class="string">"1234567"</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgsnd(msgid, (<span class="keyword">void</span> *)&amp;data, BUFFER_SIZ, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgsnd error \n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">r</span><span class="params">(Receive)</span></span>;</span><br><span class="line">    r.detach();</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">s</span><span class="params">(Send)</span></span>;</span><br><span class="line">    s.detach();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">20</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：root@iZuf64idor3ej648ciairaZ:~# ./a.out</span><br><span class="line">read data a</span><br><span class="line">read data b</span><br><span class="line">read data c</span><br><span class="line">read data d</span><br><span class="line">read data e</span><br><span class="line">read data f</span><br><span class="line">read data g</span><br><span class="line">read data h</span><br><span class="line">read data i</span><br><span class="line">read data j</span><br><span class="line">read data <span class="number">1234567</span></span><br><span class="line">Receive ok</span><br></pre></td></tr></table></figure><p>代码中为了演示方便使用消息队列进行的线程间通信，该代码同样用于进程间通信，消息队列的实现依赖于内核的支持，上述代码可能在某些系统（WSL）上不能运行，在正常的Ubuntu上可以正常运行。</p><p><strong>消息队列VS命名管道</strong></p><p><strong>消息队列&gt;命名管道</strong></p><p>1）消息队列收发消息自动保证了同步，不需要由进程自己来提供同步方法，而命名管道需要自行处理同步问题；<br>2）消息队列接收数据可以根据消息类型有选择的接收特定类型的数据，不需要像命名管道一样默认接收数据。</p><p><strong>消息队列&lt;命名管道</strong><br>消息队列有一个缺点就是发送和接收的每个数据都有最大长度的限制。</p><p><strong>共享内存</strong><br>可开辟中一块内存，用于各个进程间共享，使得各个进程可以直接读写同一块内存空间，就像线程共享同一块地址空间一样，该方式基本上是最快的进程间通信方式，因为没有系统调用干预，也没有数据的拷贝操作，但由于共享同一块地址空间，数据竞争的问题就会出现，需要自己引入同步机制解决数据竞争问题。</p><p>共享内存只是一种方式，它的实现方式有很多种，主要的有mmap系统调用、Posix共享内存以及System V共享内存等。通过这三种“工具”共享地址空间后，通信的目的自然就会达到。</p><p><strong>信号</strong><br>信号也是进程间通信的一种方式，信号可以在任何时候发送给某一个进程，如果进程当前并未处于执行状态，内核将信号保存，直到进程恢复到执行态再发送给进程，进程可以对信号设置预处理方式，如果对信号设置了阻塞处理，则信号的传递会被延迟直到阻塞被取消，如果进程结束，那信号就被丢弃。我们常用的CTRL+C和kill等就是信号的一种，也达到了进程间通信的目的，进程也可以对信号设置signal捕获函数自定义处理逻辑。这种方式有很大的<strong>缺点</strong>：只有通知的作用，通知了一下消息的类型，但不能传输要交换的任何数据。</p><p>Linux系统中常见的信号有：</p><ul><li>SIGHUP：该信号在用户终端结束时发出，通常在中断的控制进程结束时，所有进程组都将收到该信号，该信号的默认操作是终止进程；</li><li>SIGINT：程序终止信号，通常的CTRL+C产生该信号来通知终止进程；</li><li>SIGQUIT：类似于程序错误信号，通常的CTRL+\产生该信号通知进程退出时产生core文件；</li><li>SIGILL：执行了非法指令，通常数据段或者堆栈溢出可能产生该信号；</li><li>SIGTRAP：供调试器使用，由断电指令或其它陷阱指令产生；</li><li>SIGABRT：使程序非正常结束，调用abort函数会产生该信号；</li><li>SIGBUS：非法地址，通常是地址对齐问题导致，比如访问一个4字节长的整数，但其地址不是4的倍数；</li><li>SIGSEGV：合理地址的非法访问，访问了未分配的内存或者没有权限的内存区域；</li><li>SIGPIPE：管道破裂信号，socket通信时经常会遇到，进程写入了一个无读者的管道；</li><li>SIGALRM：时钟定时信号，由alarm函数设置的时间终止时产生；</li><li>SIGFPE：出现浮点错误（比如除0操作）；</li><li>SIGKILL：杀死进程（不能被捕捉和忽略）；</li></ul><p><strong>信号量</strong><br>想必大家都听过信号量，信号量就是一个特殊的变量，程序对其访问都是原子操作，每个信号量开始都有个初始值。最简单最常见的信号量是只能取0和1的变量，也叫二值信号量。</p><p>信号量有两个操作，P和V：</p><p>P：如果信号量变量值大于0，则变量值减1，如果值为0，则阻塞进程；<br>V：如果有进程阻塞在该信号量上，则唤醒阻塞的进程，如果没有进程阻塞，则变量值加1</p><blockquote><p>Q: 信号量和信号有什么关系？<br>A: 没有任何关系，完全是不同的东西。</p></blockquote><blockquote><p>Q: 信号量与互斥量有什么区别？<br>A: 互斥量用于<strong>互斥</strong>，信号量用于<strong>同步</strong>，互斥指的是某一资源同一时间只允许一个访问者访问，但无法限制访问顺序，访问是无序的，而同步在互斥的基础上可以控制访问者对资源的顺序。</p></blockquote><p><strong>套接字</strong>：就是网络传输，不用多说，网络通信都可以多机通信呢，更不用说进程间通信啦，你能看到程序喵的文章也是套接字的功劳。</p><p><strong>文件</strong>：显而易见，多个进程可以操作同一个文件，所以也可以通过文件来进行进程间通信。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
            <tag> Process </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】5万字、97 张图总结操作系统核心知识点</title>
      <link href="/2020/12/10/OS/"/>
      <url>/2020/12/10/OS/</url>
      
        <content type="html"><![CDATA[<p>本文章介绍了操作系统的一些核心知识点。</p><h2 id="文章地址"><a class="markdownIt-Anchor" href="#文章地址"></a> <a href="https://mp.weixin.qq.com/s/G4Xs8BDYo8YK4qHuGdB7DA" target="_blank" rel="noopener">文章地址</a></h2><a id="more"></a><p>文章从以下几个方面对操作系统进行了介绍:</p><ol><li><strong>计算机硬件</strong><br><img src="hardware.png" alt="计算机硬件"></li><li><strong>进程和线程</strong><ul><li>进程</li><li>线程</li><li>进程间通信</li><li>调度<br><img src="process.jpg" alt="进程和线程"></li></ul></li><li><strong>内存管理</strong><ul><li>地址空间</li><li>虚拟内存</li><li>页表置换算法<br><img src="memory.png" alt="内存管理"></li></ul></li><li><strong>文件系统的实现</strong><ul><li>文件</li><li>目录</li><li>文件系统的实现</li><li>文件系统的管理和优化<br><img src="filesystem.png" alt="文件系统"></li></ul></li><li><strong>I/O 流程</strong><ul><li>I/O 设备</li><li>I/O 软件原理</li><li>I/O 层次结构</li><li>盘</li><li>时钟<br><img src="IO.png" alt="I/O 流程"></li></ul></li><li><strong>资源</strong><br><img src="resource.png" alt="资源"></li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 Non-local</title>
      <link href="/2020/11/05/Understanding-Non-local/"/>
      <url>/2020/11/05/Understanding-Non-local/</url>
      
        <content type="html"><![CDATA[<p>之前一直没有深入地了解 Non-local 的来源，以为只是同名论文中提出的一个 Block 设计，最近阅读 AlphAction 论文时，突然发现其是来自于 Attention is all you need 中 self-attention 的思想。虽然 Attention 此文是针对 NLP 领域的，但是其思想逐渐被延伸到了视觉领域。在阅读关于 Transformer 中 self-attention 的文章后，在这里记录下对 Non-local 的理解。</p><a id="more"></a><p>首先介绍 Self-Attention</p><h1 id="self-attention-模块"><a class="markdownIt-Anchor" href="#self-attention-模块"></a> Self-attention 模块</h1><h2 id="公式"><a class="markdownIt-Anchor" href="#公式"></a> 公式</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mfrac><mrow><mi>A</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac><mo stretchy="false">)</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">Attention(Q,K,V)=softmax({AK^T\over\sqrt{d_k}})V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.448331em;vertical-align:-0.93em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span></span></p><blockquote><p>在 self-attention 中，每个单词有 3 个不同的向量，它们分别是 Query 向量（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> ），Key 向量（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> ）和 Value 向量（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> ），长度均是 64。<strong>它们是通过3个不同的权值矩阵由嵌入向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 乘以三个不同的权值矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>W</mi><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">W^Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>W</mi><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">W^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>W</mi><mi>V</mi></msup></mrow><annotation encoding="application/x-tex">W^V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span></span></span></span></span></span></span> 得到，其中三个矩阵的尺寸也是相同的</strong>。均是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>512</mn><mo>×</mo><mn>416</mn></mrow><annotation encoding="application/x-tex">512\times416</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mord">6</span></span></span></span> 。</p></blockquote><br><p><img src="QKV.jpg" alt="Q, K, V的计算示例图"></p><h2 id="attention-的计算方法"><a class="markdownIt-Anchor" href="#attention-的计算方法"></a> Attention 的计算方法</h2><ol><li>将输入单词转化成嵌入向量;</li><li>根据嵌入向量得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 三个向量;</li><li>为每个向量计算一个 score: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>=</mo><mi>q</mi><mo>⋅</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">score=q\cdot{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span>;</li><li>为了梯度的稳定，Transformer 使用了 score 归一化，即除以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.18278000000000005em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span></span>;</li><li>对 score 施以 softmax 激活函数;</li><li>softmax 点乘 Value 值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，得到加权的每个输入向量的评分 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>;</li><li>相加之后得到最终的输出结果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mo>∑</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">z=\sum{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span></span></li></ol><p>以上步骤可以表示成下图</p><p><img src="self-attention.jpg" alt="Self-Attention计算示例图"></p><p>实际计算过程中是采用基于矩阵的计算方式，那么论文中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 的计算方式如下图<br><img src="QKV-M.jpg" alt="Q, K, V的矩阵表示"></p><p>Self-Attention 的计算示例图可以总结为下图所示的矩阵形式<br><img src="self-attention-M.jpg" alt="Selef-Attention的矩阵表示"><br>而这，也是公式的计算方式。</p><hr><p>接下来看 Non-local 模块</p><h1 id="non-local-的图像"><a class="markdownIt-Anchor" href="#non-local-的图像"></a> Non-local 的图像</h1><p><img src="original-nonlocal.jpg" alt="原始的 Non-local"></p><p><img src="lfb-nonlocal.jpg" alt="lfb 中的 Non-local"></p><p><img src="alphaction-nonlocal.jpg" alt="AlphAction 中的 Non-local"></p><p>从 AlphAction 的 Non-local 可以看出，<br><code>Q</code> 的尺寸是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">N\times{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span></span>, <code>K</code> 的尺寸是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>×</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">N^{&#x27;}\times{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0258099999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span></span>, <code>Q</code> 与 <code>K转置</code>进行矩阵乘法，对应的就是第三步 <strong>计算 score</strong> 的过程(<code>Q</code>的每一行与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">K^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>的每一列点乘)。<br>接下来的 <code>Scale</code> 操作对应第四步 <strong>score 归一化</strong> 的过程。<br>再接下来，Softmax 的输出结果（尺寸 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">N\times{N^{&#x27;}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>）与 <code>V</code> 进行矩阵乘法，得到最后尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">N\times{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span></span> 的矩阵。这里，可以看作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">N\times{N^{&#x27;}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 矩阵的每一行分别与 <code>V</code> 相乘，即 <code>V</code> 的每一行的加权和。<br>其实，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mo>×</mo><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">Q\times{K^{T}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></span> 结果的每一行，来自于 <code>Q</code> 的每一行与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">K^{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span> 进行矩阵相乘，即 <code>Q</code> 的一个向量与 <code>K</code> 所有向量的点积。而<strong>最后计算 <code>V</code> 矩阵每一行的加权和时的权重就来自这里</strong>。</p><p>所以，整个 Non-local 的流程，整体感觉就是通过对 <code>Q</code>, <code>K</code> 的处理，得到了 <code>N</code> 组长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">N^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 的权重，并对 <code>V</code> 的每一行进行加权和。</p><p><strong>补充解释</strong>: Self-Attention 真实的意图是，通过 <code>Q</code> 与 <code>K</code> 进行 <code>score</code> 的计算，并以 <code>score</code> 作为 <code>V</code> 被 <code>Q</code> 所激活的程度的度量，并因此选择出激活程度最高的 <code>V</code> 中的特征向量，计算加权和。最后，将加权和与原始的 <code>Q</code> 进行相加，得到更新后的 <code>Q</code>。而这个更新后的 <code>Q</code>，就是获得了 attention 的 <code>Q</code>。在视频理解领域，目的就是通过 Self-attention 将来自其他人和物体的上下文信息加到 <code>Q</code> 所代表的人身上，以辅助后续分类。</p><p>AlphAction 中 3.2 节的解释如下</p><blockquote><p>Through the dot-product attention, which is the output of the softmax layer in Figure 3 a, the block is able to select value features that are highly activated to the query features and merge them to enhance the query features.</p></blockquote><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://zhuanlan.zhihu.com/p/48508221" target="_blank" rel="noopener">详解Transformer （Attention Is All You Need）</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Non-local </tag>
            
            <tag> attention </tag>
            
            <tag> Transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打包 Python 工程</title>
      <link href="/2019/10/29/Packaging-Python/"/>
      <url>/2019/10/29/Packaging-Python/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍了两个用来将 Python 工程的依赖进行打包以便于部署的 Python 库。</p><a id="more"></a><ol><li>PEX <a href="https://github.com/pantsbuild/pex" target="_blank" rel="noopener">github</a> <a href="https://pex.readthedocs.io/" target="_blank" rel="noopener">文档</a> <a href="https://medium.com/ovni/pex-python-executables-c0ea39cee7f1" target="_blank" rel="noopener">博客</a></li><li>shiv <a href="https://github.com/linkedin/shiv" target="_blank" rel="noopener">github</a> <a href="https://shiv.readthedocs.io/en/latest/" target="_blank" rel="noopener">文档</a></li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> PEX </tag>
            
            <tag> shiv </tag>
            
            <tag> dependencies </tag>
            
            <tag> 依赖 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将 Tensorflow 模型移植到 Caffe 上</title>
      <link href="/2019/10/22/Convert-Tensorflow-Model-to-Caffe/"/>
      <url>/2019/10/22/Convert-Tensorflow-Model-to-Caffe/</url>
      
        <content type="html"><![CDATA[<p>本文主要以 cosine metric learning 工程为例，记录了如何将一个 Tensorflow 模型 (包含 ckpt 文件) 移植到 Caffe 框架下。</p><a id="more"></a><h1 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h1><blockquote><ol><li>根据 Tensorflow 的网络定义源码，手动编写 Caffe 的网络定义文件 *.prototxt.</li><li>将训练好的 ckpt 文件中的参数 dump 到磁盘，存为 npy 文件。</li><li>使用 pycaffe API, 加载 prototxt 文件，生成 Net 对象。</li><li>根据 npy 文件与 Net 对象中网络层的对应关系，将 npy 文件中的值赋给 Net 对象中的参数。</li><li>将 Net 对象保存为 caffemodel 文件到磁盘。</li></ol></blockquote><br><h1 id="一些应该注意的点"><a class="markdownIt-Anchor" href="#一些应该注意的点"></a> 一些应该注意的点</h1><blockquote><p><strong>1</strong>. Tensorflow 中的 BN 层对应 Caffe 中的两个层，BatchNorm + Scale. 这是因为 Batch Normalization 算法最后有一个 缩放+偏置 的操作，这就对应 Caffe 中的 Scale 层。通常 Scale 层的缩放参数记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>, 偏置参数记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>. 有时候，从 ckpt 模型中 dump 出的 npy 文件没有 BN 层对应的 gamma 值，这可能是因为其在训练时没有使用缩放（batch_norm 函数的 scale 参数设为了 None ），也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\gamma=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。因此在流程第 4 步时，将相应 shape 的值全为 1 的 ndarray 赋给 Net 对象中 Scale 层对应的 gamma 即可，即 <code>net.params[conv1_scale][0].data[...] = np.ones(bn_beta)</code>. 此外，若 npy 文件中有 BN 层对应的 beta 值，则在 prototxt 文件中对应的 Scale 层应设置 <code>bias_term: true</code>，因为这里的 beta 值就是 bias term. <a href="https://blog.csdn.net/zziahgf/article/details/78843350" target="_blank" rel="noopener">参考1</a> <a href="https://www.cnblogs.com/LaplaceAkuir/p/7811383.html" target="_blank" rel="noopener">参考2</a></p></blockquote><hr><blockquote><p><strong>2</strong>. ckpt 中 dump 出的 npy 文件中可能没有某些 Convolution 层的 bias 权重。因此，在 prototxt 文件中，为此 Convolution 层设置 <code>bias_term: false</code>.</p></blockquote><hr><blockquote><p><strong>3</strong>. 在从 ckpt 中 dump 出来的参数里，有些可能名如 <code>*/Adam</code>, <code>*/Adam_1</code>，这个是因为模型使用了 Adam 优化器，这两个是对某个参数更新的时候使用的，如果只是在测试阶段进行前向推导，则不需要这两个参数。<a href="https://www.jianshu.com/p/75d8df8511bc" target="_blank" rel="noopener">参考</a><br>但是如果是需要对模型进行 Finetune, 出现大量 Adam 变量丢失的错误，则有可能是 <strong>要恢复的变量的位置</strong> 和 <strong>Adam 优化器的位置</strong> 出错造成的。<a href="https://blog.csdn.net/shwan_ma/article/details/82868751" target="_blank" rel="noopener">【tensorflow】加载pretrained model出现的大量adam变量丢失</a></p></blockquote><hr><blockquote><p><strong>4</strong>. 一些 Tensorflow 的项目使用 <code>tf.image.decode_jpeg()</code> 函数来读取 jpg 图像，要注意的是，如果直接使用此函数的默认 <code>dct_method</code> 的话，此函数读取到的值将会跟 <code>cv2.imread()</code> 读取的值不一致。这是因为 <code>tf.image.decode_jpeg()</code> 函数默认会为了解码速度而牺牲一些解码精度。如果想要获得跟 <code>cv2.imread()</code> 相同的结果的话，设置参数 <code>dct_method='INTEGER_ACCURATE'</code>。<a href="https://github.com/tensorflow/tensorflow/issues/24893#issuecomment-454911098" target="_blank" rel="noopener">参考1</a> <a href="https://stackoverflow.com/a/45520846/8149027" target="_blank" rel="noopener">参考2</a><br>此外，<code>tf.image.decode_jpeg()</code> 函数返回的图像是 <code>RGB</code> 通道的，<code>cv2.imread()</code> 是 <code>BGR</code> 通道。</p></blockquote><hr><blockquote><p><strong>5</strong>. <strong>Tensorflow 和 Caffe 在某些操作上的区别</strong><br>  <strong>5-1</strong>. <strong>Feature map 以及 卷积核 维度顺序的区别</strong><br>在 Tensorflow 中，feature map 的默认索引顺序是 <code>NHWC</code>, 卷积核是 <code>HWIO</code>，而 Caffe 中两者的索引顺序是 <code>NCHW</code> 和 <code>OIHW</code>.<br>需要说明的是，如果输入是完全一样的图片，在将图像以及卷积核按各自索引顺序 transpose 好后，后续生成的 feature map 在理论上来说应是完全一样的，它们只是索引的顺序不一样而已(feature map 内部各元素之间的相对顺序是一致的)。</p></blockquote><blockquote><p>  <strong>5-2</strong>. <strong>Flatten 操作的区别</strong><br>据上文所述，同样的输入以及卷积核在不同框架中计算得到的 feature map 是一致的。但是如果要对 feature map (4D) 进行 flatten 操作的话，则此结论可能不成立。因为 flatten 是将 3D 的 feature map 拉伸成 1D, 那么不同的顺序可能就会产生不同的 1D 向量 (内部元素的相对位置可能发生了改变).<br>对同一个 feature map, 若其 shape 为 <code>NHWC</code> （这里的 NHWC 与上文所说的 NHWC 意义不一样，针对某个特定的 feature map, 其 NHWC 的值是固定的）, Tensorflow 的顺序是沿着 <code>C -&gt; W -&gt; H</code>，而 Caffe 的顺序是沿着 <code>W -&gt; H -&gt; C</code>。两者 flatten 的顺序在其各自的输入 feature map 索引顺序中都是 <code>3 -&gt; 2 -&gt; 1</code><br>例如，一个 <code>1x3x3x2</code> 的 feature map.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data =  [[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],   | H</span><br><span class="line">          [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],   |</span><br><span class="line">          [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],  |</span><br><span class="line">      W  -------------</span><br><span class="line">         [[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],</span><br><span class="line">          [<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>],</span><br><span class="line">          [<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>]]]</span><br><span class="line"></span><br><span class="line">Tensorflow: [<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, ... ]</span><br><span class="line">Caffe: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, ...]</span><br></pre></td></tr></table></figure><blockquote><p>由于 两者 flatten 的顺序在其各自的输入 feature map 索引顺序中都是 <code>3 -&gt; 2 -&gt; 1</code>，因此若这两个 flatten 的输入是一样的话，则它们的输出也是一样的。由于 Caffe 中没有类似 Transpose 这样的层，因此我采取使用 pycaffe 将前向 inference 后 Flatten 层的输入取出，用 numpy 进行 transpose 后，再重新赋给 Flatten 层当输入，然后再次调用 pycaffe 的接口 <code>net.forward(start='', end='')</code> 指定从某个层开始前向传播，这里就指定 start 参数为 Flatten 层的 name. 这样，即可在 Caffe 中得到与 Tensorflow 中同样的 Flatten 层输出。<a href="https://github.com/BVLC/caffe/issues/2725#issue-93930312" target="_blank" rel="noopener">net.forward 指定起点</a><br>Caffe 的 Flatten 层有 <code>axis</code>, <code>end_axis</code> 两个参数，但是我无论如何设置都无法在不对输入进行 transpose 的情况下得到与 Tensorflow 一样的结果。也许是我没理解对这两个参数的意义。<a href="https://caffe.berkeleyvision.org/tutorial/layers/flatten.html" target="_blank" rel="noopener">参考1</a> <a href="https://stackoverflow.com/a/40401460/8149027" target="_blank" rel="noopener">参考2</a></p></blockquote><blockquote><p>  <strong>5-3</strong>. <strong>Padding 操作的区别</strong><br>Caffe 中的所有 padding 操作都是对称的，也就是说如果设置 <code>pad_w=1</code> 则会在 feature map 的左右两边都 pad 一个像素。但是 Tensorflow 不是如此，有可能出现左边 pad 1, 右边 pad 2，或者上边 pad 1,下边 pad 2 的情况。因此，在移植时，要保持在 Tensorflow 和 Caffe 中的 padding 方式都一样，这样才能得到相同的结果。<br>下面讨论 Caffe 的 padding 与 Tensorflow 中 <code>SAME</code> padding 方式的差异。<br>正常情况下，如果 <code>kernel_size=3, stride=1</code> 那么 <code>SAME</code> padding 模式会保持输入输出的尺寸相同，因此，需要在输入的上下左右各 pad 1 个像素。这时，在 Caffe 里只要设置 <code>pad: 1</code> 就行，这样两者 pad 的结果就是一样的了。<br>但是，如果遇到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">≠</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">stride\neq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的情况，情况就变得复杂。有可能两个框架某个 Convolution 或者 Pooling 操作的输入输出尺寸都一样，但是数值却不同。如下图所示 <a href="https://github.com/Microsoft/MMdnn/wiki/Error-in-mobilenet-conversion-from-Tensorflow-to-Caffe-Different-way-of-padding#the-reason-of-the-inconsistent-shapes-is-due-to-symmetric-padding-in-caffe" target="_blank" rel="noopener">来源</a><br><img src="padding_1.png" alt=""><br><img src="padding_2.png" alt=""><br>在 Tensorflow 中, <code>SAME</code> padding 模式的策略是: <a href="https://stackoverflow.com/a/53820765/8149027" target="_blank" rel="noopener">来源</a></p><blockquote><p>First, consider the <code>SAME</code> padding scheme. A detailed explanation of the reasoning behind it is given in these notes. Here, we summarize the mechanics of this padding scheme. When using ‘SAME’, the output height and width are computed as:</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out_height = ceil(float(in_height) / float(strides[<span class="number">1</span>]))</span><br><span class="line">out_width  = ceil(float(in_width) / float(strides[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>The total padding applied along the height and width is computed as:</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SAME padding 长度计算</span></span><br><span class="line"><span class="keyword">if</span> (in_height % strides[<span class="number">1</span>] == <span class="number">0</span>):</span><br><span class="line">  pad_along_height = max(filter_height - strides[<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  pad_along_height = max(filter_height - (in_height % strides[<span class="number">1</span>]), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_width % strides[<span class="number">2</span>] == <span class="number">0</span>):</span><br><span class="line">  pad_along_width = max(filter_width - strides[<span class="number">2</span>], <span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  pad_along_width = max(filter_width - (in_width % strides[<span class="number">2</span>]), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>Finally, the padding on the top, bottom, left and right are:</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pad_top = pad_along_height // <span class="number">2</span></span><br><span class="line">pad_bottom = pad_along_height - pad_top</span><br><span class="line">pad_left = pad_along_width // <span class="number">2</span></span><br><span class="line">pad_right = pad_along_width - pad_left</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>Note that the division by 2 means that there might be cases when the padding on both sides (top vs bottom, right vs left) are off by one. In this case, the bottom and right sides always get the one additional padded pixel. For example, when pad_along_height is 5, we pad 2 pixels at the top and 3 pixels at the bottom. Note that this is different from existing libraries such as cuDNN and Caffe, which explicitly specify the number of padded pixels and always pad the same number of pixels on both sides.</p></blockquote></blockquote><blockquote><blockquote><p>For the <code>VALID</code> scheme, the output height and width are computed as:</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out_height = ceil(float(in_height - filter_height + <span class="number">1</span>) / float(strides[<span class="number">1</span>]))</span><br><span class="line">out_width  = ceil(float(in_width - filter_width + <span class="number">1</span>) / float(strides[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>and no padding is used.</p></blockquote></blockquote><blockquote><p>在我的实例中，由于最后进入 Flatten 层的 feature map 需要是 <code>13x13</code> 的，而输入图像此前一共经过了 3 次下采样，一次 MAX Pool, 两次 Convolution, 都是 <code>kernel_size=3, stride=2</code>。因此，如何使这三次操作的 padding 操作在两个框架中一致就成了关键问题。由于在 SAME padding 中，<br>                           <code>out_height = ceil(float(in_height) / float(strides[1])),</code><br>                           <code>out_width = ceil(float(in_width) / float(strides[2]))</code><br>因此，这三次下采样操作的输入尺寸存在这些可能性</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">              13                      &lt;-  经过第二次 Conv, stride=2</span><br><span class="line">          /         \</span><br><span class="line">         /           \</span><br><span class="line">       25            26               &lt;-  经过第一次 Conv, stride=2</span><br><span class="line">    /     \       /     \</span><br><span class="line">   49     50     51      52           &lt;-   经过 MAX Pooling</span><br><span class="line">  /  \   /  \   /   \   /   \</span><br><span class="line">97   98 99 100 101 102 103 104        &lt;-      输入图像</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>由于 Caffe 只能进行对称 padding，因此要选择一个合适的输入图像尺寸，使得在这三次操作时 Tensorflow 不会出现 padding 不对称的情况 (因为这在 Caffe 中无法实现)。<br>根据上段 <code>SAME padding 长度计算部分的公式</code>，我们要使得 <code>pad_along_width，pad_along_height</code> 的数值为 <strong>偶数</strong>，这样才能对称。因此，要使得 <strong><code>in_height % strides[1] != 0, in_width % strides[2] != 0</code></strong>。由于 <code>strides[1]=2</code>，因此，<code>in_height, in_width</code> 必须是 <strong>奇数</strong>。这样，就可以得到每次操作前的输入尺寸分别是 <code>97 -&gt; 49 -&gt; 25 -&gt; 13</code>。这样，在每次操作时，SAME padding 都会为 feature map 在空间维度上四周各 pad 一个像素。而在 Caffe 的对应层的定义里，只要设置 <code>pad: 1</code> 即可。</p></blockquote><hr><blockquote><p><strong>6</strong>. 关于 Tensorflow 中获取 Graph 中所有节点名称以及 ckpt 文件中的变量。<br>  <strong>6.1</strong>.<strong>读取 ckpt 中的变量</strong> <a href="https://www.jianshu.com/p/75d8df8511bc" target="_blank" rel="noopener">参考</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf;</span><br><span class="line"></span><br><span class="line"> reader = tf.train.NewCheckpointReader(<span class="string">"/path/to/model.ckpt"</span>)</span><br><span class="line"> variables = reader.get_variable_to_shape_map()</span><br><span class="line"> <span class="keyword">for</span> key <span class="keyword">in</span> variables:</span><br><span class="line">      w = reader.get_tensor(key)</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>6.2</strong>. <strong>获取 Graph 中的所有结点名称，并计算得到某节点的值</strong> <a href="https://www.jianshu.com/p/3cee7ca5ebd8" target="_blank" rel="noopener">参考</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all_op_names = [n.name <span class="keyword">for</span> n <span class="keyword">in</span> tf.get_default_graph().as_graph_def().node]</span><br><span class="line">conv1_op = tf.get_default_graph.get_tensor_by_name(<span class="string">'a_tensor_name_from_above_line:0'</span>)  <span class="comment"># 注意要在名称后面加 :0</span></span><br><span class="line">conv1_value = sess.run(conv1_op, feed_dict=&#123;...&#125;)</span><br></pre></td></tr></table></figure><br><h2 id="dump-ckpt-中的参数以及生成-caffemodel-的两个脚本"><a class="markdownIt-Anchor" href="#dump-ckpt-中的参数以及生成-caffemodel-的两个脚本"></a> dump ckpt 中的参数以及生成 caffemodel 的两个脚本</h2><p><a href="dump.py">dump ckpt</a><br><a href="tf2caffe.py">生成 caffemodel</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Caffe </tag>
            
            <tag> Tensorflow </tag>
            
            <tag> Porting </tag>
            
            <tag> 移植 </tag>
            
            <tag> padding </tag>
            
            <tag> flatten </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波</title>
      <link href="/2019/07/04/Kalman-Filter/"/>
      <url>/2019/07/04/Kalman-Filter/</url>
      
        <content type="html"><![CDATA[<p>本文主要关注卡尔曼滤波的流程和 5 个公式。</p><a id="more"></a><p>卡尔曼滤波的主要思想：首先，根据时间步 <code>t-1</code> 的状态空间，通过状态转移矩阵和控制矩阵(控制量)，预测 <code>t</code> 时间步时的状态空间。由于 <code>t-1</code> 时间步的状态空间本身就不是准确的，含有噪声，且状态转移的过程也引入噪声，因此预测得到的 <code>t</code> 时间步的状态空间是不准确的。这时，我们在 <code>t</code> 时间步进行实际的测量，使用得到的测量结果去修正预测得到的状态空间。其实就是对预测的结果和测量的结果根据其不准确度(用协方差矩阵表示)来计算权重(即卡尔曼增益)，对两个结果进行加权平均，并依此得到 <code>t</code> 时间步最优的结果。</p><br><h1 id="卡尔曼滤波的五个公式"><a class="markdownIt-Anchor" href="#卡尔曼滤波的五个公式"></a> 卡尔曼滤波的五个公式</h1><p><img src="format.jpg" alt="卡尔曼公式"></p><br><h1 id="卡尔曼滤波模型"><a class="markdownIt-Anchor" href="#卡尔曼滤波模型"></a> 卡尔曼滤波模型</h1><p><img src="Kalman_filter_model.png" alt="卡尔曼滤波模型"></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Kalman </tag>
            
            <tag> tracking </tag>
            
            <tag> 卡尔曼 </tag>
            
            <tag> 卡尔曼滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】 浅谈多节点 CPU+GPU 协同计算负载均衡性设计</title>
      <link href="/2019/06/26/Heterogeneous-Computing/"/>
      <url>/2019/06/26/Heterogeneous-Computing/</url>
      
        <content type="html"><![CDATA[<p>本文转载自<a href="https://blog.csdn.net/zhang0311/article/details/8224093" target="_blank" rel="noopener">这里</a>，主要讲述了关于基于 CPU+GPU 的混合异构计算系统的内容。</p><a id="more"></a><p>近年来，基于 CPU+GPU 的混合异构计算系统开始逐渐成为国内外高性能计算领域的热点研究方向。在实际应用中，许多基于 CPU+GPU 的混合异构计算机系统表现出了良好的性能。但是，由于各种历史和现实原因的制约，异构计算仍然面临着诸多方面的问题，其中最突出的问题是程序开发困难，尤其是扩展到集群规模级别时这个问题更为突出。主要表现在扩展性、负载均衡、自适应性、通信、内存等方面。</p><h1 id="一-cpugpu协同计算模式"><a class="markdownIt-Anchor" href="#一-cpugpu协同计算模式"></a> 一、 CPU+GPU协同计算模式</h1><p>CPU+GPU异构协同计算集群如图1所示，CPU+GPU 异构集群可以划分成三个并行层次：节点间并行、节点内 CPU 与 GPU 异构并行、设备（CPU 或 GPU）内并行。根据这三个层次我们可以得到 CPU+GPU 异构协同计算模式为：<font color="orange">节点间分布式+节点内异构式+设备内共享式</font>。</p><p><strong>1 节点间分布式</strong><br>CPU+GPU 异构协同计算集群中，各个节点之间的连接与传统 CPU 集群一样，采用网络连接，因此，节点间采用了分布式的计算方式，可以采用 MPI 消息通信的并行编程语言。</p><p><strong>2 节点内异构式</strong><br>CPU+GPU 异构协同计算集群中，每个节点上包含多核 CPU 和一块或多块 GPU 卡，节点内采用了异构的架构，采用主从式的编程模型，即每个 GPU 卡需要由 CPU 进程/线程调用。</p><p>由于每个节点上，CPU 核数也比较多，计算能力也很大，因此，在多数情况下，CPU 也会参与部分并行计算，根据 CPU 是否参与并行计算，我们可以把 CPU+GPU 异构协同计算划分成两种计算模式：</p><p> 1) CPU/GPU 协同计算：CPU 只负责复杂逻辑和事务处理等串行计算，GPU 进行大规模并行计算；<br> 2) CPU+GPU 共同计算：由一个 CPU 进程/线程负责复杂逻辑和事务处理等串行计算，其它 CPU 进程/线程负责小部分并行计算，GPU 负责大部分并行计算。</p><p>由于 CPU/GPU 协同计算模式比 CPU+GPU 共同计算模式简单，下面的介绍中，我们以 CPU+GPU 共同计算模式为例进行展开介绍各种编程模式。</p><p>在 CPU+GPU 共同计算模式下，我们把所有的 CPU 统称为一个设备（device），如双路 8 核 CPU 共有 16 个核，我们把这 16 个核统称成一个设备；每个 GPU 卡成为一个设备。根据这种划分方式，我们可以采用 MPI 进程或 OpenMP 线程控制节点内的各设备之间的通信和数据划分。</p><p><strong>3 设备内共享式</strong><br> 1) CPU 设备：每个节点内的所有多核 CPU 采用了共享存储模型，因此，把节点内的所有多核 CPU 看作一个设备， 可以采用 MPI 进程或 OpenMP 线程、pThread 线程控制这些 CPU 核的并行计算。</p><p> 2) GPU 设备：GPU 设备内有自己独立的 DRAM 存储，GPU 设备也是共享存储模型，在 GPU 上采用 CUDA 或 OpenCL 编程控制 GPU 众核的并行计算。CUDA 编程模式只在 NVIDIA GPU 上支持，OpenCL 编程模式在 NVIDIA GP U和 AMD GPU 都支持。</p><p>根据前面对 CPU+GPU 异构协同计算模式的描述，我们可以得到 CPU+GPU 异构协同计算的编程模型（以 MPI 和 OpenMP 为例）如表1所示。</p><p><img src="pic_1.jpg" alt="图1 CPU+GPU异构协同计算架构"></p><p><img src="pic_2.png" alt="表1 CPU+GPU异构协同计算编程模型"></p><h1 id="二-cpugpu协同计算负载均衡性设计"><a class="markdownIt-Anchor" href="#二-cpugpu协同计算负载均衡性设计"></a> 二、CPU+GPU协同计算负载均衡性设计</h1><p>下面以 模式2 为例简单介绍多节点 CPU+GPU 协同计算任务划分和负载均衡，模式2 的进程和线程与 CPU 核和 GPU 设备对应关系如 图2 所示。若采用主从式 MPI 通信机制，我们在节点 0 上多起一个进程（0号进程）作为主进程，控制其它所有进程。每个节点上启动3个计算进程，其中两个控制 GPU 设备，一个控制其余所有 CPU 核的并行，在 GPU 内采用 CUDA/OpenCL 并行，在 CPU 设备内采用 OpenMP 多线程并行。</p><p>由于 CPU+GPU 协同计算模式分为 3个层次，那么负载均衡性也需要在这 3个层次 上分别设计。在 模式2 的编程方式下，节点内和节点间均采用 MPI 进程，合二为一，设计负载均衡时，只需要做到进程间（设备之间）的负载均衡和 CPU 设备内 OpenMP 线程负载均衡、GPU 设备内 CUDA 线程负载均衡即可。</p><p>对于设备内，采用的是共享存储器模型，CPU 设备上的 OpenMP 线程可以采用 schedule(static / dynamic / guided )方式；GPU 设备上只要保证同一 warp 内的线程负载均衡即可。</p><p>对于 CPU+GPU 协同计算，由于 CPU 和 GPU 计算能力相差很大，因此，在对任务和数据划分时不能给 CPU 设备和 GPU 设备划分相同的任务/数据量，这就增加了 CPU 与 GPU 设备间负载均衡的难度。CPU 与 GPU 之间的负载均衡最好的方式是采用动态负载均衡的方法，然而有些应用无法用动态划分而只能采用静态划分的方式。下面我们分别介绍动态划分和静态划分。</p><p> 1) 动态划分：对于一些高性能计算应用程序，在 CPU 与 GPU 之间的负载均衡可以采用动态负载均衡的优化方法，例如有 N 个任务/数据，一个节点内有 2 个 GPU 卡，即三个设备（CPU 和 2个 GPU），动态负载均衡的方法是每个设备先获取一个任务/数据进行计算，计算之后立即获取下一个任务，不需要等待其他设备，直到 N 个任务/数据计算完成。这种方式只需要在集群上设定一个主进程，负责给各个计算进程分配任务/数据。</p><p> 2) 静态划分：在一些应用中，无法采用动态划分的方式，需要静态划分方法，然而静态划分方法使异构设备间的负载均衡变得困难，有时甚至无法实现。对于一些迭代应用程序，我们可以采用学习型的数据划分方法，如先让 CPU 和 GPU 分别做一次相同计算量的计算，然后通过各自的运行时间计算出 CPU 与 GPU 的计算能力比例，然后再对数据进行划分。</p><p><img src="pic_3.jpg" alt="图2 CPU+GPU协同计算示意图（以每个节点2个GPU为例）"></p><h1 id="三-cpugpu协同计算数据划分示例"><a class="markdownIt-Anchor" href="#三-cpugpu协同计算数据划分示例"></a> 三、CPU+GPU协同计算数据划分示例</h1><p>假设某一应用的数据特点如 图3 所示，从输出看，结果中的每个值的计算需要所有输入数据的信息，所有输出值的计算之间没有任何数据依赖性，可以表示成 outj=；从输入看，每个输入值对所有的输出值都产生影响，所有输入数据之间也没有任何数据依赖性。从数据特点可以看出，该应用既可以对输入进行并行数据划分也可以对输出进行数据划分。下面我们分析 CPU+GPU 协同计算时的数据划分方式。<br><img src="pic_4.jpg" alt="图3 并行数据示例"></p><p><strong>1 按输入数据划分</strong></p><p>假设按输入数据划分，我们可以采用动态的方式给每个 CPU 或 GPU 设备分配数据，做到动态负载均衡，然而这种划分方式，使所有的线程向同一个输出位置保存结果，为了正确性，需要使所有的线程对每个结果进行原子操作，这样将会严重影响性能，极端情况下，所有线程还是按顺序执行的。因此，这种方式效果很差。</p><p><strong>2 按输出数据划分</strong></p><p>按输出数据划分的话可以让每个线程做不同位置的结果计算，计算完全独立，没有依赖性。如果采用静态划分的方式，由于 CPU 和 GPU 计算能力不同，因此，很难做到负载均衡。采用动态的方式可以做到负载均衡，即把结果每次给 CPU 或 GPU 设备一块，当设备计算完本次之后，立即向主进程申请下一个分块，这样可以做到完全负载均衡。按输出数据划分，无论采用静态划分还是动态划分，都会带来另外一个问题，由于每个结果的计算都需要所有输入信息，那么所有进程（设备）都需要读取一遍所有输入数据，动态划分时还不只一次，尤其对于输入数据很大时，这将会对输入数据的IO产生很大的影响，很有可能使 IO 程序性能瓶颈。</p><p><strong>3 按输入和输出同时划分</strong></p><p>由于按输入或按输出划分都存在不同的缺点，我们可以采用输入和输出同时划分的方式进行数据划分，如 图4 所示。</p><p>从输出角度，让所有的计算进程（设备）都有一份计算结果，设备内的线程对结果进行并行计算，每个设备都有一份局部的计算结果，所有设备都计算完毕之后，利用MPI进程对所有设备的计算结果进行规约，规约最后的结果即是最终的结果。</p><p>从输入角度，按输入数据动态划分给不同的计算进程（设备），这样可以满足所有的计算进程负载均衡。<br><img src="pic_5.jpg" alt="图4 CPU+GPU协同计算数据划分示例"></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> CPU </tag>
            
            <tag> GPU </tag>
            
            <tag> 负载均衡 </tag>
            
            <tag> 异构 </tag>
            
            <tag> 协同计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些 C++ 相关的概念和操作</title>
      <link href="/2019/06/26/Cxx-Related/"/>
      <url>/2019/06/26/Cxx-Related/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了一些常用的 C++ 相关的概念和操作。</p><a id="more"></a><br><h3 id="string-与-char-互转"><a class="markdownIt-Anchor" href="#string-与-char-互转"></a> string 与 char* 互转</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string to char*</span></span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"name"</span>;</span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*)name.data();</span><br><span class="line"></span><br><span class="line"><span class="comment">// char* to string</span></span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">"name"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="built_in">string</span>(name);</span><br></pre></td></tr></table></figure><br><h3 id="释放-stdvector-所占用的内存"><a class="markdownIt-Anchor" href="#释放-stdvector-所占用的内存"></a> 释放 std::vector 所占用的内存</h3><blockquote><p>在容器 vector 中，其内存占用的空间是只增不减的，比如说首先分配了 10,000 个字节，然后 erase 掉后面 9999个，则虽然有效元素只有一个，但是内存占用仍为 10,000 个。所有内存空间在 vector 析构时回收。<br>一般，我们都会通过 vector 中成员函数 clear 进行一些清除操作，但它清除的是所有的元素，使 vector 的大小减少至 0，却不能减小 vector 占用的内存。要避免 vector 持有它不再需要的内存，这就需要一种方法来使得它从曾经的容量减少至它现在需要的容量，这样减少容量的方法被称为 “<strong>收缩到合适（shrink to fit）</strong>”。</p></blockquote><p>使用以下代码可以实现此功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt;().swap(X)  <span class="comment">// X 的类型为 std::vector&lt;T&gt;;</span></span><br><span class="line"><span class="comment">//其相当于</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;  temp(X);</span><br><span class="line">temp.swap(X);</span><br></pre></td></tr></table></figure><blockquote><p>其背后原理为:<strong><code>vector()</code> 使用 <code>vector</code> 的默认构造函数建立临时 <code>vector</code> 对象，再在该临时对象上调用 <code>swap</code> 成员，<code>swap</code> 调用之后对象 <code>X</code> 占用的空间就等于一个默认构造的对象的大小，临时对象就具有原来对象 <code>X</code> 的大小，而该临时对象随即就会被析构，从而其占用的空间也被释放。</strong></p></blockquote><p><a href="https://www.cnblogs.com/zhoug2020/p/4058487.html" target="_blank" rel="noopener">参考</a></p><br><h3 id="二维数组和双重指针在内存中的差别"><a class="markdownIt-Anchor" href="#二维数组和双重指针在内存中的差别"></a> 二维数组和双重指针在内存中的差别</h3><p>首先，下例是不可行的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myputs</span><span class="params">(<span class="keyword">char</span> **pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> **p;</span><br><span class="line">    <span class="keyword">char</span> a[ROW][COL]=&#123;<span class="string">"abc"</span>, <span class="string">"def"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    p = a;</span><br><span class="line">    myputs(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myputs</span><span class="params">(<span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ROW; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, p[i][j]); <span class="comment">// 试图用双重指针的方式访问二维数组，不可行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>myputs(char **p)</code> 接受双重指针作为参数，<code>main()</code> 函数将二维数组的头指针赋给双重指针，并作为 <code>myputs(char **p)</code> 的参数传入，再使用 <code>p[i][j]</code> 的方式访问某个元素。这是不行的，而这与两者的内存分布有关。</p><hr><p><strong>二维数组的内存分布</strong></p><blockquote><p>定义了二维数组后，就会在内存中分配一块逻辑上连续的内存块。<code>char c[10][10]</code>，系统就会分配一块 100 字节的连续内存。也就是说这样的二维数组跟一维数组 <code>char c[100]</code> 具有相似的内存分布。<br>二维数组的内存分布如下：<br><img src="2d_array.png" alt="二维数组的内存分布"></p></blockquote><p><strong>双重指针的内存分布</strong></p><blockquote><p>双重指针的内存分配一般采取动态方式<br><img src="2d_pointer.png" alt="双重指针的内存分布"></p></blockquote><p>可以看出，当将二维数组的头指针赋值给双重指针后，再使用 <code>p[i][j]</code> 的方式访问里面的元素，就会出现错误。这是因为，二维数组的内存是以连续的方式分配的，但是在访问时，却使用了双重指针的方式进行访问，这就会导致段错误。</p><hr><p><strong>总结</strong></p><blockquote><p><code>char **p</code> 和 <code>char p[2][3]</code> 之间不能相互传递参数，因为它们具体的内存分布不一样，这样在运行时就会出现段错误。<br>此外还需注意的一点：<br>二维数组中的 <code>a[i][j]</code> 和双重指针中的 <code>a[i][j]</code> 的意思是不一样的。<br>二维数组 <code>int a[10][10]</code> 中，<code>a[i][j]</code> 指的是第 <code>i</code> 行第 <code>j</code> 列数元素。<br>双重指针中 <code>int **a</code> 中， <code>a[i][j]</code> 指的是第 <code>i</code> 个存放 <code>int *</code> 指针所指向地址中的第 <code>j</code> 个元素。也就是 <code>*(*(a+i)+j)</code>。</p></blockquote><p><a href="https://blog.csdn.net/u013684730/article/details/46565577" target="_blank" rel="noopener">原文</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程及相关概念</title>
      <link href="/2019/06/14/Process-and-Thread/"/>
      <url>/2019/06/14/Process-and-Thread/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了进程，线程等相关内容。</p><a id="more"></a><blockquote><p>抛开各种技术细节，从应用程序角度讲：<br>1、在单核计算机里，有一个资源是无法被多个程序并行使用的：CPU。<br>没有操作系统的情况下，一个程序一直独占着全部 CPU。<br>如果要有两个任务来共享同一个 CPU，程序员就需要仔细地为程序安排好运行计划–某时刻 CPU 和由程序 A 来独享，下一时刻 CPU 由程序 B 来独享,而这种安排计划后来成为 OS 的核心组件，被单独名命为 “<strong>scheduler</strong>”，即“<strong>调度器</strong>”，它关心的只是怎样把单个 CPU 的运行拆分成一段一段的“运行片”，轮流分给不同的程序去使用，而在宏观上，因为分配切换的速度极快，就制造出多程序并行在一个 CPU 上的假象。</p></blockquote><blockquote><p>2、在单核计算机里，有一个资源可以被多个程序共用，然而会引出麻烦：<strong>内存</strong>。<br>在一个只有调度器，没有内存管理组件的操作系统上，程序员需要手工为每个程序安排运行的空间 – 程序A使用物理地址 <code>0x00-0xff</code>, 程序B使用物理地址<code>0x100-0x1ff</code>，等等。<br>然而这样做有个很大的问题：每个程序都要协调商量好怎样使用同一个内存上的不同空间，软件系统和硬件系统千差万别，使这种定制的方案没有可行性。<br>为了解决这个麻烦，计算机系统引入了“<strong>虚拟地址</strong>”的概念，从三方面入手来做：<br>2.1、硬件上，CPU 增加了一个专门的模块叫 MMU，负责转换虚拟地址和物理地址。<br>2.2、操作系统上，操作系统增加了另一个核心组件：<strong>memory management</strong>，即内存管理模块，它管理物理内存、虚拟内存相关的一系列事务。<br>2.3、应用程序上，发明了一个叫做【进程】的模型，（注意）每个进程都用【<strong>完全一样的</strong>】虚拟地址空间，然而经由操作系统和硬件MMU协作，映射到不同的物理地址空间上。不同的【进程】，都有各自独立的物理内存空间，不用一些特殊手段，是无法访问别的进程的物理内存的。</p></blockquote><blockquote><p>3、现在，不同的应用程序，可以不关心底层的物理内存分配，也不关心 CPU 的协调共享了。然而还有一个问题存在：有一些程序，想要共享 CPU，【并且还要共享同样的物理内存】，这时候，一个叫【线程】的模型就出现了，它们被包裹在进程里面，在调度器的管理下共享 CPU，拥有同样的虚拟地址空间，同时也共享同一个物理地址空间，然而，它们无法越过包裹自己的进程，去访问别一个进程的物理地址空间。</p></blockquote><blockquote><p>4、进程之间怎样共享同一个物理地址空间呢？不同的系统方法各异，符合 posix 规范的操作系统都提供了一个接口，叫 mmap，可以把一个物理地址空间映射到不同的进程中，由不同的进程来共享。</p></blockquote><blockquote><p>5、PS：在有的操作系统里，进程不是调度单位（即不能被调度器使用），线程是最基本的调度单位，调度器只调度线程，不调度进程，比如 VxWorks<br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html#comment-270980" target="_blank" rel="noopener">来源</a></p></blockquote><br>>CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是 CPU 和相关寄存器以及 RAM 之间的事情。**一个最最基础的事实**：CPU 太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM 和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在 CPU 看来就是轮流着来。**一个必须知道的事实**：执行一段程序代码，实现一个功能的过程介绍 ，当得到 CPU 的时候，相关的资源必须也已经就位，就是显卡啊，GPS 啊什么的必须就位，然后 CPU 开始执行。这里除了 CPU 以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的 CPU 执行时间用完了，那它就要被切换出去，等待下一次 CPU 的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被 CPU 临幸的运行环境，必须保存。**串联起来的事实**：前面讲过在 CPU 看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行 A，保存程序 A 的上下文，调入下一个要执行的程序 B 的程序上下文，然后开始执行 B,保存程序 B 的上下文。。。。<p>========= 重要的东西出现了========<br>进程和线程就是这样的背景出来的，<strong>两个名词不过是对应的CPU时间段的描述，名词就是这样的功能</strong>。<br>进程就是包换上下文切换的程序执行时间总和 = CPU 加载上下文 + CPU 执行 + CPU 保存上下文<br>**线程是什么呢？**进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序 A，实际分成 a，b，c 等多个块组合而成。那么这里具体的执行就可能变成：程序 A 得到 CPU =&gt; CPU 加载上下文，开始执行程序 A 的 a 小段，然后执行 A 的 b 小段，然后再执行 A 的 c 小段，最后 CPU 保存  A 的上下文。这里 a，b，c 的执行是共享了 A 的上下文，CPU 在执行的时候没有进行上下文切换的。这里的 a，b，c 就是线程，也就是说线程是共享了进程的上下文环境的更为细小的 CPU 时间段。到此全文结束，再一个总结：<strong>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。</strong><br><a href="https://www.zhihu.com/question/25532384/answer/81152571" target="_blank" rel="noopener">来源</a></p><blockquote><p>一、 cpu个数、核数、线程数的关系<br>cpu个数：是指物理上，也及硬件上的核心数；<br>核数：是逻辑上的，简单理解为逻辑上模拟出的核心数；<br>线程数：是同一时刻设备能并行执行的程序个数，线程数=cpu个数 * 核数【如果有超线程，再乘以超线程数】</p></blockquote><blockquote><p>二、 cpu线程数和Java多线程<br>首先明白几个概念：<br>(1) 单个cpu线程在同一时刻只能执行单一Java程序，也就是一个线程<br>(2) 单个线程同时只能在单个cpu线程中执行<br>(3) 线程是操作系统最小的调度单位，进程是资源（比如：内存）分配的最小单位<br>(4)Java中的所有线程在JVM进程中,CPU调度的是进程中的线程<br>(5)Java多线程并不是由于cpu线程数为多个才称为多线程，当Java线程数大于cpu线程数，操作系统使用时间片机制，采用线程调度算法，频繁的进行线程切换。</p></blockquote><blockquote><p>a 那么java多进程，每个进程又多线程，cpu是如何调度的呢？<br>个人理解：操作系统并不是单纯均匀的分配cpu执行不同的进程，因为线程是调度的最小单位，所以会根据不同进程中的线程个数进行时间分片，均匀的执行每个线程，也就是说A进程中有10个线程，而B进程中有2个线程，那么cpu分给进程的执行时间理论上应该是5:1才合理。</p></blockquote><blockquote><p>b cpu线程数和java线程数有直接关系吗？<br>个人理解：没有直接关系，正如上面所说，cpu采用分片机制执行线程，给每个线程划分很小的时间颗粒去执行，但是真正的项目中，一个程序要做很多的的操作，读写磁盘、数据逻辑处理、出于业务需求必要的休眠等等操作，当程序在进行I/O操作的时候，线程是阻塞的，线程由运行状态切换到等待状态，此时cpu会做上下文切换，以便处理其他的程序；当I/O操作完成后，cpu 会收到一个来自硬盘的中断信号，并进入中断处理例程，手头正在执行的线程因此被打断，回到 ready 队列。而先前因 I/O 而waiting 的线程随着 I/O 的完成也再次回到 就绪 队列，这时 cpu 可能会选择它来执行。</p></blockquote><blockquote><p>c 如何确定程序线程数？<br>个人理解：如果所有的任务都是计算密集型的，则创建的多线程数 = 处理器核心数就可以了<br>如果io操作比较耗时，则根据具体情况调整线程数，此时 多线程数 = n*处理器核心数<br>一般情况程序线程数等于cpu线程数的两到三倍就能很好的利用cpu了，过多的程序线程数不但不会提高性能，反而还会因为线程间的频繁切换而受影响，具体需要根据线程处理的业务考略，不断调整线程数个数，确定当前系统最优的线程数。<br><a href="https://blog.csdn.net/wutongyuWxc/article/details/78732287" target="_blank" rel="noopener">原文</a></p></blockquote><br><h2 id="一篇非常好的文章"><a class="markdownIt-Anchor" href="#一篇非常好的文章"></a> 一篇非常好的文章</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/1352974" target="_blank" rel="noopener">进程与线程，单核与多核</a></p></blockquote><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
            <tag> CPU </tag>
            
            <tag> Process </tag>
            
            <tag> Thread </tag>
            
            <tag> 阻塞 </tag>
            
            <tag> 非阻塞 </tag>
            
            <tag> 单核 </tag>
            
            <tag> 多核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轻量卷积神经网络的一些操作</title>
      <link href="/2019/06/03/light-weight-CNN-operations/"/>
      <url>/2019/06/03/light-weight-CNN-operations/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录一些在卷积神经网络轻量化的研究中出现的一些操作，其主要是针对卷积进行的。</p><a id="more"></a><h1 id="depthwise-convolution-and-pointwise-convolution"><a class="markdownIt-Anchor" href="#depthwise-convolution-and-pointwise-convolution"></a> Depthwise Convolution and Pointwise Convolution</h1><p><font color="orange">深度卷积</font> 分解一个标准的卷积为一个 depthwise convolution 和一个 pointwise convolution, 是对输入的每一个 channel 独立进行卷积，输入 feature map 的每个 channel 会输出 <strong>channel_multiplier</strong> (通常为 1) 个通道，最后的 feature map 就会有 in_channels * channel_multiplier 个通道了。</p><hr><p><img src="convs.jpg" alt="传统卷积和深度卷积以及逐点卷积的对比_1"></p><hr><p><img src="convs_2.jpg" alt="传统卷积和深度卷积以及逐点卷积的对比_2"></p><br><h1 id="group-convolution-and-channel-shuffle"><a class="markdownIt-Anchor" href="#group-convolution-and-channel-shuffle"></a> Group Convolution and channel shuffle</h1><p><img src="GConv.png" alt="分组卷积"></p><p><font color="orange"><strong>Group Convolution</strong></font> 顾名思义，是对输入 feature map 进行分组，然后每组分别卷积。假设输入 feature map 的尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi mathvariant="normal">∗</mi><mi>H</mi><mi mathvariant="normal">∗</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">C∗H∗W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>，输出 feature map 的数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，如果设定要分成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 个 groups，则每组的输入 feature map 数量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>C</mi><mi>G</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{C}{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，每组的输出 feature map 数量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>N</mi><mi>G</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，每个卷积核的尺寸为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>C</mi><mi>G</mi></mfrac><mo>×</mo><mi>K</mi><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\frac{C}{G}\times K\times K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>，卷积核的总数仍为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个，每组的卷积核数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>N</mi><mi>G</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，卷积核只与其同组的输入 map 进行卷积，卷积核的总参数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><mfrac><mi>C</mi><mi>G</mi></mfrac><mo>×</mo><mi>K</mi><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">N\times \frac{C}{G}\times K\times K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>，可见，总参数量减少为原来的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>G</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，其连接方式如上图右所示，group 1 的输出 map 数为 2，有 2 个卷积核，每个卷积核的 channel 数为 4，与 group1 的输入 map 的 channel 数相同，卷积核只与同组的输入 map 卷积，而不与其他组的输入 map 卷积。</p><p><font color="orange"><strong>Channel shuffle</strong></font>: 因为在<strong>同一组中不同的通道蕴含的信息可能是相同的</strong>，如果不进行通道交换的话，<strong>学出来的特征会非常局限</strong>。如果在不同的组之后交换一些通道，那么就能<strong>交换信息，使得各个组的信息更丰富</strong>，能提取到的特征自然就更多，这样是有利于得到更好的结果。</p><hr><p><img src="channel_shuffle.jpg" alt="Channel Shuffle"></p><p>ShuffleNet主要拥有两个创新点：</p><blockquote><ol><li>pointwise group convolution <font color="orange"><strong>逐点组卷积，就是带分组的卷积核为1×1的卷积，也就是说逐点组卷积是卷积核为 1×1 的分组卷积</strong></font>。</li><li>channel shuffle</li></ol></blockquote><p>原因：</p><blockquote><ol><li>逐点卷积占了很大的计算量 ———&gt; 逐点分组卷积</li><li>不同组之间特征通信问题   ———&gt; channel shuffle</li></ol></blockquote><hr><p><font color="orange"><strong>GDC :</strong></font> 更进一步，如果分组数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mi>N</mi><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">G=N=C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>，同时卷积核的尺寸与输入 map 的尺寸相同，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>=</mo><mi>H</mi><mo>=</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">K=H=W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>，则输出 map 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi mathvariant="normal">∗</mi><mn>1</mn><mi mathvariant="normal">∗</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">C∗1∗1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">∗</span><span class="mord">1</span><span class="mord">∗</span><span class="mord">1</span></span></span></span> 即长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 的向量，此时称之为 <strong>Global Depthwise Convolution（GDC）</strong>，见 MobileFaceNet，可以看成是全局加权池化，与 Global Average Pooling（GAP） 的不同之处在于，GDC 给每个位置赋予了可学习的权重（对于已对齐的图像这很有效，比如人脸，中心位置和边界位置的权重自然应该不同），而 GAP 每个位置的权重相同，全局取个平均，如下图所示：</p><hr><p><img src="GDC.png" alt="Global Depthwise Convolution"></p><br><h1 id="squeeze-and-excitation-module"><a class="markdownIt-Anchor" href="#squeeze-and-excitation-module"></a> Squeeze-and-Excitation module</h1><p><font color="orange"><strong>SE module</strong></font> 通过学习的方式来自动获取到每个特征通道的重要程度，然后依照计算出来的重要程度去提升有用的特征并抑制对当前任务用处不大的特征。<br><img src="SE.jpg" alt="SE module"></p><hr><blockquote><ol><li>首先做普通的卷积，得到了一个 output feature map，它的 shape 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>C</mi><mi mathvariant="normal">，</mi><mi>H</mi><mi mathvariant="normal">，</mi><mi>W</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[C，H，W]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mclose">]</span></span></span></span>，根据论文观点，这个 feature map 的特征很混乱。为了获得重要性的评价指标，直接对这个 feature map 做一个 Global Average Pooling，然后我们就得到了长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 的向量。（这里还涉及到一个额外的东西，如果你了解卷积，你就会发现一旦某一特征经常被激活，那么 Global Average Pooling 计算出来的值会比较大，说明它对结果的影响也比较大，反之越小的值，对结果的影响就越小）</li><li>然后我们对这个向量加两个 FC 层，做非线性映射，这两个 FC 层的参数，也就是网络需要额外学习的参数。</li><li>最后输出的向量，我们可以看做特征的重要性程度，然后与 feature map 对应 channel 相乘就得到特征有序的 feature map 了。</li></ol></blockquote><hr>]]></content>
      
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> Convolution </tag>
            
            <tag> FLOPs </tag>
            
            <tag> mobile </tag>
            
            <tag> shuffle </tag>
            
            <tag> SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的使用流程</title>
      <link href="/2019/05/31/Git-Usage/"/>
      <url>/2019/05/31/Git-Usage/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录一些使用 Git 进行版本管理的流程和命令。</p><a id="more"></a><h1 id="概念建立"><a class="markdownIt-Anchor" href="#概念建立"></a> 概念建立</h1><p>1 工作区: 代码所在的文件路径<br>2 暂存区: 使用 <code>git add &lt;filename&gt;</code>，将文件 <filename> 添加进 暂存区，待后续操作。<br>3 本地仓库: 使用  <code>git commit -m &quot;comments here&quot;</code> 将 暂存区的所有文件 commit 到本地仓库，本地仓库位于本机。<br>4 远程仓库: 在服务器端运行，可将本地仓库内容通过 <code>git push</code> 推送到远程仓库。</filename></p><br><h1 id="本地仓库和远程仓库的创建"><a class="markdownIt-Anchor" href="#本地仓库和远程仓库的创建"></a> 本地仓库和远程仓库的创建</h1><h2 id="1-添加远程库"><a class="markdownIt-Anchor" href="#1-添加远程库"></a> 1. 添加远程库</h2><p>为了方便管理，创建 git 用户.<br>在远程服务器上安装好 git 后，使用以下命令创建远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir example.git</span><br><span class="line"><span class="built_in">cd</span> example.git</span><br><span class="line">git --bare init</span><br></pre></td></tr></table></figure><p>用 <code>chown -R git:git example.git</code> 将 <code>example.git</code> 的所有者和群组改为 git.</p><h2 id="2-添加本地仓库"><a class="markdownIt-Anchor" href="#2-添加本地仓库"></a> 2. 添加本地仓库</h2><p>若已经拥有了远程仓库，可以通过 <code>git clone &lt;example.git&gt;</code> 的命令将远程仓库 clone 到本地。<br>若是对已存在的工程添加 git 管理，则在工程目录下，使用 <code>git init</code> 命令将其变成 git 管理的仓库。</p><br><h1 id="常用的-git-流程"><a class="markdownIt-Anchor" href="#常用的-git-流程"></a> 常用的 git 流程</h1><p>创建好本地仓库和远程仓库后，就可以使用 git 进行版本控制了。<br>若是对已存在的工程进行操作，则流程如下:</p><blockquote><p>1  使用 git add <filename> 的方式将文件添加到暂存区。若某工程第一次使用 git，用 <code>git add .</code> 将工程目录下的所有文件添加到暂存区。此操作可以在 <code>Git bash</code> 中通过命令行操作，或者在 <code>Git GUI</code> 通过图形界面操作。</filename></p></blockquote><blockquote><hr><p>2  若已在暂存区中添加了一些文件，可以通过 <code>git commit -m &quot;comments here&quot;</code> 将暂存区中所有文件 commit 到本地仓库的当前分支。</p></blockquote><blockquote><hr><p>3  若要将本地的当前分支，如 master 分支推送到远程仓库的 master 分支，则使用 <code>git push</code> 命令。</p><blockquote><p>注意: 应先将本地仓库与远程仓库关联，在本地 <code>example</code> 工程下，使用语句 <code>git remote add origin git@10.167.93.74:/path/to/example.git</code>. 这样，就将 <code>10.167.93.74:/path/to/example.git</code> 与本地 <code>example</code> 仓库关联上了。添加后，远程库的名字就是 <code>origin</code>，这是 Git 默认的叫法，也可以改成别的，但是 <code>origin</code> 这个名字一看就知道是远程库。</p></blockquote></blockquote><blockquote><blockquote><hr><p>关联后，使用命令 <code>git push -u origin master</code> 第一次推送 <code>master</code> 分支的所有内容；</p></blockquote></blockquote><blockquote><blockquote><hr><p>此后，每次本地提交后，只要有必要，就可以使用命令 <code>git push origin master</code> 推送最新修改；</p></blockquote></blockquote><blockquote><p>注意: 若不想将工程路径下的所有文件添加版本管理，则可以只将部分文件进行 add, 对从未进行过 add 操作的文件，将被视作 <code>untracked</code>.</p></blockquote><blockquote><hr><p>4  若对已经被 Git 管理的多个文件在某次 commit 后进行了修改，想将这些文件一次性进行 add，可以使用命令 <code>git add -u</code>. 这样，就不会将那些 <code>untracked</code> 的文件添加进暂存区 (git 术语为进行 stage). 若使用 <code>git add .</code> 命令，将会提交 <strong>新文件</strong> (new) 和 <strong>被修改</strong> (modified) 文件，这时，那些 <code>untracked</code> 的文件会被看作 <code>新文件</code>。</p><blockquote><p><code>Git add</code> 命令的 3 种用法:</p></blockquote></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .  : 监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改 (modified) 以及新文件 (new)，但不包括被删除的文件。</span><br><span class="line">git add -u : 仅监控已经被 add 的文件（即 tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add --update 的缩写）</span><br><span class="line">git add -A : 上面两个功能的合集（git add --all 的缩写）</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>示例</p></blockquote></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line"><span class="built_in">echo</span> Change me &gt; change-me</span><br><span class="line"><span class="built_in">echo</span> Delete me &gt; delete-me</span><br><span class="line">git add change-me delete-me</span><br><span class="line">git commit -m initial</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> OK &gt;&gt; change-me</span><br><span class="line">rm delete-me</span><br><span class="line"><span class="built_in">echo</span> Add me &gt; add-me</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># Changed but not updated:</span></span><br><span class="line"><span class="comment">#   modified:   change-me</span></span><br><span class="line"><span class="comment">#   deleted:    delete-me</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   add-me</span></span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   new file:   add-me</span></span><br><span class="line"><span class="comment">#   modified:   change-me</span></span><br><span class="line"><span class="comment"># Changed but not updated:</span></span><br><span class="line"><span class="comment">#   deleted:    delete-me</span></span><br><span class="line"></span><br><span class="line">git reset</span><br><span class="line"></span><br><span class="line">git add -u</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   modified:   change-me</span></span><br><span class="line"><span class="comment">#   deleted:    delete-me</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   add-me</span></span><br><span class="line"></span><br><span class="line">git reset</span><br><span class="line"></span><br><span class="line">git add -A</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   new file:   add-me</span></span><br><span class="line"><span class="comment">#   modified:   change-me</span></span><br><span class="line"><span class="comment">#   deleted:    delete-me</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><p><a href="https://www.cnblogs.com/skura23/p/5859243.html" target="_blank" rel="noopener">参考</a></p></blockquote></blockquote><br><h1 id="常用-git-命令"><a class="markdownIt-Anchor" href="#常用-git-命令"></a> 常用 Git 命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git status</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">git push &lt;remote&gt; &lt;<span class="built_in">local</span> branch name&gt;:&lt;remote branch to push into&gt;</span><br><span class="line">git <span class="built_in">log</span> --graph <span class="comment">#查看树状图</span></span><br></pre></td></tr></table></figure><br><h1 id="常用-git-工具"><a class="markdownIt-Anchor" href="#常用-git-工具"></a> 常用 Git 工具</h1><p>· Git Bash<br>· Git GUI<br>· Pycharm 上的 Git</p><br><h1 id="教程"><a class="markdownIt-Anchor" href="#教程"></a> 教程</h1><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程-廖雪峰</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> version control </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AlexeyAB/Darknet 的使用经验总结</title>
      <link href="/2019/05/31/AlexyAB-Darknet/"/>
      <url>/2019/05/31/AlexyAB-Darknet/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了 GitHub 上的热门 Repo <a href="https://github.com/AlexeyAB/darknet" target="_blank" rel="noopener">AlexeyAB/Darknet</a> 的一些使用要点。</p><a id="more"></a><h1 id="与-opencv-的速度比较"><a class="markdownIt-Anchor" href="#与-opencv-的速度比较"></a> 与 OpenCV 的速度比较</h1><blockquote><p> 使用 GPU 时此 Repo 速度比 OpenCV 快<br> 使用 CPU 时此 Repo 速度比 OpenCV 慢<br><a href="https://github.com/AlexeyAB/darknet/issues/3273#issuecomment-497096110" target="_blank" rel="noopener">来源</a></p></blockquote><br><h1 id="finetune-相关"><a class="markdownIt-Anchor" href="#finetune-相关"></a> Finetune 相关</h1><p>记在 base 数据集上训练得到的模型为 yolov3-old.weights, 当有新增数据集时，</p><blockquote><p> 若新增数据集和 base 数据<br>集类别一致，则在 yolov3-old.weights 的基础上，用 base+新增数据 进行训练。</p></blockquote><hr><blockquote><p> 若新增数据集包含其他类别，则先用 <code>darknet.exe partial cfg/yolov3.cfg yolov3.weights yolov3.conv.81 81</code> 得到 <code>yolov3.conv.81</code> 模型，再在此模型上用新数据集进行训练。<a href="https://github.com/AlexeyAB/darknet/issues/3264#issuecomment-496725772" target="_blank" rel="noopener">来源</a> <a href="https://github.com/AlexeyAB/darknet/blob/55dcd1bcb8d83f27c9118a9a4684ad73190e2ca3/build/darknet/x64/partial.cmd#L27" target="_blank" rel="noopener">partial命令</a></p></blockquote><br><h1 id="处理逻辑"><a class="markdownIt-Anchor" href="#处理逻辑"></a> 处理逻辑</h1><p>以使用单个 GPU 进行处理为例:</p><h2 id="训练"><a class="markdownIt-Anchor" href="#训练"></a> 训练</h2><p>假设 cfg 文件中定义的 <code>batch=64</code>, <code>subdivisions=16</code></p><hr><blockquote><p>&lt;1&gt; 解析各种配置文件，如 <code>coco.data</code>, <code>coco.names</code> 等，获取各种参数。<br>&lt;2&gt; 解析 <code>cfg</code> 文件并将其实例化为 <code>network net</code> 对象. (注意，此过程中 net.batch 参数不是 cfg 文件中的 batch 值，而是 cfg 文件中 batch/subdivisions 得到的值。<code>net.batch</code> 的值为真正进行前向传播时的 batch size)<br>&lt;3&gt; 加载预训练模型 - <code>weights</code> 文件到 <code>net</code> 对象中。<br>&lt;4&gt; 获取所有训练图像的路径。<br>&lt;5&gt; 创建一个线程用来从磁盘中 load 数据，每次从磁盘中 load cfg 文件中的 batch 张图像到内存。<br>&lt;6&gt; 迭代训练。<br>  &lt;6.1&gt; 将一次从磁盘中读取的 batch (cfg 文件中) 张图像分成 <code>subdivisions</code> 份，即每份为 <code>net.batch</code>。使用 <code>net.batch</code> 张图像进行一次迭代，同时返回一个 <code>batch</code> 的 <code>loss</code>，最后，对 <code>subdivisions</code> 个 batch 的 loss 进行加和平均，得到一次从磁盘读取的所有图像 (cfg 中 batch 张) 的平均 loss.<br>  &lt;6.2&gt; 不断重复步骤 6.1，在某些迭代次数时生成模型以及计算 mAP.</p></blockquote><hr><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p>由于 AlexeyAB 没有提供 批量测试 函数 (Batch Inference), 因此我自己实现了此功能。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// network.c 中添加以下函数</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> **<span class="title">network_predict_image_batch_gpu</span><span class="params">(<span class="keyword">float</span> *imgBatch, network* net, <span class="keyword">float</span> thresh, <span class="keyword">float</span> hier_thresh, <span class="keyword">float</span> nms, metadata meta, <span class="keyword">int</span>* box_nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> w = network_width(net);</span><br><span class="line"><span class="keyword">int</span> h = network_height(net);</span><br><span class="line"><span class="keyword">int</span> batch = net-&gt;batch;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// predict batch images</span></span><br><span class="line">network_predict(*net, imgBatch);</span><br><span class="line"><span class="built_in">free</span>(imgBatch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> **results = (<span class="keyword">float</span>**)<span class="built_in">calloc</span>(batch, <span class="keyword">sizeof</span>(<span class="keyword">float</span>*));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batch; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nboxes = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> letterbox = <span class="number">0</span>;</span><br><span class="line">detection * dets = get_network_boxes(net, w, h, thresh, hier_thresh, <span class="number">0</span>, <span class="number">1</span>, &amp;nboxes, letterbox);</span><br><span class="line">do_nms_sort(dets, nboxes, meta.classes, nms);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> real_box_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nboxes; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; meta.classes; s++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dets[j].prob[s] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">real_box_num += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(box_nums + i, &amp;real_box_num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">float</span> *res = (<span class="keyword">float</span>*)<span class="built_in">calloc</span>(real_box_num * <span class="number">6</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>)); <span class="comment">// 6 is &#123;x, y, w, h, prob, class&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nboxes; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; meta.classes; s++) &#123;</span><br><span class="line"><span class="keyword">float</span> now_prob = dets[j].prob[s];</span><br><span class="line"><span class="keyword">if</span> (now_prob &gt; <span class="number">0</span>) &#123;</span><br><span class="line">box b = dets[j].bbox;</span><br><span class="line"><span class="keyword">char</span> * nameTag = meta.names[s];</span><br><span class="line"><span class="keyword">float</span> x_ctr = b.x;</span><br><span class="line"><span class="keyword">float</span> y_ctr = b.y;</span><br><span class="line"><span class="keyword">float</span> width = b.w;</span><br><span class="line"><span class="keyword">float</span> height = b.h;</span><br><span class="line"><span class="keyword">float</span> cls_idx = (<span class="keyword">float</span>)s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(res, &amp;x_ctr, <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">res += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res, &amp;y_ctr, <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">res += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res, &amp;width, <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">res += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res, &amp;height, <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">res += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res, &amp;now_prob, <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">res += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res, &amp;cls_idx, <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">res += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res -= real_box_num * <span class="number">6</span>;</span><br><span class="line">results[i] = res;</span><br><span class="line"></span><br><span class="line">free_detections(dets, nboxes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; net-&gt;n; k++) &#123;</span><br><span class="line">layer temp_layer = net-&gt;layers[k];</span><br><span class="line"><span class="keyword">if</span> (temp_layer.type == YOLO || temp_layer.type == REGION || temp_layer.type == DETECTION) &#123;</span><br><span class="line">net-&gt;layers[k].output = net-&gt;layers[k].output + net-&gt;layers[k].outputs;</span><br><span class="line"><span class="comment">//temp_layer.output = temp_layer.output + temp_layer.outputs; 原来的版本</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要将 darknet 编译成 dll 供其他程序使用，则在 darknet.h 里 network_predict_image 附近 加上</span></span><br><span class="line">LIB_API float **network_predict_image_batch_gpu(float *imgBatch, network* net, float thresh, float hier_thresh, float nms, metadata meta, int* box_nums)；</span><br></pre></td></tr></table></figure><p>调用此函数的示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* configPath = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/cfg/yolov3-mlit-SD.cfg"</span>;</span><br><span class="line"><span class="keyword">char</span>* weightPath = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/backup/yolov3-mlit-SD_50000.weights"</span>;</span><br><span class="line"><span class="keyword">char</span>* metaPath = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/cfg/mlit.data"</span>;</span><br><span class="line"><span class="built_in">string</span> result_dir = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/result/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* img_path_1 = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/test_images/test_1.jpg"</span>;</span><br><span class="line"><span class="keyword">char</span>* img_path_2 = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/test_images/test_2.jpg"</span>;</span><br><span class="line"><span class="keyword">char</span>* img_path_3 = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/test_images/test_3.jpg"</span>;</span><br><span class="line"><span class="keyword">char</span>* img_path_4 = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/test_images/test_4.jpg"</span>;</span><br><span class="line"><span class="keyword">char</span>* img_path_5 = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/test_images/test_5.jpg"</span>;</span><br><span class="line"><span class="keyword">char</span>* img_path_6 = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/test_images/test_6.jpg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> batchSize = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **img_paths = (<span class="keyword">char</span>**)<span class="built_in">calloc</span>(batchSize, <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">img_paths[<span class="number">0</span>] = img_path_1;</span><br><span class="line">img_paths[<span class="number">1</span>] = img_path_2;</span><br><span class="line">img_paths[<span class="number">2</span>] = img_path_3;</span><br><span class="line">img_paths[<span class="number">3</span>] = img_path_4;</span><br><span class="line">img_paths[<span class="number">4</span>] = img_path_5;</span><br><span class="line">img_paths[<span class="number">5</span>] = img_path_6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> conf_thresh = <span class="number">0.6</span>;</span><br><span class="line"><span class="keyword">float</span> hier_thresh = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">float</span> nms = <span class="number">0.45</span>;</span><br><span class="line"></span><br><span class="line">cuda_set_device(<span class="number">0</span>);</span><br><span class="line">network* netMain = load_network_custom(configPath, weightPath, <span class="number">0</span>, batchSize);</span><br><span class="line">metadata metaMain = get_metadata(metaPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> input_w = network_width(netMain);</span><br><span class="line"><span class="keyword">int</span> input_h = network_height(netMain);</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//int num_calsses = metaMain.classes;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里得到的 batch 就是上面手动设置的 batchSize</span></span><br><span class="line"><span class="keyword">int</span> batch = netMain-&gt;batch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 char** 中读取图像数据，并合并成 float *</span></span><br><span class="line"><span class="keyword">float</span> *imgBatch = (<span class="keyword">float</span>*)<span class="built_in">calloc</span>(batch * input_w * input_h * c, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//No OpenCV</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batch; i++) &#123;</span><br><span class="line">image dark_image = load_image_color(img_paths[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">image resized = resize_image(dark_image, input_w, input_h);</span><br><span class="line"><span class="built_in">memcpy</span>(imgBatch + i*input_w*input_h*c, resized.data, input_w*input_h*c * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *box_num_batch = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(batch, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">float</span> **results = network_predict_image_batch_gpu(imgBatch, netMain, conf_thresh, hier_thresh, nms, metaMain, box_num_batch);</span><br><span class="line"><span class="keyword">float</span> *res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 results</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batch; i++) &#123;</span><br><span class="line">cv::Mat image2show = cv::imread(img_paths[i]);</span><br><span class="line"><span class="keyword">int</span> ori_w = image2show.cols;</span><br><span class="line"><span class="keyword">int</span> ori_h = image2show.rows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nbox = *(box_num_batch + i);</span><br><span class="line">res = results[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; nbox &lt;&lt; <span class="string">" boxes detected"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nbox; j++) &#123;</span><br><span class="line"><span class="keyword">float</span> x_ctr = res[<span class="number">0</span> + <span class="number">6</span> * j];</span><br><span class="line"><span class="keyword">float</span> y_ctr = res[<span class="number">1</span> + <span class="number">6</span> * j];</span><br><span class="line"><span class="keyword">float</span> width = res[<span class="number">2</span> + <span class="number">6</span> * j];</span><br><span class="line"><span class="keyword">float</span> height = res[<span class="number">3</span> + <span class="number">6</span> * j];</span><br><span class="line"><span class="keyword">float</span> prob = res[<span class="number">4</span> + <span class="number">6</span> * j];</span><br><span class="line"><span class="keyword">float</span> cls_idx = res[<span class="number">5</span> + <span class="number">6</span> * j];</span><br><span class="line"><span class="keyword">char</span> * nameTag = metaMain.names[(<span class="keyword">int</span>)(cls_idx)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w_on_ori = (<span class="keyword">int</span>)(width * ori_w);</span><br><span class="line"><span class="keyword">int</span> h_on_ori = (<span class="keyword">int</span>)(height * ori_h);</span><br><span class="line"><span class="keyword">int</span> lft = (<span class="keyword">int</span>)(x_ctr * ori_w - w_on_ori / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> rgt = (<span class="keyword">int</span>)(x_ctr * ori_w + w_on_ori / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> top = (<span class="keyword">int</span>)(y_ctr * ori_h - h_on_ori / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> bot = (<span class="keyword">int</span>)(y_ctr * ori_h + h_on_ori / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">cv::<span class="function">Point <span class="title">pt1</span><span class="params">(lft, top)</span></span>;</span><br><span class="line">cv::<span class="function">Point <span class="title">pt2</span><span class="params">(rgt, bot)</span></span>;</span><br><span class="line">cv::rectangle(image2show, pt1, pt2, Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> text = <span class="built_in">std</span>::<span class="built_in">string</span>(nameTag) + <span class="string">" ["</span> + to_string(<span class="keyword">int</span>(round(prob * <span class="number">100</span>))) + <span class="string">"]"</span>;</span><br><span class="line">cv::putText(image2show, text, Point(pt1.x, pt1.y - <span class="number">5</span>), cv::FONT_HERSHEY_COMPLEX, <span class="number">0.5</span>, Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; %d %d %d %d %f &lt;&lt;&lt; "</span>, (<span class="keyword">int</span>)(x_ctr * ori_w), (<span class="keyword">int</span>)(y_ctr * ori_h), (<span class="keyword">int</span>)(width * ori_w), (<span class="keyword">int</span>)(height * ori_h), prob);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; nameTag &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv::imshow(<span class="string">"detected"</span>, image2show);</span><br><span class="line">cv::waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//free(res);</span></span><br><span class="line"><span class="comment">//free_detections(res, nbox);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(box_num_batch);</span><br><span class="line"><span class="built_in">free</span>(results);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="主存与显存"><a class="markdownIt-Anchor" href="#主存与显存"></a> 主存与显存</h1><p>在此 repo 的实现中，数据是先从磁盘读取到主存中，然后在使用 GPU 进行训练前，将主存中的数据拷贝至显存对象中，然后使用 GPU 进行运算。<br>参考 <code>network_kernels.cu</code> 中的 <code>float *network_predict_gpu(network net, float *input)</code> 函数。</p><p>在 Traffic counter 项目中，将来可能使用 GPU 版本的解码器，此解码器解码后的图像数据是在显存中的。因此，设想在将来的处理中，将略过从主存往显存拷贝数据这一步骤，直接传递显存中的对象，并进行处理。具体实现时，可重点参考 <code>float *network_predict_gpu(network net, float *input)</code> 函数。</p><h2 id="confidence-threshold"><a class="markdownIt-Anchor" href="#confidence-threshold"></a> Confidence threshold</h2><h2 id="nms-threshold"><a class="markdownIt-Anchor" href="#nms-threshold"></a> NMS threshold</h2><hr>]]></content>
      
      
      
        <tags>
            
            <tag> gpu </tag>
            
            <tag> yolo </tag>
            
            <tag> yolov3 </tag>
            
            <tag> darknet </tag>
            
            <tag> cpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV 4.0.1 + CUDA 8.0 + Visual Studio 2015 + Win10</title>
      <link href="/2019/05/20/Build-opencv-with-GPU/"/>
      <url>/2019/05/20/Build-opencv-with-GPU/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了使用 CUDA 8.0，Visual Studio 2015，Win10 来编译 OpenCV 4.0.1 的步骤。</p><a id="more"></a><h1 id="安装流程"><a class="markdownIt-Anchor" href="#安装流程"></a> 安装流程</h1><blockquote><p>[1].   安装好 CUDA 8.0. 各种路径添加到环境变量。</p></blockquote><hr><blockquote><p>[2]. 下载 Opencv 源码到 <code>&lt;OpenCV_DIR&gt;</code> 及 对应版本的 opencv_contrib 到 <code>&lt;OpenCV_CONTRIB_DIR&gt;</code>.</p></blockquote><hr><blockquote><p>[3]. Cmake 生成 VS solution。<br>  3.1 打开 cmake. 在 <code>where is the source code</code> 中填入 <code>&lt;OpenCV_DIR&gt;</code>, 在 <code>Where to build the binaries</code> 中 填入 <code>&lt;OpenCV_DIR/build&gt;</code>。<br>  3.2 点击 configure, 选择 <code>Visual Studio 14 2015 Win64</code>. (一定要选带有 Win 64 字样的，否则会出错)<br>  3.3 点击 Finish。会进行 Configure。中途可能会跳出红色错误，这是由于下载 ffmpeg, ippicv, data, xfeatures2d 相关的文件失败造成的。报错信息里会提示查看 log 文件，打开 log 文件后，根据信息，手动到网址下去下载 dll, zip, cmake 等文件，下载好后，以 <code>&lt;MD码&gt;-&lt;name&gt;.&lt;ext&gt;</code> 的方式命名，放在 <code>&lt;OpenCV_DIR/.cache&gt;</code> 下的相关路径中。重新点击 configure.<br>  3.4 勾选中复选框 <code>BUILD_opencv_world</code>, <code>WITH_CUDA</code>, <code>OPENCV_ENABLE_NONFREE</code>. 将 <code>&lt;OpenCV_CONTRIB_DIR/modules&gt;</code> 路径添加到 <code>OPENCV_EXTRA_MODULES_PATH</code> 中，再次点击 Configure.<br>  3.5 勾选 <code>CUDA_FAST_MATH</code>, 点击 Configure. 屏幕上应该一片白，没有红色信息.<br>  3.5 点击 Generate 以生成 sln. 此过程不应报错。</p></blockquote><hr><blockquote><p>[4]. VS 编译 Opencv.sln<br>  4.1 <code>&lt;OpenCV_DIR/build&gt;</code> 下打开 OpenCV.sln, 点击 生成 -&gt; 配置管理器，选择 <code>Release</code>, <code>x64</code>.<br>  4.2 将 <code>color_detail.hpp</code> 的 <code>96-127</code> 行的 <strong><code>const</code></strong> 替换为 <strong><code>constexpr</code></strong>. 否则会出现 <code>error : dynamic initialization is not supported for a __constant__ variable</code> 的错误. <a href="https://github.com/opencv/opencv/issues/13491#issuecomment-450754826" target="_blank" rel="noopener">来源1</a>  <a href="https://answers.opencv.org/question/205673/building-opencv-with-cuda-win10-vs-2017/" target="_blank" rel="noopener">来源2</a><br>  4.3 生成 <code>ALL_BUILD</code>. (主要关注 opencv_world 工程，此工程生成成功即可，实际过程中出现了 opencv_perf_gapi 和 opencv_test_gapi 工程报错的问题，貌似对我们的项目没有影响。)<br>  4.4 成功生成 <code>ALL_BUILD</code> 后 (生成了 opencv_world401.lib 和 opencv_world401.dll)，右键 <code>INSTALL</code> -&gt; <code>仅用于项目</code> -&gt; <code>仅生成INSTALL</code>.<br>  4.5 在 <code>&lt;OpenCV_DIR/install&gt;</code> 下是最后得到的 lib, dll，头文件等。</p></blockquote><h1 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h1><p><a href="https://blog.csdn.net/Gordon_Wei/article/details/85775328" target="_blank" rel="noopener">【OpenCV】opencv4.0.1+opencv_contrib4.0.1+VS2015的编译</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> vs </tag>
            
            <tag> cuda </tag>
            
            <tag> gpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyinstaller with Scipy</title>
      <link href="/2019/04/02/Pyinstaller-with-Scipy/"/>
      <url>/2019/04/02/Pyinstaller-with-Scipy/</url>
      
        <content type="html"><![CDATA[<p>在将 python 工程用 pyinstaller 打包成 exe 时，由于 import 了 scipy 的一些功能，因此生成的 exe 一直报错，经过努力终于解决。</p><a id="more"></a><h1 id="问题来源"><a class="markdownIt-Anchor" href="#问题来源"></a> 问题来源</h1><p>在 MLIT 的项目中，有使用到 scipy 库中的一个函数。因此，有 <code>from scipy.spatial.distance import cdist</code> 这句，但是突然不知道哪里发生了改动 (推测是某些库的版本在安装其他库时发生了变化)，打包好的 exe 在执行上述 import 语句时总是报错。</p><h1 id="trail-and-error"><a class="markdownIt-Anchor" href="#trail-and-error"></a> Trail and Error</h1><ol><li>由于 scipy 的版本在上次发版之后发生了改变（不知为啥），现在的版本为 1.2.0. 根据 <code>lib/site-packages/</code> 的痕迹推测之前的版本为 1.0.0. 但将 scipy 重装为 1.0.0 后仍然不成功。</li><li>按步骤 1 的方式操作后，<code>scipy/spatial/_spherical_voronoi.py</code> 中的 第 18 行 <code>from . import _voronoi</code> 仍然报错，大意为 <code>cannot import name _voronoi</code>. 其中，<code>_voronoi</code> 为 <code>scipy/spatial/</code>文件夹下的一个 pyd 文件，为 <code>_voronoi.pyd</code>. 可是事实上，我在 convert 的 bat 脚本中明明有通过 <code>hidden-import</code> 将此文件导入进去，生成的文件夹中也确实存在这个文件，但是程序总是无法成功导入。</li><li>后来经过搜索与分析，在 convert 脚本中添加了一行 <code>--paths=&quot;H:\Develop\Anaconda2\setup\Lib\site-packages\scipy\extra-dll&quot;</code>，就成功了。</li></ol><h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h1><p>上述方法成功后，分析成功原因。在执行 convert 脚本时，有一系列跟 scipy 有关的 warning. 大致都是说 hidden-import 的 pyd 文件的依赖 dll 找不到，而这些 warning 在我印象中以前并未出现过。在添加了 <code>--paths=&quot;H:\Develop\Anaconda2\setup\Lib\site-packages\scipy\extra-dll</code> 这一参数后，不再有这些 warning, exe 也可以成功执行。</p><h1 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h1><p><a href="convert_server.bat">完整的 convert 脚本</a><br><a href="mlit_pkg_version_20190402.txt">python库版本</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> pyinstaller </tag>
            
            <tag> scipy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光流法</title>
      <link href="/2019/02/25/optical-flow/"/>
      <url>/2019/02/25/optical-flow/</url>
      
        <content type="html"><![CDATA[<p>对光流法进行了一个大致的了解，并了解了在高速情况下通过图像金字塔进行光流计算的方法。</p><a id="more"></a><h1 id="光流的定义"><a class="markdownIt-Anchor" href="#光流的定义"></a> 光流的定义</h1><p><strong>光流</strong> 是空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中像素在时间域上的变化以及相邻帧之间的相关性来找到上一帧跟当前帧之间存在的对应关系，从而计算出相邻帧之间物体的运动信息的一种方法。一般而言，光流是由于场景中前景目标本身的移动、相机的运动，或者两者的共同运动所产生的。</p><h1 id="光流法的原理"><a class="markdownIt-Anchor" href="#光流法的原理"></a> 光流法的原理</h1><h2 id="光流法的基本假设"><a class="markdownIt-Anchor" href="#光流法的基本假设"></a> 光流法的基本假设</h2><ol><li><font color="orange">亮度恒定不变，</font>即同一目标在不同帧间运动时，其亮度不会发生改变。这是基本光流法的假定（所有光流法变种都必须满足），用于得到光流法基本方程</li><li><font color="orange">时间连续或运动是“小运动”，</font>即时间的变化不会引起目标位置的剧烈变化，相邻帧之间位移要比较小。同样也是光流法不可或缺的假定。</li></ol><h2 id="基本约束方程"><a class="markdownIt-Anchor" href="#基本约束方程"></a> 基本约束方程</h2><p>根据光流法的基本假设，可以推导得出光流法的基本约束方程。<br>  考虑一个三维的矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>  其三个维度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 为图像的两个维度，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 为时间维度。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I(x,y,t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 时刻的图像在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 坐标上的灰度值。<br>  根据两个基本假设，可得到方程</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>I</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>d</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mi>d</mi><mi>y</mi><mo separator="true">,</mo><mi>t</mi><mo>+</mo><mi>d</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I(x,y,t) = I(x+dx, y+dy, t+dt)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></span></p><p>由于是小运动，因此可对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>d</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mi>d</mi><mi>y</mi><mo separator="true">,</mo><mi>t</mi><mo>+</mo><mi>d</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I(x+dx, y+dy, t+dt)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span> 进行泰勒展开，即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>d</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mi>d</mi><mi>y</mi><mo separator="true">,</mo><mi>t</mi><mo>+</mo><mi>d</mi><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>I</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac><mi>d</mi><mi>x</mi><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow></mfrac><mi>d</mi><mi>y</mi><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>t</mi></mrow></mfrac><mi>d</mi><mi>t</mi><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">I(x+dx, y+dy, t+dt) = I(x,y,t) + \frac{\partial I}{\partial x}dx + \frac{\partial I}{\partial y}dy + \frac{\partial I}{\partial t}dt+\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></span></p><p>结合上式，得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac><mi>d</mi><mi>x</mi><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow></mfrac><mi>d</mi><mi>y</mi><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>t</mi></mrow></mfrac><mi>d</mi><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\frac{\partial I}{\partial x}dx + \frac{\partial I}{\partial y}dy + \frac{\partial I}{\partial t}dt=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">u=\frac{dx}{dt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">v=\frac{dy}{dt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, 得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\frac{\partial I}{\partial x}\frac{dx}{dt} + \frac{\partial I}{\partial y}\frac{dy}{dt} + \frac{\partial I}{\partial t}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>x</mi></msub><mi>u</mi><mo>+</mo><msub><mi>I</mi><mi>y</mi></msub><mi>v</mi><mo>=</mo><mo>−</mo><msub><mi>I</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">I_x u+I_y v=-I_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>这就是光流的基本约束方程。</p><h2 id="lucas-kanade-光流算法"><a class="markdownIt-Anchor" href="#lucas-kanade-光流算法"></a> Lucas-Kanade 光流算法</h2><p>  由于光流的基本约束方程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>x</mi></msub><mi>u</mi><mo>+</mo><msub><mi>I</mi><mi>y</mi></msub><mi>v</mi><mo>=</mo><mo>−</mo><msub><mi>I</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">I_x u+I_y v=-I_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 只有一个约束，但是却有两个未知数，因此无法求解。为了能够求解出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>, 需要引入新的约束。<br>  Lucas-Kanade 光流算法引入了 <font color="orange"><strong>空间一致</strong></font> 假设，即所有的相邻像素有相似的行动。也即在目标像素周围 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的区域内，每个像素均拥有相同的光流矢量。以此假设解决式</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>x</mi></msub><mi>u</mi><mo>+</mo><msub><mi>I</mi><mi>y</mi></msub><mi>v</mi><mo>=</mo><mo>−</mo><msub><mi>I</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">I_x u+I_y v=-I_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>无法求解的问题。</p><p><img src="LK.png" alt="LK光流法"><br>具体推导过程，参考 <a href="https://blog.csdn.net/sgfmby1994/article/details/68489944" target="_blank" rel="noopener">总结：光流–LK光流–基于金字塔分层的LK光流–中值流</a></p><br><h1 id="基于金字塔分层的-lk-光流法"><a class="markdownIt-Anchor" href="#基于金字塔分层的-lk-光流法"></a> 基于金字塔分层的 LK 光流法</h1><p>  根据光流的基本假设 2，光流适用于 <strong>小运动</strong> 场景，即相邻帧之间运动较小。因此，光流法无法直接处理运动较大的情况。因此，在处理运动较大的情况时，需要通过图像金字塔的方式。<br>具体细节，同样参考 <a href="https://blog.csdn.net/sgfmby1994/article/details/68489944" target="_blank" rel="noopener">总结：光流–LK光流–基于金字塔分层的LK光流–中值流</a></p><br><h1 id="基于光流的运动目标检测前景检测算法"><a class="markdownIt-Anchor" href="#基于光流的运动目标检测前景检测算法"></a> 基于光流的运动目标检测（前景检测）算法</h1><p><img src="fg.png" alt="基于光流的运动目标检测（前景检测）算法流程图"><br>参考这篇文章 <a href="https://blog.csdn.net/qq_41368247/article/details/82562165" target="_blank" rel="noopener">计算机视觉–光流法(optical flow)简介</a></p><br><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><p><a href="https://blog.csdn.net/sgfmby1994/article/details/68489944" target="_blank" rel="noopener">总结：光流–LK光流–基于金字塔分层的LK光流–中值流</a><br><a href="https://blog.csdn.net/qq_41368247/article/details/82562165" target="_blank" rel="noopener">计算机视觉–光流法(optical flow)简介</a><br><a href="https://blog.csdn.net/jobbofhe/article/details/80448961" target="_blank" rel="noopener">【计算机视觉】光流法简单介绍</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> optical flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协方差及协方差矩阵</title>
      <link href="/2019/01/25/covariance-and-covariance-matrix/"/>
      <url>/2019/01/25/covariance-and-covariance-matrix/</url>
      
        <content type="html"><![CDATA[<p>本文主要关注了协方差的定义、含义，协方差矩阵的性质以及 PCA 与协方差矩阵的关系</p><a id="more"></a><p>关于协方差的定义，这篇文章解释得很好<br><a href="https://blog.csdn.net/northeastsqure/article/details/50163031" target="_blank" rel="noopener">终于明白协方差的意义了</a></p><p>关于协方差矩阵的特征值特征向量和 PCA 的关系。这篇文章解释得很好。<br><a href="https://www.cnblogs.com/dengdan890730/p/5495078.html" target="_blank" rel="noopener">PCA算法是怎么跟协方差矩阵/特征值/特征向量勾搭起来的?</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 协方差 </tag>
            
            <tag> 协方差矩阵 </tag>
            
            <tag> PCA </tag>
            
            <tag> 主成分分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos 系统下深度学习环境配置及 tensorflow 安装</title>
      <link href="/2018/12/07/linux-install-setting-process/"/>
      <url>/2018/12/07/linux-install-setting-process/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了在新安装完 Centos 系统后的 NVIDIA 显卡驱动、cuda、cudnn、以及 TensorFlow 等 python 库的安装及配置。</p><a id="more"></a><p>更改启动设置</p><blockquote><p>(1) 查看系统默认启动环境。<code>systemctl get-default</code> -&gt; <code>graphical.target</code><br>(2) 将默认启动环境设置为命令行。<code>systemctl set-default multi-user.target</code><br>(3) <code>reboot</code></p></blockquote><p>禁用系统自带的 nouveau 显卡驱动。</p><blockquote><p>(4) run the NVIDIA driver file, it will create two <code>.conf</code> file to disable the nouveau driver for you under <code>/etc/modeprobe.d</code> and <code>/usr/...</code></p></blockquote><p>重做内核镜像</p><blockquote><p>(5) <code>mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r)-nouveau.img</code>  # Backup image<br>(6) <code>dracut /boot/initramfs-$(uname -r).img $(uname -r)</code> # Create a new image<br>(7) <code>reboot</code></p></blockquote><p>安装 NVIDIA 显卡驱动</p><blockquote><p>(8) run the NVIDIA driver file again, finish the installation of NVIDIA driver.</p></blockquote><p>安装 Cuda</p><blockquote><p>(9) Install cuda 8.0, do not install the driver provided by cuda since we already installed the NVIDIA driver before.<br>(10) add <code>export PATH=/usr/local/cuda-8.0/bin:$PATH</code> and <code>export LD_LIBRARY_PATH=/usr/local/cuda-8/lib64:$LD_LIBRARY_PATH</code> to <code>~/.bashrc</code><br>(11) <code>source ~/.bashrc</code></p></blockquote><p>解压 cudnn</p><blockquote><p>(12) <code>tar zxvf cudnn.tgz</code> # extract cudnn files<br>copy extracted files to the corresponding folders under cuda installation directory</p></blockquote><p>安装 Anaconda/python</p><blockquote><p>(13) Install Ananconda. Do not add the Ananconda path to <code>/root/.bashrc</code>, add it to <code>~/.bashrc</code>.<br>(14) <code>source ~/.bashrc</code></p></blockquote><p>安装 tensorflow 或其他 python 库</p><blockquote><p>(15) <code>pip install tensorflow-gpu==1.0.0</code>. # Install GPU version tensorflow 1.0.0</p></blockquote><p>注意，安装 <code>1.0.0</code> 的 tensorflow 时，<code>numpy==1.16.2</code> 貌似会报错。因此，需要 check 一下 Anaconda 中 numpy 的版本。如果需要安装，则安装 <code>pip install numpy==1.14.2</code>。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下利用共享内存实现进程间通信</title>
      <link href="/2018/12/03/Inter-Process-Communication-by-Shared-Memory-on-Windows/"/>
      <url>/2018/12/03/Inter-Process-Communication-by-Shared-Memory-on-Windows/</url>
      
        <content type="html"><![CDATA[<p>本文主要记载了在 Windows 下如何通过调用 WinApi ，利用 <code>共享内存</code> 实现 进程间通信 (Inter Process Communication, IPC).</p><a id="more"></a><p><strong>本文主要是通过 FileMapping 的方式实现进程间通信。目前已实现进程间共享字符串以及 opencv 的 Mat 对象 （以 <code>uchar *</code> 方式）。</strong></p><br><h1 id="两个-c-进程之间的通信"><a class="markdownIt-Anchor" href="#两个-c-进程之间的通信"></a> 两个 C++ 进程之间的通信</h1><p>参考文章 <a href="https://blog.csdn.net/u012234115/article/details/82114631" target="_blank" rel="noopener">C++共享内存实现（windows和linux）</a></p><p>上面的文章只实现了字符串的进程间通信，根据实际需要，需要进程间传递图像对象，此处使用 opencv 的 <code>Mat</code> 对象来表示。由于 <code>Mat</code> 对象有一个 <code>uchar* data</code> 属性，指向 Mat 的实际数据。因此，这里通过传输 <code>uchar* data</code> 到共享内存，并在 Reader 中重建 <code>Mat</code> 对象 (C++)。<br>参考文章 <a href="https://www.cnblogs.com/Lalafengchui/p/4223584.html" target="_blank" rel="noopener">Windows进程间通信–共享内存映射文件（FileMapping）</a>.</p><p><strong>注意:</strong> 这里在传递时需要将图像的 长、宽、高 等参数一并传递，这样在 Reader 中可以根据读到的尺寸进行恢复。因为在 Reader 端一开始得到的是共享内存的首地址。C++ 中用三个 <code>int</code> 类型来表示 <code>width</code>, <code>height</code>, <code>channel</code>。这三个 <code>int</code> 是写到表示数据的 <code>uchar *</code> 的最前面的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code snippet in img_reader.cpp</span></span><br><span class="line"><span class="keyword">int</span> width, height;</span><br><span class="line">uchar* tmp = (uchar*) <span class="built_in">malloc</span>(buffer_size);</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, &amp;width, <span class="keyword">sizeof</span>(width)) <span class="comment">// 将 width 首地址开始的 4 个 byte 内容拷贝到 tmp 所指向的地址。</span></span><br><span class="line">tmp += <span class="keyword">sizeof</span>(width); <span class="comment">// tmp 向后移动 sizeof(width) 个 uchar 的长度。</span></span><br><span class="line"><span class="built_in">memcpy</span>(tmp, &amp;height, <span class="keyword">sizeof</span>(height))</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(height)</span><br></pre></td></tr></table></figure><br><h1 id="c-和-python-进程之间的通信"><a class="markdownIt-Anchor" href="#c-和-python-进程之间的通信"></a> C++ 和 python 进程之间的通信</h1><p><em>C++ 作 Writer， python 作 Reader</em><br>参考文章：<a href="https://mail.python.org/pipermail/python-list/2005-March/302108.html" target="_blank" rel="noopener">Shared Memory Example (Python, ctypes, VC++)</a>。<br>python 中 使用 <code>ctypes</code> 来调用 <code>win32 api</code>，方法与 C++ Reader 中的类似。区别在于获取共享内存的首地址后，python 中可以通过 slicing 的方式获取不同地址的值。最后得到 width, height, channel 以及数据，将数据转换成 ndarray 即可使用 opencv 显示。</p><br><h1 id="filemapping-原理"><a class="markdownIt-Anchor" href="#filemapping-原理"></a> FileMapping 原理</h1><p>这里使用了 FileMapping 的方式进行 IPC。<br>Writer 使用的 API 有</p><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createfilea" target="_blank" rel="noopener">CreateFile</a><br><a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-createfilemappinga" target="_blank" rel="noopener">CreateFileMapping</a><br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366761%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">MapViewOfFile</a><br><code>MapViewOfFile</code> 最后返回的是共享内存的指针。通过将数据 <code>memcpy</code> 到这里实现共享。</p></blockquote><p>Reader 使用的 API 有</p><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-openfilemappinga" target="_blank" rel="noopener">OpenFileMapping</a><br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366761%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">MapViewOfFile</a><br><code>MapViewOfFile</code> 最后返回的是共享内存的指针。可通过从这里读数据重建图像。</p></blockquote><p>关于以上提及 API 的详细解释：</p><blockquote><p><a href="https://blog.csdn.net/bxsec/article/details/76566011" target="_blank" rel="noopener">Windows核心编程-CreateFile详解</a></p></blockquote><br><h1 id="file-mapping-代码"><a class="markdownIt-Anchor" href="#file-mapping-代码"></a> File Mapping 代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// img_writer.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\core\core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\highgui\highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct MyData</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//int width;</span></span><br><span class="line"><span class="comment">//int height;</span></span><br><span class="line"><span class="comment">//int channel;</span></span><br><span class="line"><span class="comment">//MyData(int _width, int _height, int _channel) : width(_width), height(_height), channel(_channel)</span></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeMemory</span><span class="params">(<span class="keyword">char</span>* imgDir)</span> </span>&#123;</span><br><span class="line"><span class="comment">// define shared data</span></span><br><span class="line"><span class="keyword">char</span> *shared_file_name = <span class="string">"file_name_sean"</span>;</span><br><span class="line"><span class="keyword">char</span> * shared_object_name = <span class="string">"Local\\object_name_sean"</span>;</span><br><span class="line"></span><br><span class="line">Mat img = imread(imgDir, IMREAD_COLOR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> width = img.cols;</span><br><span class="line"><span class="keyword">int</span> height = img.rows;</span><br><span class="line"><span class="keyword">int</span> channel = img.channels();</span><br><span class="line">uchar* img_data = img.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> data_size = <span class="keyword">sizeof</span>(uchar) * width * height * channel;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> buffer_size = data_size + <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"share buffer "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create shared memory file</span></span><br><span class="line">HANDLE hFile = CreateFile(shared_file_name,</span><br><span class="line">GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_ALWAYS, <span class="comment">// open exist or create new, overwrite file</span></span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"create file error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">HANDLE shared_file_handler = CreateFileMapping(</span><br><span class="line">hFile, <span class="comment">// Use paging file - shared memory</span></span><br><span class="line"><span class="literal">NULL</span>,                 <span class="comment">// Default security attributes</span></span><br><span class="line">PAGE_READWRITE,       <span class="comment">// Allow read and write access</span></span><br><span class="line"><span class="number">0</span>,                    <span class="comment">// High-order DWORD of file mapping max size</span></span><br><span class="line">buffer_size,            <span class="comment">// Low-order DWORD of file mapping max size</span></span><br><span class="line">shared_object_name);    <span class="comment">// Name of the file mapping object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shared_file_handler) &#123;</span><br><span class="line"><span class="comment">// map memory file view, get pointer to the shared memory</span></span><br><span class="line">LPVOID lp_base = MapViewOfFile(</span><br><span class="line">shared_file_handler,  <span class="comment">// Handle of the map object</span></span><br><span class="line">FILE_MAP_ALL_ACCESS,  <span class="comment">// Read and write access</span></span><br><span class="line"><span class="number">0</span>,                    <span class="comment">// High-order DWORD of the file offset</span></span><br><span class="line"><span class="number">0</span>,                    <span class="comment">// Low-order DWORD of the file offset</span></span><br><span class="line">buffer_size);           <span class="comment">// The number of bytes to map to view</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// write width, height, channel to a memory</span></span><br><span class="line">uchar* tmp = (uchar*) <span class="built_in">malloc</span>(buffer_size);</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, &amp;width, <span class="keyword">sizeof</span>(width));</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(width);</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, &amp;height, <span class="keyword">sizeof</span>(height));</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(height);</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, &amp;channel, <span class="keyword">sizeof</span>(channel));</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(channel);</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, img.data, data_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">uchar val = tmp[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy data to shared memory</span></span><br><span class="line">tmp -= <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">3</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(lp_base, tmp, buffer_size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line"></span><br><span class="line">FlushViewOfFile(lp_base, buffer_size); <span class="comment">// can choose save to file or not</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// process wait here for other task to read data</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"already write to shared memory, wait ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">this_thread::sleep_for(chrono::seconds(<span class="number">6000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// close shared memory file</span></span><br><span class="line">UnmapViewOfFile(lp_base);</span><br><span class="line">CloseHandle(shared_file_handler);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"shared memory closed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"create mapping file error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* imgDir = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/cnpy-solution/cv/vehicle.jpeg"</span>;</span><br><span class="line">writeMemory(imgDir);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// img_reader.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\core\core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\highgui\highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *shared_object_name = <span class="string">"Local\\object_name_sean"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// open shared memory file</span></span><br><span class="line">HANDLE shared_file_handler = OpenFileMapping(</span><br><span class="line">FILE_MAP_ALL_ACCESS,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">shared_object_name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shared_file_handler) &#123;</span><br><span class="line"></span><br><span class="line">LPVOID lp_base = MapViewOfFile(</span><br><span class="line">shared_file_handler,</span><br><span class="line">FILE_MAP_ALL_ACCESS,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy shared data from memory</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"read shared data: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">uchar* tmp = (uchar*)lp_base;</span><br><span class="line"><span class="keyword">int</span> width;</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">int</span> channel;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;width, tmp, <span class="keyword">sizeof</span>(width));</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;height, tmp, <span class="keyword">sizeof</span>(height));</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;channel, tmp, <span class="keyword">sizeof</span>(channel));</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">Mat img = Mat(height, width, CV_8UC3);</span><br><span class="line"><span class="built_in">memcpy</span>(img.data, tmp, height * width * channel);</span><br><span class="line"></span><br><span class="line">namedWindow(<span class="string">"test"</span>);</span><br><span class="line">imshow(<span class="string">"test"</span>, img);</span><br><span class="line">waitKey(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// close share memory file</span></span><br><span class="line">UnmapViewOfFile(lp_base);</span><br><span class="line">CloseHandle(shared_file_handler);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"open mapping file error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">readMemory();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># img_reader.py</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FILE_MAP_ALL_ACCESS = <span class="number">0xF001F</span></span><br><span class="line">szName = c_char_p(<span class="string">'Local\object_name_sean'</span>)</span><br><span class="line"></span><br><span class="line">hMapObject = windll.kernel32.OpenFileMappingA(FILE_MAP_ALL_ACCESS, <span class="keyword">False</span>, szName)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Error after OpenFileMappingA -&gt;"</span>, GetLastError()  <span class="comment"># If everything runs smoothly, GetLastError should return 0</span></span><br><span class="line"><span class="keyword">if</span> hMapObject == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Could not open file mapping object'</span></span><br><span class="line">    <span class="keyword">raise</span> windll.WindowsError()</span><br><span class="line"></span><br><span class="line">pBuf = windll.kernel32.MapViewOfFile(hMapObject, FILE_MAP_ALL_ACCESS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Error after MapViewOfFile -&gt;"</span>, GetLastError()  <span class="comment"># If everything runs smoothly, GetLastError should return 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pBuf == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Could not map view of file'</span></span><br><span class="line">    windll.kernel32.GetLastError()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    pBuf_int = cast(pBuf, POINTER(c_int))</span><br><span class="line">    width, height, channel = pBuf_int[:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    data_len = width * height * channel</span><br><span class="line">    pBuf_ubyte = cast(pBuf, POINTER(c_ubyte))</span><br><span class="line">    data_ubyte = pBuf_ubyte[: data_len]  <span class="comment"># The pointer is already incremented by 12 bytes, not sure why.</span></span><br><span class="line"></span><br><span class="line">    image = np.asarray(data_ubyte, dtype=np.uint8)</span><br><span class="line">    image = image.reshape((height, width, channel))</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'python image'</span>, image)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line"></span><br><span class="line">windll.kernel32.UnmapViewOfFile(pBuf)</span><br><span class="line">windll.kernel32.CloseHandle(hMapObject)</span><br></pre></td></tr></table></figure><p><a href="img_writer.cpp">img_writer in C++</a> <a href="img_reader.cpp">img_reader in C++</a> <a href="img_reader.py">img_reader in python</a></p><p><em><font color="orange">不知为什么，python 版的 reader 用脚本执行正常，但是用 pyinstaller 打包成 exe 后就无法获取共享内存的指针，<code>MapViewOfFile</code> 始终返回 0，正在解决这个问题。</font></em></p><p><em><font color="green">除此之外，发现 python 版中在执行完 <code>OpenFileMappingA</code> 和 <code>MapViewOfFile</code> 后，分别调用 <code>GetLastError</code> 都应该返回 0 (0 表示没有错误)。C++ 版本的 reader 就是如此。但是 <code>img_reader.py</code> 用脚本方式执行却都返回 2，按理说返回 2 了就表示有错，应该无法正确读取共享内存数据，但是用脚本方式执行却可以读取图像数据。这一点很奇怪。而将 <code>img_reader.py</code> 转换成 exe 后，在 <code>OpenFileMappingA</code> 后调用 <code>GetLastError</code> 返回 2，<code>MapViewOfFile</code> 后返回 6，也无法正确读取图像数据。</font></em></p><p>由于现有的方法无法在转成 exe 后成功运行，考虑使用新的方法来读取共享内存。这里使用了 <code>mmap</code> 库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shm = mmap.mmap(<span class="number">0</span>, <span class="number">720</span>*<span class="number">480</span>*<span class="number">3</span>+<span class="number">12</span>, <span class="string">"object_name_sean"</span>, mmap.ACCESS_READ)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> shm</span><br><span class="line"><span class="keyword">if</span> shm:</span><br><span class="line">    header = shm.read(<span class="number">12</span>)</span><br><span class="line">    width_str = header[:<span class="number">4</span>]</span><br><span class="line">    height_str = header[<span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line">    channel_str = header[<span class="number">8</span>:<span class="number">12</span>]</span><br><span class="line"></span><br><span class="line">    width = struct.unpack(<span class="string">'&lt;i'</span>, width_str)[<span class="number">0</span>]</span><br><span class="line">    height = struct.unpack(<span class="string">'&lt;i'</span>, height_str)[<span class="number">0</span>]</span><br><span class="line">    channel = struct.unpack(<span class="string">'&lt;i'</span>, channel_str)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> width, height, channel</span><br><span class="line"></span><br><span class="line">    data = shm.read(width * height * channel)</span><br><span class="line"></span><br><span class="line">    img_data = [ord(x) <span class="keyword">for</span> x <span class="keyword">in</span> data]</span><br><span class="line">    <span class="keyword">print</span> img_data[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">    image = np.asarray(img_data, dtype=np.uint8)</span><br><span class="line">    image = image.reshape((height, width, channel))</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'python image'</span>, image)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line"></span><br><span class="line">shm.close()</span><br></pre></td></tr></table></figure><p><a href="reader_mmap.py">img reader in python mmap</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Windows </tag>
            
            <tag> IPC </tag>
            
            <tag> Python </tag>
            
            <tag> WinAPI </tag>
            
            <tag> file mapping </tag>
            
            <tag> 进程通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio 环境变量配置</title>
      <link href="/2018/11/26/Visual-Studio-Configuration/"/>
      <url>/2018/11/26/Visual-Studio-Configuration/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了一些关于 Visual Studio 的环境变量的配置，本文使用的版本是 VS 2015.</p><a id="more"></a><h1 id="vs-的项目结构"><a class="markdownIt-Anchor" href="#vs-的项目结构"></a> VS 的项目结构</h1><p>  Visual Studio 主要由两层结构，最大的一层是 <code>解决方案 (Solution)</code>，一个 <code>解决方案</code> 可以包含多个 <code>项目 (Project)</code>。可以在一个已有的 <code>Solution</code> 里添加 <code>Project</code>.</p><br><h1 id="vs-平台选项"><a class="markdownIt-Anchor" href="#vs-平台选项"></a> VS 平台选项</h1><p>  VS 由 <code>Debug</code> 和 <code>Release</code> 两种模式，一般在开发阶段都使用 Debug，而在最后的发布阶段使用 Release。在目标平台选项主要有 <code>x64</code> 和 <code>x86</code> 两种。模式和平台相互组合就会产生 4 种方式。可根据需要进行环境变量的配置。</p><br><h1 id="项目属性配置"><a class="markdownIt-Anchor" href="#项目属性配置"></a> 项目属性配置</h1><p>  在某个项目上(是项目，非解决方案)<code>右键</code>，<code>属性</code>，选中左侧 <code>VC++目录</code>，右侧会出现一些路径的配置。主要有 <code>可执行文件目录</code>，<code>包含目录</code>，<code>引用目录</code>，<code>库目录</code>等等。在安装 VS 的时候，VS 已经将一些依赖的目录命名到一些宏了（就是类似于系统的环境变量之类的变量，与 C++ 的宏不一样），因此上面这些 <code>可执行文件目录</code> 等都包含了一些宏，作为默认的查找路径，如果自己的项目需要额外引入其他的依赖，则需要在对应的目录里添加自己的路径。比如，C++ 中调用 Python 的项目需要 <code>Python.h</code> 和 <code>python27.lib</code>，因此就将这两个文件所在的路径分别添加进 <code>包含目录</code> 和 <code>库目录</code>。上面的每一个目录都是和环境变量的某个变量对应的。比如，<code>包含目录</code> 与 环境变量 <code>INCLUDE</code> 对应，<code>库目录</code> 与 环境变量 <code>LIB</code> 对应。<br><strong>Note:</strong> 当选用 <code>Debug</code> 模式时，编译的时候会报找不到 <code>python27_d.lib</code> 的错，这是因为我们下载的 python 都是 Release 版本的。因此只有 <code>python27.lib</code> 没有 <code>python27_d.lib</code>。<a href="https://blog.csdn.net/Chris_zhangrx/article/details/78947526" target="_blank" rel="noopener">解决方法</a></p><br><h1 id="包含目录-附加包含目录以及库目录和附加库目录的区别"><a class="markdownIt-Anchor" href="#包含目录-附加包含目录以及库目录和附加库目录的区别"></a> 包含目录、附加包含目录以及库目录和附加库目录的区别</h1><p>在 VS 中，右键一个 Project，可以发现有两个地方设置 <code>Include</code> 的相关目录：</p><blockquote><p>VC++ Directories -&gt; Include Directories<br>C/C++ -&gt; General -&gt; Additional Include Directories</p></blockquote><p>同理，设置 Lib 也有两个地方</p><blockquote><p>VC++ Directories -&gt; LibraryDirectories<br>Linker -&gt; General -&gt; Additional Library Directories</p></blockquote><p>应该如何设置呢？<br>MSDN 对这两个条目的解释如下</p><blockquote><p>“VC++ Directories -&gt; Include Directories” : Directory settings displayed in the window are the directories that Visual Studio will search for include files referred to in your source code files. Corresponds to environment variable INCLUDE.<br>“C/C+±&gt; General -&gt; Additional Include Directories”: The directory to be added to the list of directories searched for include files.</p></blockquote><p>编译器在编译过程中查找包含目录（<strong>Include</strong> 文件）的顺序：</p><blockquote><p>The compiler searches for directories in the following order:<br>1. Directories containing the source file.<br>2. Directories specified with the <strong>/I</strong> option, in the order that CL encounters them.<br>3. Directories specified in the <strong>INCLUDE</strong> environment variable.</p></blockquote><p>其中 step2 中的 <code>/I</code> 是由 <code>C/C++ -&gt; General -&gt; Additional Include Directories</code> 设置的。<br>而 step3 中的 <code>INCLUDE</code> 是由 <code>VC++ Directories -&gt; Include Directories</code> 设置的。<br>所以从这里看出，不同的设置有不同的编译链接顺序。</p><p>因此，总结出两种设置方法：</p><blockquote><p>VC++ Directories -&gt; Include Directories 配合 VC++ Directories -&gt; LibraryDirectories<br>C/C++ -&gt; General -&gt; Additional Include Directories 配合 Linker -&gt; General -&gt; Additional Library Directories</p></blockquote><p>但是要注意，由于编译顺序，这种用法情况下需要确保在 <code>VC++ Directories -&gt; Include Directories</code> 中填入 <code>$(IncludePath)</code> (继承其他 Include 路径).</p><p>Lib 的设置与 Include 同理。</p><br><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://blog.csdn.net/u012234115/article/details/54233095" target="_blank" rel="noopener">visual studio配置中包含目录和附加包含目录的区别以及auto-linking</a><br><a href="https://blog.csdn.net/zcedar/article/details/51444343" target="_blank" rel="noopener">VS属性配置和auto-linking</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> visual studio </tag>
            
            <tag> 环境变量 </tag>
            
            <tag> Debug </tag>
            
            <tag> Release </tag>
            
            <tag> 调试 </tag>
            
            <tag> 发行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机成像原理和参数标定</title>
      <link href="/2018/11/15/camera-calibration/"/>
      <url>/2018/11/15/camera-calibration/</url>
      
        <content type="html"><![CDATA[<p>最近学习了相机的成像原理和参数标定，将参考文献记录如下。</p><a id="more"></a><h1 id="成像原理"><a class="markdownIt-Anchor" href="#成像原理"></a> 成像原理</h1><p>简化后的相机模型和针孔相机的成像原理很相似，因此我们把简化后的相机模型称为针孔相机模型。<br>具体内容参考<a href="https://zhuanlan.zhihu.com/p/30813733" target="_blank" rel="noopener">相机成像过程的简化与建模</a><br><br></p><h1 id="世界坐标到相机坐标变换"><a class="markdownIt-Anchor" href="#世界坐标到相机坐标变换"></a> 世界坐标到相机坐标变换</h1><p><a href="https://zhuanlan.zhihu.com/p/23090593" target="_blank" rel="noopener">刚体变换</a><br><a href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula" target="_blank" rel="noopener">罗德里格斯旋转公式</a><br><a href="https://www.matongxue.com/madocs/244.html" target="_blank" rel="noopener">仿射变换</a></p><h1 id="相机坐标到数字图像坐标畸变矫正"><a class="markdownIt-Anchor" href="#相机坐标到数字图像坐标畸变矫正"></a> 相机坐标到数字图像坐标，畸变矫正</h1><p><a href="https://zhuanlan.zhihu.com/p/30813733" target="_blank" rel="noopener">相机标定究竟在标定什么？</a></p><h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1><ol><li>由于针孔相机模型的特性（射线），CCD 上的某个点可能对应了一个射线上的所有点，因此无法只通过相机内参将像素坐标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 映射为相机坐标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>c</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>c</mi></msub><mo separator="true">,</mo><msub><mi>z</mi><mi>c</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_c, y_c, z_c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。因而无法计算出两个像素点之间的实际物理距离。（远处的大物体移动大距离和近处的小物体移动小距离可能成像结果完全一样）</li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> camera </tag>
            
            <tag> calibration </tag>
            
            <tag> imaging </tag>
            
            <tag> 相机 </tag>
            
            <tag> 成像原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow-1.x-cookbook 读书笔记</title>
      <link href="/2018/11/14/tensorflow-1-x-cookbook/"/>
      <url>/2018/11/14/tensorflow-1-x-cookbook/</url>
      
        <content type="html"><![CDATA[<p>本文是关于 《TensorFlow 1.x Deep Learning Cookbook》 的读书笔记。</p><a id="more"></a><br><h1 id="hello-world-in-tensorflow"><a class="markdownIt-Anchor" href="#hello-world-in-tensorflow"></a> Hello world in TensorFlow</h1><h2 id="1-设置-tensorflow-输出日志等级"><a class="markdownIt-Anchor" href="#1-设置-tensorflow-输出日志等级"></a> 1. 设置 tensorflow 输出日志等级</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>]=<span class="string">'2'</span></span><br></pre></td></tr></table></figure><h2 id="2-tensorflow-与设备"><a class="markdownIt-Anchor" href="#2-tensorflow-与设备"></a> 2. TensorFlow 与设备</h2><blockquote><p>TensorFlow allows you to use specific devices (CPU/GPU) with different objects of the computation graph using with <code>tf.device()</code>.</p></blockquote><br><h1 id="working-with-constants-variables-and-placeholders"><a class="markdownIt-Anchor" href="#working-with-constants-variables-and-placeholders"></a> Working with constants, variables, and placeholders</h1><h2 id="3-constants-和-variables-的存储方式"><a class="markdownIt-Anchor" href="#3-constants-和-variables-的存储方式"></a> 3. Constants 和 Variables 的存储方式</h2><blockquote><p>Constants are stored in the computation graph definition; they are loaded every time the graph is loaded. In other words, they are memory expensive. Variables, on the other hand, are stored separately; they can exist on the parameter server.</p></blockquote><h2 id="4-设置全局-seed"><a class="markdownIt-Anchor" href="#4-设置全局-seed"></a> 4. 设置全局 seed</h2><blockquote><p>When there are large numbers of random tensors in use, we can set the seed for all randomly generated tensors using tf.set_random_seed(); the following command sets the seed for random tensors for all sessions as 54: <code>tf.set_random_seed(54)</code></p></blockquote><h2 id="5-以某种分布初始化-variable"><a class="markdownIt-Anchor" href="#5-以某种分布初始化-variable"></a> 5. 以某种分布初始化 Variable</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rand_t = tf.random_uniform([<span class="number">50</span>,<span class="number">50</span>], <span class="number">0</span>, <span class="number">10</span>, seed=<span class="number">0</span>)</span><br><span class="line">t_a = tf.Variable(rand_t)</span><br><span class="line">t_b = tf.Variable(rand_t)</span><br></pre></td></tr></table></figure><h2 id="6-将-variable-作常量使用以优化内存-constant-存储在-graph-中variable-不是"><a class="markdownIt-Anchor" href="#6-将-variable-作常量使用以优化内存-constant-存储在-graph-中variable-不是"></a> 6. 将 Variable 作常量使用以优化内存 (Constant 存储在 graph 中，Variable 不是)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_large = tf.Variable(large_array, trainable = <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><br><h1 id="performing-matrix-manipulations-using-tensorflow"><a class="markdownIt-Anchor" href="#performing-matrix-manipulations-using-tensorflow"></a> Performing matrix manipulations using TensorFlow</h1><h2 id="7-elementwise-operations"><a class="markdownIt-Anchor" href="#7-elementwise-operations"></a> 7. elementwise operations</h2><blockquote><p>All arithmetic operations of matrices like add, sub, div, multiply (elementwise multiplication), mod, and cross require that the two tensor matrices should be of the same data type.<br><br></p></blockquote><h1 id="invoking-cpugpu-devices"><a class="markdownIt-Anchor" href="#invoking-cpugpu-devices"></a> Invoking CPU/GPU devices</h1><h2 id="8-tensorflow-naming-cpu-and-gpu-devices"><a class="markdownIt-Anchor" href="#8-tensorflow-naming-cpu-and-gpu-devices"></a> 8. TensorFlow naming CPU and GPU devices</h2><blockquote><p>TensorFlow names the supported devices as “<code>/device:CPU:0</code>” (or “<code>/cpu:0</code>”) for the CPU devices and “<code>/device:GPU:I</code>” (or “<code>/gpu:I</code>”) for the ith GPU device.</p></blockquote><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ORB 特征提取</title>
      <link href="/2018/11/13/ORB-Feature/"/>
      <url>/2018/11/13/ORB-Feature/</url>
      
        <content type="html"><![CDATA[<p>ORB 特征的提取过程</p><a id="more"></a><p>以下两篇博客讲解得不错，结合起来看更易理解。<br><a href="https://blog.csdn.net/zouzoupaopao229/article/details/52625678" target="_blank" rel="noopener">ORB特征提取详解</a><br><a href="https://blog.csdn.net/yang843061497/article/details/38553765" target="_blank" rel="noopener">见过的介绍ORB最清楚的博文</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 特征提取 </tag>
            
            <tag> 图像检索 </tag>
            
            <tag> 图像匹配 </tag>
            
            <tag> feature extraction </tag>
            
            <tag> ORB </tag>
            
            <tag> keypoint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Faster RCNN 中自定义 Python 层的作用理解</title>
      <link href="/2018/11/06/Faster-RCNN-Python-layer/"/>
      <url>/2018/11/06/Faster-RCNN-Python-layer/</url>
      
        <content type="html"><![CDATA[<p>本文主要分析了 Faster RCNN 中 <code>anchor_target_layer.py</code>, <code>proposal_target_layer.py</code> 和 <code>proposal_layer.py</code> 三个自定义 python 层的代码。</p><a id="more"></a><h1 id="训练阶段的主要网络结构"><a class="markdownIt-Anchor" href="#训练阶段的主要网络结构"></a> 训练阶段的主要网络结构</h1><p><img src="structure.PNG" alt="训练阶段的主要网络结构"></p><h1 id="测试阶段的主要网络结构"><a class="markdownIt-Anchor" href="#测试阶段的主要网络结构"></a> 测试阶段的主要网络结构</h1><p><img src="structure_test.PNG" alt="测试阶段的主要网络结构"></p><br><h1 id="proposal_layerpy-训练测试阶段都有"><a class="markdownIt-Anchor" href="#proposal_layerpy-训练测试阶段都有"></a> proposal_layer.py （训练，测试阶段都有）</h1><p><a href="https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/rpn/proposal_layer.py" target="_blank" rel="noopener">source</a><br>输入： score, bbox_deltas, im_info</p><ol><li>生成 anchors, 利用预测得到的 bbox_deltas 作为输入，对所有的 anchors 作回归，得到 proposals. (注意，这里生成 anchors 的方式与训练时 anchor_target_layer.py 里一致)</li><li>对超出原图的 proposals 进行 clip, 筛除尺寸过小的 proposals.</li><li>根据输入的 scores 进行排序，选取前 N 个保留。（eg. 6000）</li><li>对剩下的 proposals 进行 nms，筛除一部分 proposals.</li><li>再根据 scores 排序，选取前一部分 proposals. (eg. 300)</li><li>输出 proposals</li></ol><br><h1 id="anchor_target_layerpy-仅在训练阶段"><a class="markdownIt-Anchor" href="#anchor_target_layerpy-仅在训练阶段"></a> anchor_target_layer.py (仅在训练阶段)</h1><p><a href="https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/rpn/anchor_target_layer.py" target="_blank" rel="noopener">source</a><br>输入: ‘rpn_cls_score’,‘gt_boxes’,‘im_info’, ‘data’<br>(1) 生成 所有的 anchors，记为 <code>all_anchors</code>，选出在图像内部的 anchor，记为 <code>anchors</code>.<br>(2) 生成与 1 步中 <code>anchors</code> 同尺寸的 <code>labels</code>，初始化为 <code>-1</code>.<br>(3) 计算 <code>anchors</code> 与 <code>gt_boxes</code> 的 IoU，得到 <code>overlaps</code>，得到每个 anchor 对应的 gt_box (IoU 最大).<br>(4) 根据 RPN 正负样本选取规则 1，将每个 gt_box 的 IoU 最大 anchor 的 label 置为 <code>1</code>.<br>(5) 根据 RPN 正负样本选取规则 2，将与任意 gt_box 的 IoU 大于某阈值的 anchor 的 label 置为 <code>1</code>. 将与所有 gt_box 的 IoU 小于某阈值的 achor 的 label 置为 <code>0</code>. 剩下的保留为 <code>-1</code>. 这样，就为每个 anchor 分配了标签。<br>(6) 根据正负样本的数量限制，将一部分正样本（label 为 1）置为 <code>-1</code>. 负样本同样。<br>(7) 计算 <code>anchors</code> 中每个 anchor 和 其对应的 gt_box 之间的 delta 作为 <code>bbox_targets</code>.<br>这样，上面计算得到的 <code>labels</code> 和 <code>bbox_targets</code> 其实就是 RPN 网络的 loss 的真值。<br>(8) 将得到的 <code>anchors</code> 和 <code>bbox_targets</code> unmap 回原来的 <code>all_anchors</code> 中。这样，所有生成的 anchors 都有一个类别标记（-1，0，1）和 bbox_targets. (在 <code>all_anchors</code> 不在 <code>anchors</code> 中的 anchor 的 bbox_target 用 0 填充。label 用 -1 填充。这样在计算 RPN loss 时不会计算此 anchor 的 loss.(-1 被忽略))。<br>(9) 将 <code>all_anchors</code> 的 <code>labels</code> 和 <code>bbox_targets</code> 输出，与预测的结果计算 rpn_loss.</p><br><h1 id="proposal_target_layerpy-仅在训练阶段"><a class="markdownIt-Anchor" href="#proposal_target_layerpy-仅在训练阶段"></a> proposal_target_layer.py (仅在训练阶段)</h1><p><a href="https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/rpn/proposal_target_layer.py" target="_blank" rel="noopener">source</a><br>接受 proposal_layer.py 的输出(0, x1, y1, x2, y2) 和 gt_boxes (每个 GT box 的坐标和类别) (x1, y1, x2, y2, label)作为输入。</p><ol><li>将输入的 rois 和 gt_boxes 合并 (vstack)，形成总的 rois，记为 <code>all_rois</code>, 格式为(0, x1, y1, x2, y2), 共 M 个。</li><li>计算每个 roi 和每个 gt_box 的 IoU，形成一个 matrix，设 gt_boxes 共有 N 个，则尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M\times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>.</li><li>找到每个 roi 对应的 IoU 最大的 gt_box 的索引，并将此 gt_box 的类别赋给此 roi. 这样每个 roi 都有一个物体类别。</li><li>选择一些最大 IoU (最大 IoU 指 roi 与所有 gt_box 的 IoU 的最大值) 大于某阈值的 roi 作为 foreground，选择一些最大 IoU 在某区间内的 roi 作为 background。将作为 background 的 roi 的类别改为 0，用作最后 loss_cls 的计算。将 fg rois 和 bg rois 合并(vstack)，作为一个输出。记为 rois，用作 ROI Pooling.</li><li>计算这些 rois (第4步获得)与其对应的 gt_boxes 之间的 delta 作为位置预测的目标，用来计算 loss_bbox. <a href="https://github.com/rbgirshick/py-faster-rcnn/blob/781a917b378dbfdedb45b6a56189a31982da1b43/lib/fast_rcnn/bbox_transform.py#L10" target="_blank" rel="noopener">delta计算方法</a></li></ol><p><strong>2021/03/16:</strong></p><ol><li>这里，第一步将 gt_boxes 与 proposal_layer.py 输入的 rois 合并(vstack)是为了将 gt_boxes 作为 fg rois 参与后面的 loss 计算，因为每一个 gt_box 肯定会和自己本身的 IoU 为1，这样，就会被选作 fg roi, 进行后面的 loss 计算。</li><li>感觉这一步生成的 rois 作用类似于 RPN 中的 anchor。都要计算与其对应的 gt_box 之间的 delta 作为回归的真值。其类别也是由其对应的 gt_box 赋予的。</li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> Faster R-CNN </tag>
            
            <tag> RPN </tag>
            
            <tag> anchor </tag>
            
            <tag> Python layer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 中关于字符的编码方式</title>
      <link href="/2018/07/24/encoding-problem/"/>
      <url>/2018/07/24/encoding-problem/</url>
      
        <content type="html"><![CDATA[<p>在工作中遇到了有关字符编码的一个问题，在解决之后记录一下。</p><a id="more"></a><p>在一个深度学习的目标检测任务中，需要将检测出的结果输出到一个 xml 文件中，或者以 xml 的形式打印到控制台上。当向 xml 文件中传递的字符都是英文和数字时，不会有问题。但是当 xml 文件中出现中文或日文字符时，会出现一系列的编码问题。</p><h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><p>  当设置 xml 某个元素的值时，若传递进去的为中文或日文，就会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: All strings must be XML compatible: Unicode <span class="keyword">or</span> ASCII, no NULL bytes <span class="keyword">or</span> control characters [<span class="number">8444</span>] Failed to execute script runcaffe_fpn</span><br></pre></td></tr></table></figure><p>这个错是由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resource.text = image_name</span><br></pre></td></tr></table></figure><p>这句话引发的，其中 image_name 是用 glob 函数从 Windows 系统中的某个路径下读进来的文件名。</p><br><h1 id="分析和解决"><a class="markdownIt-Anchor" href="#分析和解决"></a> 分析和解决</h1><p>经过搜索发现，lxml 模块中，当对一个树的某个节点进行赋值时，其传入值必须是 Unicode 或 ASCII 码，而使用 glob 函数读进来的文件名并不是，因而造成了错误。</p><p>经过研究发现，简体中文版的 Windows 系统使用 GBK 字符集，而不是 Unicode 字符集，因而传入的文件名不能直接赋值给 lxml 的节点对象。因此，需要对其进行转换，转换成 Unicode 码，再赋值给节点对象，也就是 <code>name = image_name.decode('gbk')</code> 或 <code>name = image_name.decode('Shift-JIS')</code>。</p><p>这样之后不会报错了，但是在生成的 xml 文件中，中日字符都是以 unicode 码显示的，此时，只要将 <code>etree.tostring()</code> 函数的 <code>encoding=</code> 参数设置为 utf-8 即可。</p><p>传入的文件名除了不能直接赋给 lmxl 的节点对象，直接进行 print 也是会乱码的（当 cmd 的 code page 与此字符串编码不一致时）。这是因为，传入的文件名的编码方式是由其代表文件所在的系统决定的，简体中文版 Windows 是 GBK，日文版是 Shift-JIS。当传入的字符串为 Shift-JIS 编码，但是尝试在 GBK 的 cmd 上打印出来时，就会报错。如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\sean\Pictures\01.嶥杫巗彫栰杫.png</span><br><span class="line">C:\Users\sean\Pictures\fc_barcelona___wallpaper_by_ccrt.png</span><br><span class="line">C:\Users\sean\Pictures\vs添加lib文件.PNG</span><br><span class="line">C:\Users\sean\Pictures\户口簿首页.png</span><br><span class="line">C:\Users\sean\Pictures\捕获.PNG</span><br></pre></td></tr></table></figure><p>可以看出，第一个文件的文件名是乱码，这是因为它是 Shift-JIS 编码的，但是却尝试在 GBK 的 cmd 上打印出来，因此会报错。</p><p>总结: python2 中，如果在文件开头声明了某种文件编码格式，那么此文件中<font color="orange"><strong>定义</strong></font>的字符串就是跟文件同样的编码格式。如果想要将此字符串打印到控制台上，则其编码必须跟控制台的编码一致。否则就需要手动进行 decode 成 unicode 进行打印。对于从系统中读进来的文件名，其编码格式是根据所在系统的编码格式决定的，与源码文件头部声明的编码格式无关。例如，以下代码中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"></span><br><span class="line">names = glob.glob(osp.join(<span class="string">'C:\Users\sean\Pictures'</span>, <span class="string">'*.png'</span>))</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    <span class="keyword">print</span> name</span><br><span class="line"></span><br><span class="line">s = <span class="string">'路飞学院'</span></span><br><span class="line"><span class="keyword">print</span> s</span><br></pre></td></tr></table></figure><p><code>s</code> 变量的编码就是头部声明的 utf-8，而 <code>names</code> 中每个元素的编码则是根据路径下每个文件的编码格式而异的。</p><p>值得注意的时，在 python2 中，字符串一共有两种类型，str 或 unicode。</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">s = <span class="string">'中文'</span>  <span class="comment"># 注意这里的 str 是 str 类型的，而不是 unicode</span></span><br><span class="line">s.encode(<span class="string">'gb18030'</span>)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这句代码将 s 重新编码为 gb18030 的格式，即进行 unicode -&gt; str 的转换。因为 s 本身就是 str 类型的，因此 Python 会自动的先将 s 解码为 unicode ，然后再编码成 gb18030。因为解码是 python 自动进行的，我们没有指明解码方式，python 就会使用 sys.defaultencoding 指明的方式来解码。很多情况下 sys.defaultencoding 是 ASCII，如果 s 不是这个类型就会出错。拿上面的情况来说，我的 sys.defaultencoding 是 ASCII，而 s 的编码方式和文件的编码方式一致，是 utf8 的，所以出错了:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe4 in position</span><br><span class="line">0: ordinal not in range(128)</span><br></pre></td></tr></table></figure><blockquote><p>此问题的解决方案有以下两种:<br>一是明确的指示出 s 的解码方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; # -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">s = &apos;中文&apos;</span><br><span class="line">s.decode(&apos;utf-8&apos;).encode(&apos;gb18030&apos;)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>二是更改 <code>sys.defaultencoding</code> 为文件的编码方式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">reload(sys) # Python2.5 初始化后会删除 sys.setdefaultencoding 这个方法，我们需要重新载入</span><br><span class="line">sys.setdefaultencoding(&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">str = &apos;中文&apos;</span><br><span class="line">str.encode(&apos;gb18030&apos;)</span><br></pre></td></tr></table></figure><p>注意: 在 pycharm 等 IDE 中，一般新建一个文件都是默认的 UTF-8 编码，而在文件中显式地声明一个字符串时(前面没加 u)，此字符串采用的就是与文件同样的编码方式，即 UTF-8. 也就是说，当你在一个 python 脚本里直接定义一个字符串常量的时候，此字符串的编码方式和环境编码方式相同。注意，如果一个 str 变量是从外部传过来的，如 glob 函数返回的，则此变量的编码方式可能会和源文件编码方式不一样。</p><br><h1 id="python-中的-str-和-unicode"><a class="markdownIt-Anchor" href="#python-中的-str-和-unicode"></a> python 中的 str 和 unicode</h1><p>简体中文版 Windows 系统，编码方式为 GBK</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="string">'你好'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'\xc4\xe3\xba\xc3'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="string">u'你好'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">u'\u4f60\u597d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> a</span><br><span class="line">你好</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> b</span><br><span class="line">你好</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__class__</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(a)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(b)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>由以上代码段可以看出，直接定义一个字符串常量的时候，即 str 的时候，其编码方式为 GBK，是环境的编码方式，</p><p>在一个系统编码为UTF-8的Linux环境下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'你好'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'/xe4/xbd/xa0/xe5/xa5/xbd'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">u'你好'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">u'/u4f60/u597d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> a</span><br><span class="line">你好</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> b</span><br><span class="line">你好</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__class__</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(a)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(b)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以看出，在此 Linux 中，str 的编码方式为 utf-8，也是环境的编码方式。</p><p>len(string)返回string的字节数，len(unicode)返回的是字符数</p><blockquote><p>print(string) 的时候，如果 string 是按当前环境编码方式编码的，可以正常输出，不会乱码；如果 string 不是当前环境编码的，就会乱码。而 print(unicode) 是不会乱码的。why？因为 print(unicode) 的时候，会把 unicode 先转成当前编码，然后再输出。我没看过 print 的源码，不过估计是这样的。</p></blockquote><p>关于 <code>如果 string 不是当前环境编码的，就会乱码。</code> 这句，可由一下代码证实:<br><a href="http://coding.py" target="_blank" rel="noopener">coding.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">s = <span class="string">'路飞学院'</span></span><br><span class="line"><span class="keyword">print</span> s</span><br></pre></td></tr></table></figure><p>在使用 GBK 的 terminal 中，输出为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\sean\PycharmProjects\working&gt;python coding.py</span><br><span class="line">璺瀛﹂櫌</span><br></pre></td></tr></table></figure><p>这是因为，s 使用文件编码方式 utf-8 进行编码，而 terminal 是 gbk 编码的，因此会出现乱码。若在声明中使用 gbk，则不会出现乱码(已亲测)。</p><br><h2 id="python2-还是-python3"><a class="markdownIt-Anchor" href="#python2-还是-python3"></a> python2 还是 python3</h2><p>以上所说的都是针对 python2，python3 针对编码部分进行了改进。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">s = <span class="string">'路飞学院'</span></span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>以上这段代码，在 python2 中执行结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\sean\PycharmProjects\working&gt;python coding.py</span><br><span class="line">璺瀛﹂櫌</span><br></pre></td></tr></table></figure><p>在 python3 中为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\sean\PycharmProjects\working&gt;D:\Develop\Anaconda2\setup\envs\tensorflow\python coding.py</span><br><span class="line">路飞学院</span><br></pre></td></tr></table></figure><p>原因如下：</p><blockquote><p>  utf-8 编码之所以能在 windows gbk 的终端下显示正常，是因为到了内存里 python 解释器把 utf-8 转成了 unicode, 但是这只是 python3, 并不是所有的编程语言在内存里默认编码都是 unicode。比如，万恶的 python2 就不是，它的默认编码是 ASCII，想写中文，就必须声明文件头的 coding 为 gbk 或 utf-8, 声明之后，python2 解释器仅以文件头声明的编码去解释你的代码，加载到内存后，并不会主动帮你转为 unicode，也就是说，你的文件编码是 utf-8，加载到内存里，你的变量字符串就也是 utf-8 编码的。如果需要显示在 gbk 的终端下，就只能使用 decode 或 encode 函数转换成 unicode 或者再使用 gbk 进行编码。</p></blockquote><hr><blockquote><p>PY3 除了把字符串的编码改成了 unicode, 还把str 和 bytes 做了明确区分， str 就是 unicode 格式的字符， bytes 就是单纯二进制</p></blockquote><hr><blockquote><p>python2 的字符串其实更应该称为字节串。通过存储方式就能看出来，但 python2 里还有一个类型是 bytes ，难道又叫 bytes 又叫字符串？是的，在 python2 里，bytes == str ， 其实就是一回事。除此之外，python2 里还有个单独的类型 unicode , 把字符串解码后，就会变成 unicode。</p></blockquote><hr><blockquote><p>总之，Python只要出现各种编码问题，无非是哪里的编码设置出错了<br>常见编码错误的原因有：</p></blockquote><ul><li>Python解释器的默认编码</li><li>Python源文件文件编码</li><li>Terminal使用的编码</li><li>操作系统的语言设置</li></ul><blockquote><p>掌握了编码之前的关系后，挨个排错就好了。</p></blockquote><p><a href="http://www.cnblogs.com/huxi/archive/2010/12/05/1897271.html" target="_blank" rel="noopener">这篇文章非常不错</a>，可以参考了解。<br><br></p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://blog.csdn.net/ktb2007/article/details/3876436" target="_blank" rel="noopener">https://blog.csdn.net/ktb2007/article/details/3876436</a><br><a href="https://blog.csdn.net/ktb2007/article/details/3876429" target="_blank" rel="noopener">https://blog.csdn.net/ktb2007/article/details/3876429</a><br><a href="https://www.zhihu.com/question/31833164/answer/381137073" target="_blank" rel="noopener">https://www.zhihu.com/question/31833164/answer/381137073</a><br><a href="https://blog.csdn.net/abyjun/article/details/50190243" target="_blank" rel="noopener">https://blog.csdn.net/abyjun/article/details/50190243</a><br><a href="https://medium.com/@jackyu/windows-cmd-ae8d4f84f8bf" target="_blank" rel="noopener">永久修改 cmd 代码页方法</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编码 </tag>
            
            <tag> unicode </tag>
            
            <tag> utf-8 </tag>
            
            <tag> 中文 </tag>
            
            <tag> 日文 </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将包含 caffe 的 python 工程打包成一个 exe 文件</title>
      <link href="/2018/07/09/Convert-python-project-to-exe/"/>
      <url>/2018/07/09/Convert-python-project-to-exe/</url>
      
        <content type="html"><![CDATA[<p>由于工作原因，需要将一个基于 caffe 的深度学习检测工程转换成 exe 文件，在此过程中遇到了许多问题，现将其记录下来，以供参考。</p><a id="more"></a><h1 id="fpn_ported-改动"><a class="markdownIt-Anchor" href="#fpn_ported-改动"></a> fpn_ported 改动</h1><h2 id="caffe-related"><a class="markdownIt-Anchor" href="#caffe-related"></a> Caffe related</h2><p>1 caffe/pycaffe.py L13 <code>from ._caffe</code> 改成了 <code>from caffe._caffe</code>。因为最后 <code>dist\runcaffe_fpn\</code> 里有一个  <code>caffe._caffe.pyd</code> 文件，因此需要 import 此文件。（个人解释见下文）<br>2 caffe/_<em>init_</em>.py L2 <code>from._caffe</code> 改成了 <code>from caffe._caffe</code><br>caffe/_<em>init_</em>.py L3 <code>from._caffe</code> 改成了 <code>from caffe._caffe</code><br>3 caffe 中关于图像读入的部分都是用的 skimage 进行实现，但是似乎 pyinstaller 对 skimage 的支持并不好，因此需要对 caffe 中的相关部分用 cv2 进行替代。</p><blockquote><p>My Python project includes A Caffe module which run a simple image classification process. One basic function is Caffe calling <a href="http://skimage.io" target="_blank" rel="noopener">skimage.io</a> to load image:<br><a href="https://github.com/BVLC/caffe/blob/master/python/caffe/io.py" target="_blank" rel="noopener">https://github.com/BVLC/caffe/blob/master/python/caffe/io.py</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_image</span><span class="params">(filename, color=True)</span>:</span></span><br><span class="line">    img = skimage.img_as_float(skimage.io.imread(filename, as_grey=<span class="keyword">not</span> color)).astype(np.float32)</span><br><span class="line">    <span class="keyword">if</span> img.ndim == <span class="number">2</span>:</span><br><span class="line">        img = img[:, :, np.newaxis]</span><br><span class="line">        <span class="keyword">if</span> color:</span><br><span class="line">            img = np.tile(img, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">elif</span> img.shape[<span class="number">2</span>] == <span class="number">4</span>:</span><br><span class="line">        img = img[:, :, :<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure><blockquote><p>I wonder if PyInstaller currently has a good support for Python package skimage. But from what I know by now, it doesn’t.</p></blockquote><blockquote><p>Run from Python source code files, it works fine. But when I packed all things into one single binary file, it can not load image at all. And after debugging and googleing for a long time – I always thought maybe I did something wrong – I get rid of this. PyInstaller hates skimage! So at last I use cv2 instead. And it works smoothly.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv2_load_image</span><span class="params">(filename, color=True)</span>:</span></span><br><span class="line">    img = cv2.imread(filename).astype(np.float32) / <span class="number">255</span></span><br><span class="line">    <span class="keyword">if</span> img.ndim == <span class="number">3</span>:</span><br><span class="line">        img[:,:,:] = img[:,:,<span class="number">2</span>::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> img.ndim == <span class="number">2</span>:</span><br><span class="line">        img = img[:, :, np.newaxis]</span><br><span class="line">        <span class="keyword">if</span> color:</span><br><span class="line">            img = np.tile(img, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">elif</span> img.shape[<span class="number">2</span>] == <span class="number">4</span>:</span><br><span class="line">        img = img[:, :, :<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure><blockquote><p>For all above details, please do check out PyInstaller Documentation: <a href="https://media.readthedocs.org/pdf/pyinstaller/latest/pyinstaller.pdf" target="_blank" rel="noopener">https://media.readthedocs.org/pdf/pyinstaller/latest/pyinstaller.pdf</a></p></blockquote><p>具体参考<a href="https://handong1587.github.io/programming_study/2016/12/24/pyinstaller-and-others.html#continue-tackling-weird-stuffs" target="_blank" rel="noopener">这篇文章</a></p><br><h2 id="numpy-related"><a class="markdownIt-Anchor" href="#numpy-related"></a> Numpy related</h2><p>1 numpy.core._<em>init_</em>.py 中 <code>from .info import __doc__</code> 改成 <code>from numpy.core.info import __doc__</code><br>2 <code>from . import multiarray</code> 改成 <code>from numpy.core import multiarray</code><br>3 将 numpy.core._<em>init_</em>.py 中其他的代表当前目录的 <code>.</code> 都替换成 <code>numpy.core</code><br>4 将 <a href="http://numpy.fft.fftpack.py" target="_blank" rel="noopener">numpy.fft.fftpack.py</a> 中的 <code>from . fft import fftpack_lite as fftpack</code> 改成 <code>from numpy.fft import fftpack_lite as fftpack</code><br>5.将 numpy.random._<em>init_</em>.py 中的 <code>from .mtrand import *</code> 改成 <code>from numpy.random.mtrand import *</code><br><strong>个人观点：</strong> 似乎无需像第3步一样将所有的 . 都改成绝对路径，貌似只有使用 <code>.</code> 导入 pyd 文件的导入语句会报找不到的错误。因此只需将导入 pyd 文件的语句更改即可。</p><br><h2 id="os-ospath-related"><a class="markdownIt-Anchor" href="#os-ospath-related"></a> os, os.path related</h2><h3 id="problem"><a class="markdownIt-Anchor" href="#problem"></a> Problem</h3><p>  打包后运行时，在最外层的 runcaffe_fpn.py 中 import os 可以成功，但是在  <code>models/rpn/proposal_layer.py</code> 和 <code>lib/config.py</code> 中 <code>import os</code> 就会报错 <code>no module named path</code>。</p><br><h3 id="analysis"><a class="markdownIt-Anchor" href="#analysis"></a> Analysis</h3><p>  由于 os 和 os.path 的特殊性，即 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 中根据平台不同，import 不同的文件作为 path 模块，例如，在 Windows 中，使用 <code>import ntpath as path</code> 并将其命名为 os.path 模块。此外，<a href="http://os.py" target="_blank" rel="noopener">os.py</a> 和 <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 文件存在相互 import 的情况，不知为什么，工程中一些文件中，如 <a href="http://config.py" target="_blank" rel="noopener">config.py</a> 中，import os 语句会报错 no module namded path。</p><br><h3 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h3><p>  <s>由于 <a href="http://config.py" target="_blank" rel="noopener">config.py</a> 等文件中调用了 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 中的 makedirs 等函数以及 <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 中的一些函数。因此，尝试将 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 与 <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 文件解耦（其实是无法解耦的，因为 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 需要导入 <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 中的属性并供其函数使用），因此将 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 中 <code>import ntpath as path</code>  句注释，将 <code>sys.modules['os.path'] = path</code> 和 <code>from os.path import (curdir, pardir, sep, pathsep, defpath, extsep, altsep, devnull)</code> 注释掉，换成 <code>from _ntpath import (curdir, pardir, sep, pathsep, defpath, extsep, altsep, devnull)</code> （<code>from _ntpath</code> 是因为如果直接使用 <code>from ntpath</code> 的话，它会自动调用 anaconda 下的 <code>ntpath.py</code> 文件，会导致前面的错误，因此，将 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 和 <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 文件拷贝至一个包下，并都在前面加上下划线进行重命名）。实际操作中，我是创建了一个名为 os_modified 的包，并将重命名后的 _os.py 和 _ntpath.py 文件放进去作为模块。在工程文件中调用 os 和 os.path 的地方，将 <code>import os</code> 和 <code>import os.path as osp</code> 改成 <code>import modified_os._os as os</code> 和 <code>import modified_os._ntpath as osp</code>。工程文件中导入的其他一些包，如 genericpath，也会 import os，我也将这些文件拷贝进 modified_os 中重命名， 如 _genericpath，并将其中的 import os 改成 import _os as os。在工程文件中有 <code>import genericpath</code> 的地方改成 <code>import modified_path._genericpath as genericpath</code>。其他有类似情况的也按此方法处理。总之，os_modified 模块下，都是在工程文件中使用到，且其有 <code>import os</code> 或 <code>import os.path</code> 的，我将所有这些文件集中到一个名为 modified_os 的模块下，当工程文件中调用到这些时，就调用此模块下的版本，而不是 anaconda 的原始版本。这样就解决了 <code>no module named path</code> 的错误。</s></p><br><h3 id="comment"><a class="markdownIt-Anchor" href="#comment"></a> Comment</h3><p>  上面所述的关于 os, os.path 的部分全部不需要，只需要将 <a href="http://os.py" target="_blank" rel="noopener">os.py</a>, <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 两个文件通过 <code>--add-binary=&quot;/path/to/os.py;.&quot; --add-binary=&quot;/path/to/ntpath.py;.&quot;</code> 添加进去即可。这样，在 <code>dist/runcaffe_fpn/</code> 下就会有 <code>os.py</code> 和 <code>ntpath.py</code> 两个文件。当一个 <code>.py</code> 文件是从 exe 文件中开始执行，即是 boundled 的时候，pyinstaller 的 bootloader 将 <code>frozen</code> 属性添加进 sys 模块中。因此，可以通过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> getattr(sys, <span class="string">'frozen'</span>, <span class="keyword">False</span>):</span><br><span class="line">    <span class="comment"># running in a bundle</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># running live</span></span><br></pre></td></tr></table></figure><p>来在工程文件中进行判断此工程文件是用 python 脚本调用执行的还是用 exe 文件调用执行的。如果是用 python 脚本调用，则根据其导入模块的结构进行 import。比如 <code>fast_rcnn/nms_wrapper.py</code> 需要导入 <code>nms/gpu_nms.pyd</code> 和 <code>fast_rcnn/config.py</code>。在脚本模式下，需使用 <code>from nms.gpu_nms import gpu_nms</code> 和 <code>from fast_rcnn.config import cfg</code> 进行调用。而在 boundle 模式下，使用 <code>from gpu_nms import gpu_nms</code> 和 <code>from config import cfg</code> 进行调用即可。需要注意的是，在 boundle 模式下，还需使用 <code>--add-binary</code> 选项将 <code>gpu_nms.pyd</code> 和 <code>config.py</code> 两个文件添加进去，这样它的 import 语句才会生效。</p><p>上述做法有效的<font color="orange"><strong>原因</strong></font>是：pyinstaller 似乎将工程中不同层次的脚本（即存在调用关系）所需的依赖都展开放在最后打包的依赖项所在的文件夹下，即 <code>sys._MEIPASS</code> 所指向路径下，是没有目录层次的。因此，当处于 boundle 模式下时，<code>from gpu_nms import gpu_nms</code> 语句会直接对 <code>sys.__MEIPASS</code> 目录下的 <code>gpu_nms.pyd</code> 文件进行 import。在解决 os, os.path 问题时，将 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 和 <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 文件都添加进去，就不会有找不到的问题。并且按照理论，import os 所导入的文件应该是 <code>sys._MEIPASS</code> 路径下的 <a href="http://os.py" target="_blank" rel="noopener">os.py</a>。（已验证）</p><p>工程文件中的示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> getattr(sys, <span class="string">'frozen'</span>, <span class="keyword">False</span>): <span class="comment"># boundle 模式</span></span><br><span class="line">    <span class="keyword">from</span> gpu_nms <span class="keyword">import</span> gpu_nms</span><br><span class="line">    <span class="keyword">from</span> config <span class="keyword">import</span> cfg</span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 脚本模式</span></span><br><span class="line">    <span class="keyword">from</span> nms.gpu_nms <span class="keyword">import</span> gpu_nms</span><br><span class="line">    <span class="keyword">from</span> fast_rcnn.config <span class="keyword">import</span> cfg</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;解决了 os 和 pyd 文件导入的问题后，exe 可以成功运行了。但是美中不足的是，运行 exe 除了需要作为参数的那些文件外，还一直需要 `proposal_layer.py` 文件，这是不好的，因为不能向客户透露源码。因此，尝试将 `proposal_layer.py` 文件也用 `--add-binary` 选项添加进去。但是这样并没有用。究其原因是，`proposal_layer.py` 是在 `.prototxt` 文件中指定的（即 python 层中的 module 参数），原来为 `module: rpn.proposal_layer`。这是因为 prototxt 文件同级目录下有一个 rpn 文件夹，其下有一个 `proposal_layer.py` 文件。由于将 `proposal_layer.py` 文件添加进 `sys._MEIPASS` 后其名称仍为 `proposal_layer.py`，而 prototxt 中指定为 `rpn.proposal_layer`，不统一。因此，将 rpn 文件夹下的两个文件，`proposal_layer.py` 和 `generate_anchors.py`，放置到与 prototxt 文件同级目录下，并将 prototxt 中的 `rpn.proposal_layer` 改成 `proposal_layer`. 再将 `proposal_layer.py` 用 `--add-binary` 添加进去，就可以在 `sys._MEIPASS` 中调用 `proposal_layer.py` 了，这样再运行单个的 exe 文件时就不需带着 `proposal_layer.py` 文件了，因为它会调用 `sys._MEIPASS` 下的 `proposal_layer.py`。<p>Pyinstaller 打包命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F --add-binary=&quot;models/nms/gpu_nms.pyd;.&quot; ^</span><br><span class="line">               --add-binary=&quot;models/fast_rcnn/bbox_transform.py;.&quot; ^</span><br><span class="line">               --add-binary=&quot;models/fast_rcnn/config.py;.&quot; ^</span><br><span class="line">               --add-binary=&quot;models/fast_rcnn/nms_wrapper.py;.&quot; ^</span><br><span class="line">               --add-binary=&quot;models/proposal_layer.py;.&quot; ^</span><br><span class="line">               --add-binary=&quot;models/generate_anchors.py;.&quot; ^</span><br><span class="line">               --add-binary=&quot;H:/Develop/Anaconda2/setup/Lib/os.py;.&quot; ^</span><br><span class="line">               --add-binary=&quot;H:/Develop/Anaconda2/setup/Lib/ntpath.py;.&quot; ^</span><br><span class="line">               runcaffe_fpn.py</span><br></pre></td></tr></table></figure><p>最后，如上面的代码所示，我是将所有的除 caffe 模块外的额外 python 脚本都添加进了 <code>sys._MEIPASS</code> 中，保证可以有效调用。</p><h1 id="pyinstaller-使用方法记录"><a class="markdownIt-Anchor" href="#pyinstaller-使用方法记录"></a> Pyinstaller 使用方法记录</h1><h2 id="pyinstaller-运行时路径问题"><a class="markdownIt-Anchor" href="#pyinstaller-运行时路径问题"></a> Pyinstaller 运行时路径问题</h2><p>  pyinstaller 在打包后，会将 <code>frozen</code> 属性添加进 sys 变量。因此，可以使用 <code>getattr(sys, 'frozen', False)</code> 来判断当前执行的脚本是否是用 python 脚本执行的还是 exe 文件执行的。</p><p>  pyinstaller 有两种打包模式，一种是 onefile 模式，即将所有的依赖文件都打包成一个单独的 exe 文件，在运行此 exe 文件时，将其所包含的依赖文件临时解压到某个目录下，并在此目录下进行执行。另一种是 one-folder 模式，将生成的 exe 文件和依赖文件都放在 dist 文件夹下与被打包的 script 同名的文件夹中。在运行 exe 文件时，不需要将依赖文件解压，因此速度更快一些。很显然，one-file 模式的 exe 文件会比较大。当运行 exe 文件时，pyinstaller 的 bootloader 将 bundle folder 的绝对路径添加进 sys._MEIPASS 中。其实，这就是 exe 文件执行时，依赖文件所在的位置。需要注意的是，one-folder 模式下的 exe 文件必须和依赖文件在同一路径下，否则会找不到依赖。</p><br><h2 id="hidden-import"><a class="markdownIt-Anchor" href="#hidden-import"></a> hidden-import</h2><p>在一次测试中，我用 <code>R.py</code> 导入了 <code>libs/rpn/proposal_layer.py</code>，在<code>proposal_layer.py</code> 中 <code>from ..fast_rcnn.nms_wrapper import nms</code>，在 <code>libs/fast_rcnn.nms_wrapper.py</code> 中 <code>from ..nms.gpu_nms import gpu_nms</code>，在 <code>libs/nms/</code> 下有一个 <code>gpu_nms.pyd</code> 文件。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pyinstaller </tag>
            
            <tag> 打包 </tag>
            
            <tag> caffe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下 Caffe 的路径设置问题</title>
      <link href="/2018/07/04/Linux-caffe-path-setting/"/>
      <url>/2018/07/04/Linux-caffe-path-setting/</url>
      
        <content type="html"><![CDATA[<p>在 FRDC 的 8 GPU 服务器上，在 <code>import caffe</code> 后，在 ipython 中一直无法补全 caffe 的函数。研究了一下，终于解决了这个问题。</p><a id="more"></a><h1 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h1><ul><li>Centos 7</li><li>Caffe</li></ul><h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><ol><li>个人用户目录下有一 caffe 库，将其添加进 <code>PYTHONPATH</code> 后，无法有效调用。</li><li>尝试将其他用户下的 caffe 路径添加进 <code>PYTHONPATH</code>，依然无法有效调用。</li><li>在 <code>PYTHONPATH</code> 中删除所有 caffe 有关的路径，依然可以 <code>import caffe</code>，但无法有效调用。</li></ol><br><h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h1><ol><li>针对问题 3，使用 <code>caffe.__file__</code> 可以查看所调用 caffe 的文件地址，发现调用的是 caffe2 库下的一个 caffe 文件夹。这显然是不对的。由于 python 在其 <code>PYTHONPATH</code> 中依次向后查找调用库，当查找到第一个后，就使用第一个路径中的库，因此如果后面的 <code>PYTHONPATH</code> 中也包含某个库的话，后面的库就不会被调用。因此，我们需要将 caffe 的路径放在 caffe2 路径的前面。</li><li>针对问题 1，由于我在 <code>/home/taoxuan/</code> 路径下有一个 caffe 库，因此将其添加进 <code>PYTHONPATH</code>，但无法有效调用。将其从 <code>PYTHONPATH</code> 中删除后，使用 <code>caffe.__file__</code> 却依然指向此 caffe 库，遂将此库改名。</li><li>针对问题 2，将其他用户的 caffe 路径添加进 <code>PYTHONPATH</code> 后，依然正确调用，个人猜测是由于权限的问题。</li></ol><br><h1 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h1><p>将其他用户下的有效 caffe 库拷贝至个人目录下，更改所有者及组，<code>sudo chown -R taoxuan:taoxuan /path/to/caffe</code>。然后将此库的路径添加进 <code>PYTHONPATH</code>，这样就可以有效调用。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Caffe </tag>
            
            <tag> 权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下 Caffe 安装及测试</title>
      <link href="/2018/06/27/Caffe-install/"/>
      <url>/2018/06/27/Caffe-install/</url>
      
        <content type="html"><![CDATA[<p>由于工作需求，需在 Windows 平台安装 Caffe, 并在此基础上添加新的层，对 Caffe 进行重新编译。</p><a id="more"></a><br><h1 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h1><ul><li>Windows 10</li><li>Visual Studio 2015 Community Edition</li><li>Cuda 8.0</li><li>Cudnn 5.1</li><li>Anaconda2 虚拟环境中的 python 3.5</li><li>Cmake 3.11.1</li><li>BVLC/Caffe</li><li>Git</li></ul><br><h1 id="step-1"><a class="markdownIt-Anchor" href="#step-1"></a> STEP 1</h1><p>默认已经安装好 Cuda 8.0，并已经将 Cuda 的安装路径中的某些文件夹添加进环境变量。<br>默认已经将 Cudnn 中的文件放置到 Cuda 安装路径的对应文件夹中。<br>将 Cmake 命令所在路径添加进环境变量<br>将 python 环境中 python.exe 以及 lib 文件夹所在路径添加进环境变量。<br>将 Git 命令添加进环境变量。</p><br><h1 id="step-2"><a class="markdownIt-Anchor" href="#step-2"></a> STEP 2</h1><p>从 BVLC 的 Caffe Repo 上下载 Caffe 工程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/BVLC/caffe.git</span><br><span class="line"><span class="built_in">cd</span> caffe</span><br><span class="line">git checkout windows</span><br></pre></td></tr></table></figure><br><h1 id="step-3"><a class="markdownIt-Anchor" href="#step-3"></a> STEP 3</h1><p>修改 BVLC/Caffe windows 分支下 <code>scripts\build_win.cmd</code> 文件<br>因为我们没有定义 <code>APPVEYOR</code>，所以直接拉到 <code>else</code>（大约 69 行）以后。在 <code>else</code> 代码块中，设置相应参数：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WITH_NINJA=<span class="number">0</span> // 不使用 ninja 这个 generator，因为会报错。查看 cmake 拥有的 generator, 在 <span class="built_in">cmd</span> 中输入 cmake --<span class="built_in">help</span></span><br><span class="line">CPU_ONLY=<span class="number">0</span></span><br><span class="line">PYTHON_VERSION=<span class="number">3</span> // 根据自己的 python 版本来</span><br><span class="line">BUILD_PYTHON=<span class="number">1</span> // 安装 pycaffe</span><br><span class="line">BUILD_PYTHON_LAYER=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">// 在 cake -G ... 这一段中，添加一个选项.(其实这一段可以不加我感觉，因为已经将 cudnn 文件放到 cuda 的安装路径中了，不过加了也没啥)</span><br><span class="line">-DCUDNN_ROOT=H:/Develop/cudnn/cudnn5.<span class="number">1</span>/cuda ^</span><br></pre></td></tr></table></figure><br><h1 id="step-4"><a class="markdownIt-Anchor" href="#step-4"></a> STEP 4</h1><p>运行 <code>scripts/build_win.cmd</code> 文件，等其完成。它会先编译 <code>.cu</code> 文件，再编译 <code>.cpp</code> 文件。最后会生成 <code>caffe.exe</code> 等可执行文件以及 caffe 的 python 接口。<br>注意：在编译过程中，脚本可能会下载一个依赖包到 <code>C:\\Users\username\.caffe\dependencies</code> 文件夹下，可手动下载，将其解压到此文件夹即可。<br>Note：此脚本执行完毕后，不用再打开 <code>Caffe.sln</code> 工程进行 build，因为这些工作在脚本里都完成了。<br>最后得到的可执行程序在 <code>caffe/build/tools/Release</code> 中，python 接口在 <code>caffe/python/caffe</code> 中，将 <code>caffe/python/caffe</code> 路径添加进 python 的环境变量中或者将此文件夹拷贝进 python 的 <code>site-packages</code> 中均可在 python 中调用 caffe 的 python 接口。</p><br><h1 id="step-5"><a class="markdownIt-Anchor" href="#step-5"></a> STEP 5</h1><p>对编译结果进行测试。参考 <a href="https://software.intel.com/zh-cn/articles/installation-and-configuration-of-bvlc-caffe-under-windows-the-caffe-learning-notes-part1" target="_blank" rel="noopener">这篇文章</a></p><br><h1 id="添加自定义层"><a class="markdownIt-Anchor" href="#添加自定义层"></a> 添加自定义层</h1><p>由于任务需求，因此需要在 Caffe 中添加新的层，这只要涉及 caffe 中的 <code>/include</code> 和 <code>/src</code> 文件夹，将需要添加的文件拷贝进原生的 BVLC/Caffe 中，（注意：不可整体替换这两个文件夹中的所有源码文件，因为相同文件名文件的代码可能是有区别的，因此，只将新增的源码添加进 Caffe 工程中即可），并根据改变，修改 <code>src/proto/caffe.proto</code> 文件，具体方法看 <a href="https://blog.csdn.net/bvl10101111/article/details/74837156" target="_blank" rel="noopener">这篇文章</a>。<br>最后，按上述步骤重新编译即可。</p><br><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ol><li><a href="https://software.intel.com/zh-cn/articles/installation-and-configuration-of-bvlc-caffe-under-windows-the-caffe-learning-notes-part1" target="_blank" rel="noopener">https://software.intel.com/zh-cn/articles/installation-and-configuration-of-bvlc-caffe-under-windows-the-caffe-learning-notes-part1</a></li><li><a href="https://blog.csdn.net/bvl10101111/article/details/74837156" target="_blank" rel="noopener">https://blog.csdn.net/bvl10101111/article/details/74837156</a></li></ol><br><h1 id="trouble-shooting"><a class="markdownIt-Anchor" href="#trouble-shooting"></a> Trouble Shooting</h1><h2 id="trouble-on-windows"><a class="markdownIt-Anchor" href="#trouble-on-windows"></a> Trouble on Windows</h2><p>1.在按上面的步骤成功编译后，再使用命令 <code>/path/to/caffe.exe test -model /path/to/my.prototxt -weights /path/to/my.caffemodel</code> 进行测试，会报错如下图。 <img src="1.png" alt="报错信息"><br>可以看出，新添加的五个层里有三个已经存在，分别是 <code>DeformableROIPooling</code>, <code>ROIPooling</code> 和 <code>SmoothL1Loss</code>, 不存在的两个层为 <code>DeformableConvolution</code> 和 <code>ResizeBilinear</code>. 通过查看 <code>src/caffe/layers/deformabe_conv_layer.cpp</code> 和 <code>src/caffe/layers/resize_bilinear_layer.cpp</code> 文件，发现这两个文件都在最后一行差了 <code>REGISTER_LAYER_CLASS(DeformableConvolution);</code> 或 <code>REGISTER_LAYER_CLASS(ResizeBilinear);</code>。在这两个文件后分别添加对应的代码，重新编译。<br>通过比较，发现原版 BVLC-Caffe 的 <code>src/caffe/layer_factory.cpp</code> 和 添加过新层的 cafe-fast-rcnn 这个 Caffe 的 <code>src/caffe/layer_factory.cpp</code> 文件有所不同，更改过的文件中有关于 <code>DeformableConvolution</code> 和 <code>ResizeBilinear</code> 的内容，（可通过文档比较工具查看）。个人猜测这个就是上面 <code>src/caffe/layers/deformabe_conv_layer.cpp</code> 和 <code>src/caffe/layers/resize_bilinear_layer.cpp</code> 文件没有最后一个 <code>REGISTER</code> 语句，而其在 Linux 平台能够调用 <code>DeformableConvolution</code> 层的原因。但是，我从网上找到一个博客说，新版 Caffe 不需要在 <code>layer_factory.cpp</code> 文件中添加相关内容，只需要在对应 <code>.cpp</code> 文件中写上 <code>REGISTER</code> 语句就好。</p><blockquote><p>2）配置该层：包括注册和在caffe.proto中设置相关参数。在较新版本的caffe中，用户只需要<br>在编译caffe的过程中，会根据caffe.proto文件中定义的参数接口来编译相关层的代码。一般只需要做3.1和3.2两部即可。<br>注意：不需要在layer_factory.cpp文件中添加新层的头文件。<br><a href="https://blog.csdn.net/king_lu/article/details/53812216" target="_blank" rel="noopener">来源</a></p></blockquote><p>经过验证，我发现确实只要在 <code>.cpp</code> 文件后面添加对应的 <code>REGISTER</code> 语句就好。</p><p>2.在解决了上述问题后，执行 <code>/path/to/caffe.exe test -model /path/to/my.prototxt -weights /path/to/my.caffemodel -gpu 0</code>，报错 <code>Py_Initialize fails - unable to load the file system codec</code>，找了很多资料，觉得可能是多个版本的 python 冲突问题，但是我把环境变量 <code>PATH</code> 中全部改成有关虚拟环境 <code>tensorflow</code> 下的路径都无效。个人感觉是不知道在哪里仍然默认指向 Anaconda2 的外层 python，即使在 <code>PATH</code> 中修改也无效。因此，我重新用 python2.7 编译了自定义的 caffe。完成后执行上句命令，不再报此错误，而是报 <code>ImportError: No module named site</code>，我使用<a href="https://stackoverflow.com/questions/5599872/python-windows-importerror-no-module-named-site" target="_blank" rel="noopener">此处的最高票答案</a>解决了问题。继续执行前面的命令，出现 <code>ImportError: No module named gpu_nms</code>，这是由代码 <code>from nms.gpu_nms import gpu_nms</code> 引起的，目的是从 <code>gpu_nms.so</code> 文件中导入 <code>gpu_nms</code> 函数。而 <code>gpu_nms.so</code> 是 linux 平台上的动态链接文件，不能在 windows 上使用，因此需要从源码重新编译出 windows 下的动态链接文件。使用 <a href="https://github.com/MrGF/py-faster-rcnn-windows" target="_blank" rel="noopener">此工程</a> 并运行 <code>python setup_cuda.py build</code> 可编译出 Windows 下的 <code>.pyd</code> 文件供 python 导入。（运行前需先修改 <code>include_dirs = [numpy_include, '/path/to/cuda/include']</code>，且有可能会提示需安装 VC 9.0，根据提示下载安装即可），这样，就能导入 gpu_nms 函数了。</p><p>3.解决上述问题后，执行命令，会报一个 <code>MS VC</code> 有关的错 - <code>Runtime error R6034</code>，这个是一个与 <code>msvcr90.dll</code> 有关的错。这个 <code>dll</code> 文件是由系统提供的，根据后来分析发现，Anaconda 中也会提供这两个文件，分别位于 Anaconda 根目录和 <code>Library/bin</code> 目录下。我根据<a href="https://stackoverflow.com/questions/14552348/runtime-error-r6034-in-embedded-python-application" target="_blank" rel="noopener">这个问题的最佳答案</a>解决了此问题。由于环境变量 <code>PATH</code> 较为复杂，我无法修改 <code>PATH</code>，因此我将 Anaconda 中的两个文件进行了重命名，解决了这个问题。</p><p>4.解决了上述问题后，使用上述命令执行依旧错误，主要是在 <code>Creating layer rpn_rois</code> 处，会出现 <code>Caffe.exe 已经停止运行</code> 的错误。但是没有任何错误信息，困扰了好久。后来，我尝试使用 pycaffe 进行 test，在 <code>caffe.Net()</code> 函数中传入 <code>model_path</code> 和 <code>weights_path</code> 后执行，报错 <code>AttributeError: 'ProposalLayer' object has no attribute 'param_str_'</code>，这是由于 ProposalLayer 的定义中，有一句 <code>layer_params = yaml.load(self.param_str_)</code>，这是老版的 caffe 中定义的属性。由于我的是在新版的 bvlc-caffe 的基础上添加的新的层，因此会报错。而在 Linux 中没有报错，个人觉得是由于 Linux 版本的 modified caffe 是基于老版的 caffe 得到的。解决办法：将 <code>param_str_</code> 改成 <code>param_str</code> 即可，参考<a href="https://github.com/rbgirshick/py-faster-rcnn/issues/219" target="_blank" rel="noopener">这里</a>。</p><br><h2 id="trouble-on-linux"><a class="markdownIt-Anchor" href="#trouble-on-linux"></a> Trouble on Linux</h2><p>在 linux 中同样执行 <code>/path/to/caffe test -model /path/to/my.prototxt -weights /path/to/my.caffemodel</code> 时，会先报错<br><code>Creating layer rpn_rois ImportError: No module named rpn.proposal_layer</code><br>这是因为在执行时，<code>my.prototxt</code> 需要调用 <code>rpn/proposal_layer.py</code> 文件，因此，需要将 <code>rpn</code> 所在路径加入 <code>PYTHONPATH</code> 或者在此路径下执行。<br>上一步解决后，再次执行命令，会报错 <code>Check failed: registry.count(type) == 0 (1 vs. 0) Solver type Nesterov already registered.</code>. 这是因为 <code>.bashrc</code> 文件中将一个原生的 caffe 的 python 接口添加进了 <code>PYTHONPATH</code>, 而真正使用的是自己更改过的 caffe. 因此，将 <code>.bashrc</code> 中 <code>PYTHONPATH</code> 关于原生 caffe 的部分去掉。<br>后来，又报 <code>rpn/proposal_layer.py</code> 文件中 <code>calss ProposalLayer(caffe.Layer):</code> <code>AttributeError:'module' object has no attribute 'Layer'</code>。此时，将自己更改过的 caffe 的 python 接口添加进 <code>PYTHONPATH</code> 中即可。<br>总之，解决上面 2 个错误的关键就是将自己所使用的版本的 caffe 添加进 <code>PYTHONPATH</code>，并确保其他版本的 caffe 不在其中。<br>接着，继续运行同样的命令，会报错 <code>Check failed: status == CUDNN_STATUS_SUCCESS (8 vs. 0) CUDNN_STATUS_EXECUTION_FAILED</code>. 个人感觉这是一个跟 gpu 有关的错，由于 <code>.prototxt</code> 文件中在 <code>rpn_rois</code> 层设置了 <code>gpu_id</code> 参数，因此，需将此参数与 <code>caffe test</code> 命令执行时使用的 gpu id 相同。若文件内设置为 1，则命令应为 <code>/path/to/caffe test -model /path/to/my.prototxt -weights /path/to/my.caffemodel -gpu 1</code></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Caffe </tag>
            
            <tag> 安装 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 多线程模块 threading 及 多进程模块 multiprocessing</title>
      <link href="/2018/05/22/python-thread/"/>
      <url>/2018/05/22/python-thread/</url>
      
        <content type="html"><![CDATA[<p>关于 python 多线程模块 threading 以及 多进程模块 multiprocessing 的使用。</p><p><em><font color="orange">注意：本文代码均在 python 3.5 中实现，其他版本未亲测。</font></em></p><a id="more"></a><h1 id="threading-模块"><a class="markdownIt-Anchor" href="#threading-模块"></a> threading 模块</h1><p>  关于 python 的多线程模块 threading 的使用方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread 1 start'</span>, time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(<span class="string">'thread 1 end'</span>, time.time())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread 2 start'</span>, time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(<span class="string">'thread 2 end'</span>, time.time())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread 3 start'</span>, time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(<span class="string">'thread 3 end'</span>, time.time())</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=fun1)</span><br><span class="line">t2 = threading.Thread(target=fun2)</span><br><span class="line">t3 = threading.Thread(target=fun3)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br><span class="line">print(<span class="string">'主线程中间'</span>, time.time())</span><br><span class="line">t3.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(<span class="string">'主线程结束'</span>, time.time())</span><br></pre></td></tr></table></figure><p>输出为：</p><blockquote><p>thread 1 start 1526973092.5235336<br>thread 1 end 1526973097.535105<br>thread 2 start 1526973097.5354195<br>thread 3 start主线程中间 1526973097.5474474<br>1526973097.5414264<br>thread 2 end 1526973107.548385<br>thread 3 end 1526973112.5574799<br>主线程结束 1526973112.5574799</p></blockquote><p>  可以看出，thread 1 执行完毕了后，同时开始执行（几乎） thread2, thread3 和 print 语句，（print 语句是主线程中的），这是因为，在 thread1, thread2 调用之前，t1.join() 已经阻塞了别的线程。由于 thread3 用时较长，因此 thread2 先结束，然后 thread3 结束。在 thread3 结束后，主线程才执行最后的 print 语句。</p><p>  由于 python GIL (Global Interpreter Lock) 的限制，python 的多线程并没有达到真正的多线程的效果，不能充分地利用 CPU。但是多进程可以充分地利用 CPU，因此使用 multiprocessing 模块来使用多进程。</p><h1 id="multiprocessing-模块"><a class="markdownIt-Anchor" href="#multiprocessing-模块"></a> multiprocessing 模块</h1><p>  此处采用线程池的方式进行多线程操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(l, name, sur)</span>:</span></span><br><span class="line">    print(l + <span class="string">' '</span> + name + <span class="string">' '</span> + sur)</span><br><span class="line"></span><br><span class="line">arg_1 = [<span class="string">'adf'</span>, <span class="string">'freg'</span>, <span class="string">'gr3q'</span>, <span class="string">'saf'</span>, <span class="string">'qrg'</span>]</span><br><span class="line">arg_2 = [<span class="string">'sean'</span>]</span><br><span class="line">arg_3 = [<span class="string">'tao'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = Pool(processes=<span class="number">8</span>)</span><br><span class="line">    pool.starmap(func=fun, iterable=product(arg_1, arg_2, arg_3))</span><br><span class="line">    print(<span class="string">'all done'</span>)</span><br></pre></td></tr></table></figure><p>输出为:<br><img src="pic_1.png" alt="multiprocessing 输出"></p><p>以上代码为针对多参数的函数，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.starmap(func=fun, iterable=product(arg_1, arg_2, arg_3))</span><br></pre></td></tr></table></figure><p>是通过 itertools 的 product 函数，将三个参数进行笛卡儿积。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">product([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="string">'1'</span>]) <span class="comment"># 结果为 ('a','1')，('b', '1'), ('c', '1')</span></span><br></pre></td></tr></table></figure><p>关于 product 函数以及 itertools 包的使用，可点击<a href="https://docs.python.org/3/library/itertools.html#itertools.product" target="_blank" rel="noopener">这里</a>了解更多。</p><p>值得注意的是，product 函数的输入必须是 iterable 的。这样，才可以进行 笛卡儿积。</p><p>此外，多参数进程池还有别的方法，但未亲测。<br><a href="http://python.omics.wiki/multiprocessing_map/multiprocessing_partial_function_multiple_arguments" target="_blank" rel="noopener">pool.map - multiple arguments</a></p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p>1.<a href="https://stackoverflow.com/questions/5442910/python-multiprocessing-pool-map-for-multiple-arguments/24446525" target="_blank" rel="noopener">https://stackoverflow.com/questions/5442910/python-multiprocessing-pool-map-for-multiple-arguments/24446525</a><br>2.</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> thread </tag>
            
            <tag> process </tag>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 进程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jupyter notebook 增加内核</title>
      <link href="/2018/05/15/jupyter-add-kernel/"/>
      <url>/2018/05/15/jupyter-add-kernel/</url>
      
        <content type="html"><![CDATA[<p>在 jupyter notebook 中添加不同的 python 内核。</p><a id="more"></a><p>由于在 anaconda2 中安装了虚拟环境 tensorflow, 且虚拟环境中的 python 为 3.5，在虚拟环境中安装了 jupyter notebook，当在虚拟环境中的 jupyter notebook 中新建脚本时，只能选择 python3，因此想要把 anaconda2 中 2.7 的 python 内核导入进来，这样可以直接在一个 jupyter notebook 中新建不同内核的 python 脚本。</p><p>本文介绍在 python3 中添加 python2 内核。</p><p>首先确认在Python3下已安装了内核：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipython kernel install --user</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m ipykernel install --user</span><br></pre></td></tr></table></figure><p>然后确保 python2 下安装了 ipykernel</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip2 install -U ipykernel</span><br></pre></td></tr></table></figure><p>然后运行如下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 -m ipykernel install --user</span><br></pre></td></tr></table></figure><p>至此，运行 jupyter notebook 就可以添加多个内核。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vim</title>
      <link href="/2018/05/08/vim/"/>
      <url>/2018/05/08/vim/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>以下命令可以对标点内的内容进行操作。<br><code>ci'、ci&quot;、ci(、ci[、ci{、ci&lt;</code> - 分别更改这些配对标点符号中的文本内容<br><code>di'、di&quot;、di(或dib、di[、di{</code>或<code>diB、di&lt;</code> - 分别删除这些配对标点符号中的文本内容<br><code>yi'、yi&quot;、yi(、yi[、yi{、yi&lt;</code> - 分别复制这些配对标点符号中的文本内容<br><code>vi'、vi&quot;、vi(、vi[、vi{、vi&lt;</code> - 分别选中这些配对标点符号中的文本内容</p><p>另外如果把上面的 <code>i</code> 改成 <code>a</code> 则可以连带配对的标点一起操作～～</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deformable Convolutional Networks 论文理解</title>
      <link href="/2018/05/07/Deformable-Convolutional-Networks/"/>
      <url>/2018/05/07/Deformable-Convolutional-Networks/</url>
      
        <content type="html"><![CDATA[<p>关于 Deformable Convolutional Networks 的一些个人理解。</p><a id="more"></a><p>–   有效感受野 Effective Receptive Field<br><a href="">Understanding the effective receptive field in deep convolutional neural networks</a></p><blockquote><ul><li>感受野中的像素对最后的输出响应贡献不一。靠近中心的像素贡献更大。</li></ul></blockquote><ul><li>有效感受野只占理论感受野的一小部分，并且呈高斯分布。</li><li>有效感受野尺寸的增长幅度不是像理论感受野那样随卷积数目线性增长，而是与卷积数目的均方根线性相关。</li></ul><p>这个发现说明，<strong>即使是很深的 CNN 网络的顶层的单元的有效感受野也可能不够大。</strong></p><br><h1 id="deformable-convolution"><a class="markdownIt-Anchor" href="#deformable-convolution"></a> Deformable Convolution</h1><p>  对一个3*3的 deformable conv 来说，先在分支上进行卷积操作，得到的 offset field 与 input feature map 尺寸相同，通道数为 2N（对 3*3 卷积，N=9）。这样，offset field 每个位置处的 2N 维向量代表在 input feature map 上此处卷积时对应的 N 个位置的偏移。如下图所示。<br><img src="deform_conv.PNG" alt="3*3 deformable convolution"></p><h1 id="deformable-roi-pooling"><a class="markdownIt-Anchor" href="#deformable-roi-pooling"></a> Deformable ROI Pooling</h1><p>  首先通过标准的兴趣区域池化（绿色）获得兴趣区域对应的特征，该特征通过一个全连接层得到兴趣区域每个部位(每个 bin)的位移量。用该位移作用在标准的 ROI Pooling 的每个区域块上，得到 可变形兴趣区域池化（蓝色），以获得不局限于兴趣区域固定网格的特征<br>  简单地说，假如要对某个 ROI 区域进行 3*3 的 Deformable ROI Pooling，那么则先对此 ROI 进行普通的 ROI Pooling，得到 3*3*C (C 为 ROI pooling 前的 feature map 的 channel 数) 的 feature map。然后，对得到的 feature map 进行 fc，fc 层的输出个数为 k*k*2，其中 k 为 pooling 后的尺寸，此处为 3。这样，就得到 ROI 区域中每块 （共 k*k 块）的偏移了。根据这个偏移，得到每个块的新的位置，进行 ROI Pooling，就是 Deformable ROI Pooling。<br>所以，在 Deformable ROI Pooling 中，偏移是针对每个块（bin）的，某个 bin 内的所有像素的偏移都是一样的。<br><img src="deform_roi_pooling.PNG" alt="3*3 deformable ROI Pooling"></p><h1 id="position-sensitive-ps-roi-pooling-from-r-fcn"><a class="markdownIt-Anchor" href="#position-sensitive-ps-roi-pooling-from-r-fcn"></a> Position-Sensitive (PS) RoI Pooling - From R-FCN</h1><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> deformable convolution </tag>
            
            <tag> deformable RoI pooling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPN 论文理解</title>
      <link href="/2018/04/26/FPN/"/>
      <url>/2018/04/26/FPN/</url>
      
        <content type="html"><![CDATA[<p>本文给出了对 FPN 网络的理解。</p><a id="more"></a><h1 id="网络结构"><a class="markdownIt-Anchor" href="#网络结构"></a> 网络结构</h1><p>  常见的特目标测网络中特征的利用方式主要有 4 种</p><blockquote><p>*(a) 图像金字塔，即将图像做成不同的 scale，然后不同 scale 的图像生成对应的不同 scale 的特征。这种方法的缺点在于增加了时间成本。有些算法会在测试时候采用图像金字塔。<br>(b) 像 SPP net，Fast RCNN，Faster RCNN 是采用这种方式，即仅采用网络最后一层的特征。<br>© 像 SSD (Single Shot Detecto) 采用这种多尺度特征融合的方式，没有上采样过程，即从网络不同层抽取不同尺度的特征做预测，这种方式不会增加额外的计算量。作者认为 SSD 算法中没有用到足够低层的特征（在 SSD 中，最低层的特征是 VGG 网络的 conv4_3），而在作者看来足够低层的特征对于检测小物体是很有帮助的。<br>© 本文作者是采用这种方式，顶层特征通过上采样和低层特征做融合，而且每层都是独立预测的。</p></blockquote><ul><li></li></ul><p><img src="pic1.png" alt="检测网络的 4 种特征利用方式"><br>图中，线越粗表示特征的语义程度越强。</p><p>  与以往的方式不同，FPN 网络在 pyramid 的所有 level 上都进行预测。<br><img src="pic2.png" alt="FPN 网络在 pyramid 的所有 level 上进行预测"></p><p>  FPN 网络的内部结构<br><img src="pic3.png" alt="FPN 网络的内部结构"></p><blockquote><p><strong>自底向上</strong>其实就是网络的前向过程 (论文中使用的是 ResNet )。在前向过程中，feature map 的大小在经过某些层后会改变，而在经过其他一些层的时候不会改变，作者将不改变 feature map 大小的层归为一个 stage，因此每次抽取的特征都是每个 stage 的最后一个层输出，这样就能构成特征金字塔。<br><strong>自顶向下</strong>的过程采用上采样进行，而横向连接则是将上采样的结果和自底向上生成的相同大小的 feature map 进行融合。在融合之后还会再采用 3*3 的卷积核对每个融合结果进行卷积，目的是消除上采样的混叠效应。并假设生成的 feature map 结果是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>5</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P_2, P_3,P_4,P_5\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，和原来自底向上的卷积结果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>C</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>5</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{C_2,C_3,C_4,C_5\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 一一对应。</p></blockquote><br><h1 id="feature-pyramid-network-for-rpn"><a class="markdownIt-Anchor" href="#feature-pyramid-network-for-rpn"></a> Feature Pyramid Network for RPN</h1><p>  FPN 可以用在 RPN 网络中，从而提高多尺度物体的检测性能。与 Faster R-CNN 中不同的是，FPN 在不同的 level 上使用 anchor，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>5</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>6</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P_2, P_3,P_4,P_5, P_6\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 上的 anchor 尺寸分别是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mn>3</mn><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mn>6</mn><msup><mn>4</mn><mn>2</mn></msup><mo separator="true">,</mo><mn>12</mn><msup><mn>8</mn><mn>2</mn></msup><mo separator="true">,</mo><mn>25</mn><msup><mn>6</mn><mn>2</mn></msup><mo separator="true">,</mo><mn>51</mn><msup><mn>2</mn><mn>2</mn></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{32^2, 64^2, 128^2, 256^2, 512^2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">3</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>。可以看出，尺寸较大的 feature map 上的 anchor 的尺寸较小，适合用来检测小物体。<br><img src="pic4.png" alt="FPN 的 anchor 机制"></p><hr>*<font color="orange">关于 anchor 尺寸选取的个人理解。</font>*&emsp;&emsp;RPN 网络的输入 feature map 在原图上的感受野是固定的，取决于此 featured map 相对于原图的尺寸缩小了多少倍。缩小的倍数越大，相邻感受野的中心距离越远（因为 feature map 尺寸越小，就需要用越少的感受野覆盖整张原图，因此相邻感受野的中心距离就会越远）。如果在尺寸较小的 feature map 上使用尺寸较小的 anchor 的话，相邻感受野的 anchor 可能会不重叠，从而漏掉物体。![anchor 尺寸较小](pic5.png)&emsp;&emsp;但是在这种情况下选择较大尺寸 anchor 也会产生新的问题。当遇到小物体时，如果与大的 anchor 计算 IoU 时，IoU 可能较小，在生成样本时也会遇到问题。![anchor 尺寸较大时检测小物体](pic6.png)&emsp;&emsp;可以看出，由于 feature map 尺寸较小，对应在原图上的感受野个数也较少，因而需要用较少的 anchor 来覆盖原图。若 feature map 的尺寸较大，则用来覆盖原图的感受野的个数较多，则每个 anchor 的尺寸就不用太大，因而可以更好地检测小物体。![较大 feature map](pic7.png)&emsp;&emsp;可以看出，当 feature map 尺寸较大时，就可以用较小的 anchor 来覆盖原图，这样既不会出现 anchor 不相交从而漏检的情况，也不会造成小物体和 anchor 的 IoU 较小从而无法正确产生正样本的情况。<p><strong>从以上分析可以得出结论，尺寸较大的 feature map 适合用来检测用来检测小物体，尺寸较小的 feature map 适合用来检测大物体。因此，FPN 的思想就是将各种尺寸的 feature map 结合起来，将大物体分配给小的 feature map 进行检测，将小物体分配给大 feature map 进行检测，从而提升检测性能。</strong></p><br><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>  在 FPN 中，anchor 机制跟 Faster R-CNN 有所不同。FPN 产生了上文所述的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>5</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>6</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P_2, P_3,P_4,P_5, P_6\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 不同尺寸的 feature map，在一个 feature map 上只使用一个尺度的 anchor（Faster R-CNN 中为 3 个尺度）。在尺寸较大的 feature map 中使用尺度较小的 anchor，能够更好地检测小物体。</p><p>FPN 中有多个尺度的 feature map，每一个 feature map 作为输入进入一个 RPN。因此，有多少 feature map，就有多少 RPN。最后，将这些 RPN 的输出进行综合，得到所有的 proposals。</p><br><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://blog.csdn.net/u014380165/article/details/72890275" target="_blank" rel="noopener">https://blog.csdn.net/u014380165/article/details/72890275</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> Faster R-CNN </tag>
            
            <tag> FPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPN 中的 loss 理解</title>
      <link href="/2018/04/25/Faster-R-CNN/"/>
      <url>/2018/04/25/Faster-R-CNN/</url>
      
        <content type="html"><![CDATA[<p>本文解释了 Faster R-CNN 中的 RPN 部分的 GT 生成以及 loss 的计算方式.</p><a id="more"></a><h1 id="rpn-结构"><a class="markdownIt-Anchor" href="#rpn-结构"></a> RPN 结构</h1><p>  RPN 网络使用 特征提取网络的输出 feature map 作为输入. 然后在此基础上,用 anchor 的方式计算 分类误差 和 定位误差. Faster R-CNN 中的 RPN 网络在 caffe 框架中如下图所示.<br><img src="pic1.PNG" alt="RPN 网络结构图"><br>假设 RPN 网络输入 feature map 尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>×</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">s\times s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>, 那么图中 <em>rpn_cls_score</em> 和 <em>rpn_bbox_pred</em> 层的输出尺寸分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>×</mo><mi>s</mi><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">s\times s\times8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 以及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>×</mo><mi>s</mi><mo>×</mo><mn>36</mn></mrow><annotation encoding="application/x-tex">s\times s\times36</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">6</span></span></span></span>. <em>rpn-data</em> 是真实值, 与这两个 feature map 计算 loss. 可以推测, <em>rpn-data</em> 具有两个与 <em>rpn_cls_score</em> 和 <em>rpn_bbox_pred</em> 分别对应的 GT feature map. 对应于 <em>rpn_cls_score</em> 的真实值的尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>×</mo><mi>s</mi><mo>×</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">s\times s\times 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>, 对应于 <em>rpn_bbox_pred</em> 的真实值的尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>×</mo><mi>s</mi><mo>×</mo><mn>36</mn></mrow><annotation encoding="application/x-tex">s\times s\times 36</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">6</span></span></span></span>.</p><br><h1 id="ground-truth-的尺寸和计算方式"><a class="markdownIt-Anchor" href="#ground-truth-的尺寸和计算方式"></a> Ground Truth 的尺寸和计算方式</h1><p><em><font color="orange">以下部分为个人理解</font></em><br>  在 Faster R-CNN 中, RPN 输入 feature map 的每个空间位置都对应 9 个 anchor, (共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>×</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">s\times s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>个空间位置), 每个 anchor 产生一个预测框. Faster R-CNN 的正负样本生成策略是:</p><blockquote><ol><li>将每一个 GT box 与所有的 anchor 计算 IoU, 将 IoU 最大的 anchor 与当前 GT box 对应, 作为正样本, 记为 1. (这就保证了每个 GT box 至少有一个 anchor 与之对应)</li><li>将每一个 anchor 与 所有 GT box 计算 IoU, 若当前 anchor 与某一个 GT box 的 IoU 超过 0.7, 则将当前 anchor 与此 GT box 对应, 将当前 anchor 作为正样本, 记为 1. 对与所有 GT box 的 IoU 都小于 0.3 的 anchor 作为负样本, 记为 -1. 不满足上述条件的其他 anchor 不计入讨论, 记为 0.</li></ol></blockquote><p>  根据上述策略可以知道, anchor 和 GT box 之间是 多对多 的关系. 但是这是不合理的, 若一个 anchor 对应了 多个 GT box, 那岂不是这个 anchor 要负责检测多个物体? 这是不可能的. 因此, 个人感觉上述策略中, 第 2 步是在不满足第 1 步条件的 anchor 中进行的. 一旦一个 anchor 找到了与之对应的 GT box, 它就不会再与其他 GT box 计算 IoU, 这样, 即使某个 anchor 与 多个 GT box 的 IoU 都大于 0.7, 此 anchor 仍然只能与一个 GT box 对应.</p><p><font color="orange"><strong>2018/11/06 更新:</strong></font> 事实上，在为每个 anchor 匹配 GT box 时，是每一个 anchor 和每一个 GT box 算 IoU，为每个 anchor 找到与之 IoU 最大的 GT box。并计算每个 anchor 和与之对应的 GT box 之间的 delta 作为 RPN 学习的目标。</p><p>  因此, 从 GT box 的角度看, <font color="green">一个 GT box 有一个或多个 anchor 与之对应, 这些 anchor 负责检测这个 GT box.</font></p><br><h1 id="ground-truth-及-相关图示"><a class="markdownIt-Anchor" href="#ground-truth-及-相关图示"></a> Ground Truth 及 相关图示</h1><p>下图为每一个空间位置处的向量.<br><img src="pic2.png" alt="每个空间位置处的向量"><br>  在上图中, GT class 是一个 9 维的向量, 其可能值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">1,-1,0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span></span></span></span>, 1 表示正样本, 0 表示负样本, -1 表示非样本. 相同颜色表示某一空间位置处的不同类型的值. 在 GT class 向量中某处为 1 , 表示此空间位置处的此处的 anchor 为正样本, GT bbox 向量中对应的 4 个值为此 anchor 对应的 GT box 的真实 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,w,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>. 这样就可以与 rpn_cls_score 和 rpn_bbox_pred 对应位置的预测值计算损失. 针对正样本, 要计算 分类 和 定位 两种损失, 对于负样本, 只计算 分类损失, 因此 GT bbox 向量中对应位置的值不参与计算. 对于非样本, 不计算任何损失. 因此在生成 GT bbox 向量时, 只需计算正样本 anchor 对应 GT box 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,w,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span> 值.</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> Faster R-CNN </tag>
            
            <tag> RPN </tag>
            
            <tag> anchor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yolo v2 论文理解</title>
      <link href="/2018/04/20/Yolo-v2/"/>
      <url>/2018/04/20/Yolo-v2/</url>
      
        <content type="html"><![CDATA[<p>本文针对 Yolo v2 的一些处理方法和细节给出了自己的理解。不一定正确，如有错误请指正。</p><a id="more"></a><p>本文尝试了使用一系列的方法来提升检测效果。<br><br></p><h1 id="better"><a class="markdownIt-Anchor" href="#better"></a> Better</h1><h2 id="batch-normalization"><a class="markdownIt-Anchor" href="#batch-normalization"></a> Batch Normalization</h2><ul><li>在所有卷积层后加 Batch Normalization。</li><li>mAP 提高了2%。</li></ul><h2 id="high-resolution-classifier"><a class="markdownIt-Anchor" href="#high-resolution-classifier"></a> High Resolution Classifier</h2><ul><li>Yolo v1 使用 224×224 的图像预训练分类器，并用来对448的图像进行检测。这意味着网络的卷积层要在适应新的分辨率的同时还要学习检测。</li><li>Yolo v2 直接使用 448×448 的图像进行预训练。</li><li>mAP提高了4%。</li></ul><h2 id="convolutional-with-anchor-boxes"><a class="markdownIt-Anchor" href="#convolutional-with-anchor-boxes"></a> Convolutional With Anchor Boxes</h2><ul><li>Yolo 通过在卷积层上加全连接层来直接预测bbox的坐标。而 Faster R-CNN 使用 RPN 网络来预测 bbox 相对于 anchor 的 offset 和 confidence。预测 offset 比直接预测坐标来得简单。</li><li>Yolo v2 去除了全连接层，并减少了一个 Pooling 层。这样最后的 feature map 尺寸是输入的1/32。在这里，网络使用 416 尺寸而不是 448，因为作者想要最后的 feature map 尺寸为奇数。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>416</mn><mo>÷</mo><mn>32</mn><mo>=</mo><mn>13</mn></mrow><annotation encoding="application/x-tex">416\div32=13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span></span></span></span>。这是因为作者观察发现，很多物体都在图像的中间，因此检测这些图像中间的物体时，只需用最中心的那个位置而不是偶数情况下的中心4个位置。(个人理解为：在这种情况下，那些在图像中心位置的物体的中心点都会落在这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>13</mn><mo>×</mo><mn>13</mn></mrow><annotation encoding="application/x-tex">13\times 13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span></span></span></span> 栅格的中心格子中)</li><li>使用 anchor boxes 预测坐标的同时，Yolo v2 还对 conditional class probability 的预测机制和空间位置（栅格）做了解耦。<br>  在Yolo v1 将输入图像划分为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">S×S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 的栅格，每一个栅格预测 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 个 bounding boxes，以及这些 bounding boxes 的 confidence scores。<br>  每一个栅格还要预测 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 个 conditional class probability（条件类别概率）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mo stretchy="false">(</mo><mi>C</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi mathvariant="normal">∣</mi><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Pr(Classi|Object)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>。即在一个栅格包含一个 Object 的前提下，它属于某个类的概率。且每个栅格预测一组 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>个) 类概率，而不考虑框 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的数量。<br>  Yolo v2 不再由栅格去预测条件类别概率，而由 Bounding boxes 去预测。在 Yolo v1 中每个栅格只有1组条件类别概率，而在 Yolo v2 中，因为每个栅格有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 个 bounding boxes，所以有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 组条件类别概率。<br>在 Yolo v1 中输出的维度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>×</mo><mi>S</mi><mo>×</mo><mo stretchy="false">(</mo><mi>B</mi><mo>×</mo><mn>5</mn><mo>+</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S\times S \times (B \times 5 + C )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>，而 Yolo v2 为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>×</mo><mi>S</mi><mo>×</mo><mo stretchy="false">(</mo><mi>B</mi><mo>×</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mi>C</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S \times S \times (B \times (5 + C))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。如下图所示。</li><li>使用了Anchor box 后，mAP 从 69.5% 降到了 69.2%，但是 recall 从 81% 增加到了 88%。</li></ul><p><img src="pic1.png" alt="v1 和 v2 输出维度对比"></p><h2 id="dimension-clusters"><a class="markdownIt-Anchor" href="#dimension-clusters"></a> Dimension Clusters</h2><p>  采用 Anchor 机制后遇到两个遇到<font style="color:orange"> 两个问题 </font>，其中<font style="color:cyan"> 第一个 </font>为 anchor 尺寸的设置问题。Faster R-CNN 等网络的 anchor 的尺寸是人工选定的，虽然网络可以通过学习来调整预测框的尺寸，但是如果一开始就给一个较合适的 anchor 的话，网络学习起来会更加的容易。Yolo v2 通过 k-means 的方式来学习到 anchor 的尺寸分布情况。对训练集中的所有标定的框，即 GT box，根据他们的 <code>(x,y,w,h)</code> 的值进行 k-means 聚类。如果将用 <code>(x,y,w,h)</code> 来代表一个 GT box，并用4维向量的标准欧式距离来作为距离度量的话，大的框可能会比小的框产生更大的误差，比如 <code>(1,1,2,2)</code> 和 <code>(2,2,4,4)</code> 的欧式距离为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mn>10</mn></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">1</span><span class="mord">0</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>，而 <code>(2,2,4,4)</code> 和 <code>(4,4,8,8)</code> 的欧式距离为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><msqrt><mn>10</mn></msqrt></mrow><annotation encoding="application/x-tex">2\sqrt{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord">2</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">1</span><span class="mord">0</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>，而如果采用IoU的度量方式，这两对框的距离相等都是3/4。而后一种情况所代表的两种框是前一种情况两种框尺寸的两倍。因此，可以看出，采用IoU的方式作为两个框之间的距离度量，可以避免框的尺寸带来的影响。<br>  通过聚类，可以将所有的 <code>(x,y,w,h)</code> 聚为 <code>k</code> 类，最后得到 <code>k</code> 个类别中心，这 <code>k</code> 个类别中心就代表 <code>k</code> 个矩形框。论文中使用 Dimension Clusters 的结果如下图所示。<br><img src="pic2.jpg" alt="维度聚类-5类"></p><p>在网上看到另一种说法</p><blockquote><p>算法过程（k-means）是: 将每个 bbox 的宽和高相对整张图片的比例 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>h</mi><mi>r</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(w_r,h_r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 进行聚类,得到 k 个 anchor box.<br>算法实现代码可以参考: <a href="https://github.com/PaulChongPeng/darknet/blob/master/tools/k_means_yolo.py" target="_blank" rel="noopener">k_means_yolo.py</a><br>其实根据距离函数就可以看出，k-means 一定是对 <code>(x,y,w,h)</code> 进行聚类的（计算 IoU 需要用到 (x,y) ）。只不过最后不关注聚类中心的 <code>(x,y)</code> ，只关注聚类中心的 <code>(w,h)</code>。上面代码中的操作也证实了这一点。</p></blockquote><p>  与手工挑选的相比，使用 Dimension Clusters 的方法效果更好。对比效果如下图所示。<br><img src="pic3.jpg" alt="使用维度聚类效果对比"><br>其中 Cluster SSE 表示使用 sum squared error 作为度量进行聚类，Cluster IoU 表示使用 IoU 作为度量进行聚类。Anchor boxes 为采取类似 Faster R-CNN 中的方法。</p><h2 id="direct-location-prediction"><a class="markdownIt-Anchor" href="#direct-location-prediction"></a> Direct location prediction</h2><p>  前面提到了两个问题，其中 <font color="cyan">第二个</font> 问题是：模型的不稳定性。不稳定性主要来源于预测框的(x,y)坐标。在 RPN 中，网络预测 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">t_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> ，因此，框的中心<code>(x,y)</code>计算方式为:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo>∗</mo><msub><mi>w</mi><mi>a</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>x</mi><mi>a</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mi>y</mi></msub><mo>∗</mo><msub><mi>h</mi><mi>a</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>y</mi><mi>a</mi></msub></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex"> \begin{cases} x = (t_x * w_a) + x_a\\    y = (t_y * h_a) + y_a\\   \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>在原论文中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">x_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">y_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 前使用的是减号，估计是作者的笔误。其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">w_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">h_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为 anchor 的宽和长。如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t_x&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，bounding box 会向右移动 anchor 宽的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">t_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 倍，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t_x&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，bounding box 会向左移动 anchor 宽的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">t_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 倍。由公式可以看出，由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">t_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 没有限制（取值范围没有限制），因此最后得到的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 可以落在图像上的任意一个位置，因此一个 anchor 可能检测一个离自己很远的物体，尽管这个物体应该由离其自身近的 anchor 来检测。<br>  Yolo v2 不采用预测 offset 的方法，而是延续 Yolo v1 预测 bbox 相对每个 grid cell 左上角的坐标，确保每个 bbox 的中心落在 grid cell 内。作者使用 logistic 函数来约束预测值。<br>  对网络的输出 feature map (13×13)，Yolo v2 对每一个 grid cell 预测 5 个 bbox (对应 5 个 anchor)，每个 bbox 由 5 维向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>o</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">( t_x,t_y,t_w,t_h,t_o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 表示。因此，对 feature map 上的每一个位置来说，都会预测出一个 5×5 的向量。(要牢记 feature map 上的每一个位置都对应图像上的一个 grid cell )。如果这个 grid cell 的左上角距离图像左上角偏移为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>c</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c_x,c_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，anchor box 的宽高为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>p</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">p_w, p_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么这个预测的 bounding box 的中心点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b_x, b_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，宽高为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>h</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b_w, b_h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。计算方式如下图:</p><p><img src="pic4.png" alt="一个预测框的计算方式"></p> <hr><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(t_x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 是 bounding box 的中心相对栅格左上角的横坐标，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(t_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 是纵坐标。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>o</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(t_o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 是 bounding box 的 confidence score。<br>这样，就可以预测出 5 组 bbox.<br><font color="green">个人理解: </font>由于预测的值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>o</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">( t_x,t_y,t_w,t_h,t_o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 这 5 个数，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>h</mi></msub><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>f</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b_x,b_y,b_w,b_h,confidence)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span> 可以由上面的预测值计算出来，因此不确定最后的 GT 向量是用哪一个来计算 loss。<s>个人猜测是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>h</mi></msub><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>f</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b_x,b_y,b_w,b_h,confidence)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span>。因为这样与 Yolo v1 中的 loss 一致。因此有可能 5 个 GT 都是一样的，就像 Yolo v1 中的一样。</s></p><center><font color="orange">---------------------------  损失计算理解更新  -----------------------------</font></center><p>通过阅读损失部分源码，感觉上面的猜测不正确。应该是使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>o</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">( t_x,t_y,t_w,t_h,t_o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 这 5 个数进行损失计算的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">delta_region_box</span><span class="params">(box truth, <span class="keyword">float</span> *x, <span class="keyword">float</span> *biases, <span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">float</span> *delta, <span class="keyword">float</span> scale, <span class="keyword">int</span> stride)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    box pred = get_region_box(x, biases, n, index, i, j, w, h, stride);</span><br><span class="line">    <span class="keyword">float</span> iou = box_iou(pred, truth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 i,j 是对 cell 的索引，因此 i,j 的范围都是 [0,12] 的整数. w,h 都是 13，delta 存储 loss， x 是预测结果，stride=169.</span></span><br><span class="line">    <span class="comment">// n 是 [0,5] 的整数，是一个确定 cell 内 bbox 的索引。</span></span><br><span class="line">    <span class="keyword">float</span> tx = (truth.x*w - i); <span class="comment">// 这里跟论文中有一点不一样，这里的 tx 其实相当于论文中的$\sigma&#123;t_x&#125;$，这里的 i 就相当于论文中的 cx。ty同理。</span></span><br><span class="line">    <span class="keyword">float</span> ty = (truth.y*h - j);</span><br><span class="line">    <span class="keyword">float</span> tw = <span class="built_in">log</span>(truth.w*w / biases[<span class="number">2</span>*n]); <span class="comment">// biases 数组中存储的是 5 个 anchor 的长宽。</span></span><br><span class="line">    <span class="keyword">float</span> th = <span class="built_in">log</span>(truth.h*h / biases[<span class="number">2</span>*n + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    delta[index + <span class="number">0</span>*stride] = scale * (tx - x[index + <span class="number">0</span>*stride]);</span><br><span class="line">    delta[index + <span class="number">1</span>*stride] = scale * (ty - x[index + <span class="number">1</span>*stride]);</span><br><span class="line">    delta[index + <span class="number">2</span>*stride] = scale * (tw - x[index + <span class="number">2</span>*stride]);</span><br><span class="line">    delta[index + <span class="number">3</span>*stride] = scale * (th - x[index + <span class="number">3</span>*stride]);</span><br><span class="line">    <span class="keyword">return</span> iou;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，计算每一个 bbox 的损失时，是将当前 bbox 所在 cell 对应的 GT box 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,w,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span> 转换成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t_x,t_y,t_w,t_h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 后，再跟网络输出的预测值计算损失的。可以看出，针对同一 cell 内不同的 anchor 对应的预测框（一个 anchor 对应一个预测框），它们的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t_x,t_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 真实值都是相等的，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 是 cell 的索引，所以对某一 cell 内的预测框来说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 都是相等的。但是 n 是 cell 内预测框，或者是 anchor 的索引，因此对每个预测框来说，他们的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t_w,t_h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的真实值是不等的。（这里没有说一个 cell 是否只计算 responsable 的那个 bbox 的损失，需要查看别的地方的代码）</p><p>Yolo v2 论文没有给出损失函数。网上找到的一个损失函数如下，不知正确与否。<br><img src="pic6.png" alt="Yolo v2 损失函数"></p><h2 id="fine-grained-features"><a class="markdownIt-Anchor" href="#fine-grained-features"></a> Fine-Grained Features</h2><p>  上述网络上的修改使 Yolo v2 最终在 13×13 的特征图上进行预测，虽然这足以胜任大尺度物体的检测，但是用上细粒度特征的话，这可能对小尺度的物体检测有帮助。Faster R-CNN 和 SSD 都在不同层次的特征图上产生区域建议（SSD 直接就可看得出来这一点）（Faster R-CNN 有吗？），获得了多尺度的适应性。这里使用了一种不同的方法，简单添加了一个转移层 ( passthrough layer )，这一层要把浅层特征图 （分辨率为 26×26，是底层分辨率4倍）连接到深层特征图（concat）。</p><blockquote><p>补充：关于 passthrough layer，具体来说就是特征重排（不涉及到参数学习），前面 26×26×512 的特征图使用按行和按列隔行采样的方法，就可以得到4个新的特征图，维度都是 13×13×512，然后做 concat 操作，得到 13×13×2048 的特征图，将其拼接到后面的层，相当于做了一次特征融合，有利于检测小目标。</p></blockquote><h2 id="multi-scale-training"><a class="markdownIt-Anchor" href="#multi-scale-training"></a> Multi-Scale Training</h2><p>  为了使网络具有较强的尺寸鲁棒性，即对不同尺寸的输入都有较好的检测效果。Yolo v2 每迭代几个 epoch 后就会随机选择输入图像的尺寸。由于网络下采样率为32，因此尺寸都是32的倍数，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>320</mn><mo separator="true">,</mo><mn>352</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mn>608</mn></mrow><annotation encoding="application/x-tex">{320,352,...,608}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">3</span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">5</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">8</span></span></span></span></span> 中随机选择。这样，网络不得不学着对不同分辨率的图像都要检测得很好。<br><br></p><h1 id="faster"><a class="markdownIt-Anchor" href="#faster"></a> Faster</h1><p>为了速度，避免使用 VGG-16。提出了 Yolo v2 专用网络 Darknet-19。</p><h2 id="darknet-19"><a class="markdownIt-Anchor" href="#darknet-19"></a> Darknet-19</h2><p>特点：</p><ol><li>主要使用 3×3 卷积核</li><li>每次 Pooling 后，通道数翻倍</li><li>在 3×3 卷积之间使用 1×1 进行特征压缩表示</li></ol><p>网络参数如下图所示:<br><img src="pic5.png" alt="网络参数"><br>  在进行检测时，将Darknet-19的全连接去掉，换上3个 3×3 的卷积层，每一个卷积层通道均为 1024，每一个 3×3 卷积后面都要接上一个 1×1 的卷积。最后的输出尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>13</mn><mo>×</mo><mn>13</mn><mo>×</mo><mo stretchy="false">(</mo><mn>5</mn><mo>×</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>20</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>13</mn><mo>×</mo><mn>13</mn><mo>×</mo><mn>125</mn></mrow><annotation encoding="application/x-tex">13×13×(5×(5+20))=13×13×125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span></span></span></span>。在最后一个 3×3×512 层和倒数第二个卷积层之间加上了 passthrough layer.</p><br><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ol><li><a href="https://blog.csdn.net/hrsstudy/article/details/70767950" target="_blank" rel="noopener">https://blog.csdn.net/hrsstudy/article/details/70767950</a></li><li><a href="https://blog.csdn.net/jesse_mx/article/details/53925356" target="_blank" rel="noopener">https://blog.csdn.net/jesse_mx/article/details/53925356</a></li><li><a href="https://github.com/leetenki/YOLOv2/blob/master/YOLOv2.md" target="_blank" rel="noopener">https://github.com/leetenki/YOLOv2/blob/master/YOLOv2.md</a></li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 回归 </tag>
            
            <tag> Yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yolo v1 论文理解</title>
      <link href="/2018/04/19/Yolo/"/>
      <url>/2018/04/19/Yolo/</url>
      
        <content type="html"><![CDATA[<p>本文针对 Yolo v1 的一些处理方法和细节给出了自己的理解。不一定正确，如有错误请指正。</p><a id="more"></a><h1 id="yolo-整体思想"><a class="markdownIt-Anchor" href="#yolo-整体思想"></a> Yolo 整体思想</h1><p>  YOLO 将输入图像分成 <code>SxS</code> 个格子，每个格子负责检测‘落入’该格子的物体。若某个物体的中心位置的坐标落入到某个格子，那么这个格子就负责检测出这个物体。如下图所示，图中物体狗的中心点（红色原点）落入第5行、第2列的格子内，所以这个格子负责预测图像中的物体-狗。<br><img src="pic1.jpg" alt="yolo 检测思想"><br>  </p><p style="color:green">  在计算 loss 时，此格子预测得到的 B 个 bounding box 分别与‘狗’这个物体的 gt box（即图中的红色框）计算 IoU，用 IoU 较大的 bounding box 来计算 localization 损失（称这个 bnd box 负责检测这个物体 --‘狗’），剩下的 bnd box 不参与计算。这边所讨论的是有物体的格子计算损失的方式，没有物体的格子的损失计算与之稍有不同。</p> 具体见损失函数。<p></p><h1 id="yolo输出特征图"><a class="markdownIt-Anchor" href="#yolo输出特征图"></a> Yolo输出特征图</h1><p>  根据论文中的参数，Yolo 网络的输出为 7×7×30，每一个格子对一个一个 30 维的向量。这个 30 维向量的含义如下图所示。<br><img src="pic2.gif" alt="30维向量含义"><br>  如图所示，<code>x,y</code> 分别是预测出的 bnd box 的中心相对于当前格子的边界的坐标值。其被格子的尺寸归一化到了[0,1]。也就是说，<strong>预测出的 bnd box 的中心是在格子内部的</strong>。<code>w,h</code> 是预测出的 bnd box 的长宽，其被图像尺寸归一化到了[0,1]。也就是说，预测出的 bnd box 的尺寸是不大于图像尺寸的任意尺寸。confidence 就是预测出的 bnd box 和 gt box的 IoU 值。</p><h1 id="损失函数"><a class="markdownIt-Anchor" href="#损失函数"></a> 损失函数</h1><p>网络的损失函数定义如下图：<br><img src="pic3.png" alt="网络损失函数"></p><p>从图中可以看出，损失函数主要分为【坐标预测】【confidence】【类别预测】三个部分。是计算出每一个格子的损失并将所有格子的损失加和作为最后的损失值。由于格子主要分为 【有物体】和【无物体】两种，因此对不同类型的格子，损失的计算方式不完全一样。对于有物体的格子，由于每个格子预测了两个bnd box，因此计算这两个 bnd box 和当前格子对应物体的 GT box 的 IoU，用 IoU 值大的 bnd box 来负责这个 GT box 的预测（也就是回归），也就是说，只计算 IoU 较大的 bnd box 的损失，不计算其他 bnd box 的损失。 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>1</mn><mi>i</mi><mrow><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\mathbb{1}^{obj}_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2438799999999999em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span></span> 表示第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个格子中是否有物体出现，若有，则为1，否则为0。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>1</mn><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\mathbb{1}^{obj}_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.379988em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个格子中的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个 bnd box 是否负责当前格子所对应 GT box 的预测。个人理解，当格子中没有物体，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>1</mn><mi>i</mi><mrow><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathbb{1}^{obj}_i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2438799999999999em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，对任何<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>1</mn><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\mathbb{1}^{obj}_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.379988em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span>都为 0。因此，对于没有物体的格子来说，此格子对损失函数的贡献只有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mrow><mi>n</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msub><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><msup><mi>S</mi><mn>2</mn></msup></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>B</mi></munderover><msubsup><mn>1</mn><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mi>n</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup><mo stretchy="false">(</mo><msub><mi>C</mi><mi>i</mi></msub><mo>−</mo><msub><mover accent="true"><mi>C</mi><mo>^</mo></mover><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\lambda_{noobj}\sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{1}^{noobj}_{ij} (C_i-\hat C_i)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.387702em;vertical-align:-1.4137769999999998em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9739250000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.19677em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>这一项，而其他的如分类误差和定位误差都为0。</p><h1 id="ground-truth设定"><a class="markdownIt-Anchor" href="#ground-truth设定"></a> Ground Truth设定</h1><p>Yolo 的网络输出为 7×7×30 的 feature map，为了能够构造损失函数，因此需要一个同样尺寸的 Ground Truth。针对每一个格子，它的 Ground Truth 也为一个 30 维的向量。其中 20 维为这个格子所对应的物体的类别，个人理解为 one hot。剩下10维为两个 bnd box 的 GT ，两个 bnd box 的 GT 值相同，即两个相同的 5 维向量。5 维向量分别为当前格子对应的物体的 <code>w,h,x,y,confidence</code>。对于有物体的格子，<code>w,h,x,y</code> 为格子对应物体的 GT box 的这四项参数，<code>confidence</code> 项为 <code>1</code>。对于没有物体的格子, <code>confidence</code> 项为 <code>0</code>，且在计算损失时，不计算当前格子预测出的两个 bnd box 的定位损失（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>1</mn><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathbb{1}^{obj}_{ij}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.379988em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>）和分类损失（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>1</mn><mi>i</mi><mrow><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathbb{1}^{obj}_{i}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2438799999999999em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>），因此没有物体的格子的 Ground Truth 中的 w,h,x,y 并不重要，因为它们不参与计算。这样，如上节所讲，没有物体的格子对损失函数的贡献只有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mrow><mi>n</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msub><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><msup><mi>S</mi><mn>2</mn></msup></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>B</mi></munderover><msubsup><mn>1</mn><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mi>n</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup><mo stretchy="false">(</mo><msub><mi>C</mi><mi>i</mi></msub><mo>−</mo><msub><mover accent="true"><mi>C</mi><mo>^</mo></mover><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\lambda_{noobj} \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{1}^{noobj}_{ij} (C_i-\hat C_i)^2 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.387702em;vertical-align:-1.4137769999999998em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9739250000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.19677em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>这一项。</p><h1 id="inference流程"><a class="markdownIt-Anchor" href="#inference流程"></a> Inference流程</h1><p>  前面讲到，每一个格子最后会得到一个 30 维的向量，其中 10 维分别为两个 bnd box 预测的 w,h,x,y,confidence 值，20 维为此格子的条件类别概率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mo stretchy="false">(</mo><mi>C</mi><mi>l</mi><mi>a</mi><mi>s</mi><msub><mi>s</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Pr(Class_i|Object)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>。将两个 bnd box 预测的 confidence 分别和这个条件类别概率相乘，则得到两个 20 维的向量，称作 confidence score，它既包含了 bounding box 中预测的 class 的 probability 信息，也反映了 bounding box 是否含有 Object 和 bounding box 坐标的准确度。这样，对每一个格子，都得到两个 20 维的 score 向量。如下图。<br><img src="pic4.gif" alt="score向量"></p><blockquote><p><strong>这里我有一个疑问:</strong> 前面的 score 向量是最后用来比较的标准，即判断每个 bnd box 好坏的标准，但是这里并没有用到 w,h,x,y 四个预测坐标来计算与 GT box 的 IoU。我的解释是：在训练阶段，w,h,x,y 和 confidence 是绑定的，即预测的 bnd box 的 w,h,x,y 向真实值靠近(针对有物体的格子)，confidence 向 1 靠近，因此，当 confidence 较接近 1 时，说明 w,h,x,y 四个值也接近真实值。这样在预测阶段，就不用把 w,h,x,y 拿出来计算，直接拿预测的 confidence 计算，就可以表达 bnd box 是否很好地预测了 GT box 的坐标。</p></blockquote><h2 id="得到score向量后的流程"><a class="markdownIt-Anchor" href="#得到score向量后的流程"></a> 得到score向量后的流程</h2><p>  在得到每个 bnd box 的 score 向量后（论文中共有 2×7×7=98 个），将其看作一个 20×98 的矩阵。其中每一列为每个 bnd box 的 score 向量，每一行为每个 bnd box 对某个类别的预测 score。针对此矩阵，逐行，即逐类别进行操作。</p><ul><li>对某一行（假设第一行，即第一类）的 98 个 score 值进行阈值化，将小于固定阈值的 score 值置零。</li><li>根据此行阈值化后的 score 值的大小，对每个 bnd box 的 score 向量（列与列进行排序，不是列的元素排序）进行降序排序。</li><li>降序排序后，根据此行的 98 个 score 值以及预测出的 98 对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(w,h,x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 进行 NMS，将此行部分 bnd box 的 score 值置零 (见 NMS 的具体方式图)。</li><li>对每一行（即每个类别）重复上述三个步骤，这样就得到一个全新的 20×98 的矩阵，其中有大量 0 元素。</li><li>对新矩阵的每一列（每一个 bnd box），找出其 score 值最大的类别，若其最大 score 值大于 0，则用此类别对应的颜色画出当前 bnd box 预测的框。</li></ul><p>其中，阈值化-降序排序-NMS 流程如下图所示：<br><img src="pic5.gif" alt="阈值化-降序排序-NMS"><br>NMS 的具体方式如下图所示：<br><img src="pic6.gif" alt="NMS 流程"><br>从新矩阵中画出检测框的过程如下图所示：<br><img src="pic7.gif" alt="画检测框"></p><h1 id="yolo-的缺点"><a class="markdownIt-Anchor" href="#yolo-的缺点"></a> Yolo 的缺点</h1><ul><li>localization error 较大，定位不准确</li><li>recall rate 较低 (由于每个格子内只预测 B 个 bnd box，因此当有多个物体的中心落入同一个格子时，Yolo 是无法检出的，因此 Yolo 对成群出现的小物体检测效果很差)</li></ul><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://blog.csdn.net/hrsstudy/article/details/70305791" target="_blank" rel="noopener">https://blog.csdn.net/hrsstudy/article/details/70305791</a><br><a href="https://arxiv.org/abs/1506.02640" target="_blank" rel="noopener">论文原文 https://arxiv.org/abs/1506.02640</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 回归 </tag>
            
            <tag> Yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Node.js 生成随机数的服务</title>
      <link href="/2018/04/16/node-random-number-service/"/>
      <url>/2018/04/16/node-random-number-service/</url>
      
        <content type="html"><![CDATA[<p>使用 Node.js 写一个服务器程序，用来返回一个不大于给定数的随机数。</p><a id="more"></a><p>程序代码为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// these modules need to be imported in order to use them.</span></span><br><span class="line"><span class="comment">// Node has several modules.  They are like any #include</span></span><br><span class="line"><span class="comment">// or import statement in other languages</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The most important line in any Node file.  This function</span></span><br><span class="line"><span class="comment">// does the actual process of creating the server.  Technically,</span></span><br><span class="line"><span class="comment">// Node tells the underlying operating system that whenever a</span></span><br><span class="line"><span class="comment">// connection is made, this particular callback function should be</span></span><br><span class="line"><span class="comment">// executed.  Since we're creating a web service with REST API,</span></span><br><span class="line"><span class="comment">// we want an HTTP server, which requires the http variable</span></span><br><span class="line"><span class="comment">// we created in the lines above.</span></span><br><span class="line"><span class="comment">// Finally, you can see that the callback method receives a 'request'</span></span><br><span class="line"><span class="comment">// and 'response' object automatically.  This should be familiar</span></span><br><span class="line"><span class="comment">// to any PHP or Java programmer.</span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The response needs to handle all the headers, and the return codes</span></span><br><span class="line">   <span class="comment">// These types of things are handled automatically in server programs</span></span><br><span class="line">   <span class="comment">// like Apache and Tomcat, but Node requires everything to be done yourself</span></span><br><span class="line">   response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Here is some unique-looking code.  This is how Node retrives</span></span><br><span class="line">   <span class="comment">// parameters passed in from client requests.  The url module</span></span><br><span class="line">   <span class="comment">// handles all these functions.  The parse function</span></span><br><span class="line">   <span class="comment">// deconstructs the URL, and places the query key-values in the</span></span><br><span class="line">   <span class="comment">// query object.  We can find the value for the "number" key</span></span><br><span class="line">   <span class="comment">// by referencing it directly - the beauty of JavaScript.</span></span><br><span class="line">   <span class="keyword">var</span> params = url.parse(request.url, <span class="literal">true</span>).query;</span><br><span class="line">   <span class="keyword">var</span> input = params.number;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// These are the generic JavaScript methods that will create</span></span><br><span class="line">   <span class="comment">// our random number that gets passed back to the caller</span></span><br><span class="line">   <span class="keyword">var</span> numInput = <span class="keyword">new</span> <span class="built_in">Number</span>(input);</span><br><span class="line">   <span class="keyword">var</span> numOutput = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="built_in">Math</span>.random() * numInput).toFixed(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Write the random number to response</span></span><br><span class="line">   response.write(numOutput);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Node requires us to explicitly end this connection.  This is because</span></span><br><span class="line">   <span class="comment">// Node allows you to keep a connection open and pass data back and forth,</span></span><br><span class="line">   <span class="comment">// though that advanced topic isn't discussed in this article.</span></span><br><span class="line">   response.end();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// When we create the server, we have to explicitly connect the HTTP server to</span></span><br><span class="line"> <span class="comment">// a port.  Standard HTTP port is 80, so we'll connect it to that one.</span></span><br><span class="line">&#125;).listen(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output a String to the console once the server starts up, letting us know everything</span></span><br><span class="line"><span class="comment">// starts up correctly</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Random Number Generator Running..."</span>);</span><br></pre></td></tr></table></figure><p>在命令行执行此js脚本</p><figure class="highlight plain"><figcaption><span>lang:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node xxx.js</span><br></pre></td></tr></table></figure><p>然后，在客户端，在地址栏输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:80?number=46</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何截取网页长屏</title>
      <link href="/2018/04/16/Webpage2Picture/"/>
      <url>/2018/04/16/Webpage2Picture/</url>
      
        <content type="html"><![CDATA[<p>本文主要展示如何通过使用 nodejs 进行网页截屏，并截取整个网页。</p><a id="more"></a><p> <br>js 部分代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> page = <span class="built_in">require</span>(<span class="string">'webpage'</span>).create();</span><br><span class="line">page.open(<span class="string">'http://www.guancha.cn/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"status:"</span> + status);</span><br><span class="line">  <span class="keyword">if</span> (status == <span class="string">"success"</span>) &#123;</span><br><span class="line">    page.render(<span class="string">"example.png"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  phantom.exit();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> <br>这对一般的网站来说能得到很好的效果。但是存在一个问题，当截取如优酷等视频网站时，由于网页加载时间较长，因此容易在网页还蛮完全渲染完全时进行截图，造成图中部分图片缺失。</p><img src="/2018/04/16/Webpage2Picture/failed.png" title="failed"><a href="https://www.v2ex.com/t/67689" target="_blank" rel="noopener">这篇文章</a>也遇到了同样的问题，并给出了解决方案。<p> <br>我尝试了使用sleep方式解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> t = <span class="built_in">Date</span>.now(); <span class="built_in">Date</span>.now() - t &lt;= d; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start_time = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="keyword">var</span> page = <span class="built_in">require</span>(<span class="string">'webpage'</span>).create();</span><br><span class="line"></span><br><span class="line">page.open(<span class="string">'http://www.youku.com/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"status:"</span> + status);</span><br><span class="line">  <span class="keyword">if</span> (status == <span class="string">"success"</span>) &#123;</span><br><span class="line">    sleep(<span class="number">10000</span>);</span><br><span class="line">    page.render(<span class="string">"example.png"</span>);</span><br><span class="line">    <span class="keyword">var</span> end_time = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">var</span> used_time = (end_time - start_time) / <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Used time is: "</span> + used_time + <span class="string">' s'</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  phantom.exit();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是效果并不好。</p><p> <br>因此，又尝试了获取页面 img 元素的方式，判断某个图片是否加载完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> stat = page.evaluate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> laifeng = <span class="built_in">document</span>.getElementById(<span class="string">"m_250037"</span>);</span><br><span class="line">    <span class="keyword">var</span> pict = laifeng.getElementsByTagName(<span class="string">"img"</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> pict.complete;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'complete---'</span> + stat);</span><br><span class="line">  <span class="keyword">return</span> stat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitForReady</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!check()) &#123;</span><br><span class="line">    setTimeout(waitForReady(), <span class="number">10</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'element showed'</span>);</span><br><span class="line">    page.render(<span class="string">"example.png"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> page = <span class="built_in">require</span>(<span class="string">'webpage'</span>).create();</span><br><span class="line">page.open(<span class="string">'http://www.youku.com/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"status:"</span> + status);</span><br><span class="line">  <span class="keyword">if</span> (status == <span class="string">"success"</span>) &#123;</span><br><span class="line">    waitForReady();</span><br><span class="line">  &#125;</span><br><span class="line">  phantom.exit();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是并没有达到想要的效果，虽然能够获取到元素的完成状态，但实际上截图时图片并没有显示出来。</p><img src="/2018/04/16/Webpage2Picture/example.png" title="bad result"><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 网页 </tag>
            
            <tag> 截屏 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
