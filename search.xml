<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【转载】矩阵之芯 SVD：奇异值分解及其几何解释</title>
      <link href="/2021/04/19/SVD/"/>
      <url>/2021/04/19/SVD/</url>
      
        <content type="html"><![CDATA[<p>在网上看到一篇非常好的关于 SVD 的文章，转载在这里。并附上自己的理解。</p><a id="more"></a><p>原文来源: <a href="https://my.oschina.net/mathinside/blog/4760837" target="_blank" rel="noopener"><font color="purple">矩阵之芯 SVD: 奇异值分解及其几何解释</font></a></p><p><img src="svd1.jpeg" alt="svd"></p><p><img src="svd2.jpeg" alt="svd"></p><p><img src="svd3.jpeg" alt="svd"></p><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><p><a href="https://www.cnblogs.com/qizhou/p/13864589.html" target="_blank" rel="noopener">实对称矩阵的特征值一定为实数证明</a></p><p><a href="https://my.oschina.net/JiamingMai/blog/366093" target="_blank" rel="noopener">证明：实对称矩阵中，属于不同特征值的特征向量相互正交</a><br>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">p</mi></mrow><mo>=</mo><msub><mi>λ</mi><mn>1</mn></msub><mi mathvariant="bold-italic">p</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{Ap}=\lambda_1\boldsymbol{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8805499999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol">p</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">q</mi></mrow><mo>=</mo><msub><mi>λ</mi><mn>2</mn></msub><mi mathvariant="bold-italic">q</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{Aq}=\lambda_2\boldsymbol{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8805499999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">A</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span></span></span></span> 为实对称矩阵，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\lambda_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\lambda_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">A</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span></span></span></span> 的不同的特征值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">p</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">q</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span></span></span> 分别是对应的特征向量。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mo stretchy="false">(</mo><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">q</mi></mrow><mo stretchy="false">)</mo><mo>=</mo><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>2</mn></msub><mi mathvariant="bold-italic">q</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>λ</mi><mn>2</mn></msub><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">q</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\boldsymbol{p}^T(\boldsymbol{Aq})=\boldsymbol{p}^T(\lambda_2\boldsymbol{q})=\lambda_2\boldsymbol{p}^T\boldsymbol{q}  \tag{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0857709999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span><span class="tag"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi><mo stretchy="false">)</mo><mi mathvariant="bold-italic">q</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><msup><mi mathvariant="bold-italic">A</mi><mi>T</mi></msup><mo stretchy="false">)</mo><mi mathvariant="bold-italic">q</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>1</mn></msub><mi mathvariant="bold-italic">p</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mi mathvariant="bold-italic">q</mi><mo>=</mo><msub><mi>λ</mi><mn>1</mn></msub><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">q</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(2)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">(\boldsymbol{p}^T\boldsymbol{A})\boldsymbol{q}=(\boldsymbol{p}^T\boldsymbol{A}^T)\boldsymbol{q}=(\lambda_1\boldsymbol{p})^T\boldsymbol{q} =\lambda_1\boldsymbol{p}^T\boldsymbol{q} \tag{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.167341em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.917341em;"><span style="top:-3.1390100000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0857709999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span><span class="tag"><span class="strut" style="height:1.167341em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p><p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mo stretchy="false">(</mo><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">q</mi></mrow><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi><mo stretchy="false">)</mo><mi mathvariant="bold-italic">q</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{p}^T(\boldsymbol{Aq})=(\boldsymbol{p}^T\boldsymbol{A})\boldsymbol{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span></span></span>, 由 (1)-(2)得：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mo stretchy="false">(</mo><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">q</mi></mrow><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi><mo stretchy="false">)</mo><mi mathvariant="bold-italic">q</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>1</mn></msub><mo>−</mo><msub><mi>λ</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mrow><msup><mi mathvariant="bold-italic">p</mi><mi mathvariant="bold-italic">T</mi></msup><mi mathvariant="bold-italic">q</mi></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{p}^T(\boldsymbol{Aq})-(\boldsymbol{p}^T\boldsymbol{A})\boldsymbol{q}=(\lambda_1-\lambda_2)\boldsymbol{p^Tq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1432769999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8932769999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight" style="margin-right:0.15972em;">T</span></span></span></span></span></span></span></span><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span></span></span></span></p><p>即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>=</mo><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>1</mn></msub><mo>−</mo><msub><mi>λ</mi><mn>2</mn></msub><mo stretchy="false">)</mo><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">q</mi></mrow><annotation encoding="application/x-tex">0=(\lambda_1-\lambda_2)\boldsymbol{p}^T\boldsymbol{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span></span></span><br>又由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mn>1</mn></msub><mi mathvariant="normal">≠</mi><msub><mi>λ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\lambda_1\neq\lambda_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">q</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\boldsymbol{p}^T\boldsymbol{q}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi mathvariant="bold-italic">p</mi><mo separator="true">,</mo><mi mathvariant="bold-italic">q</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&lt;\boldsymbol{p}, \boldsymbol{q}&gt;=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 从而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">p</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">q</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span></span></span> 相互正交。</p><p><a href="https://blog.csdn.net/itnerd/article/details/83032543" target="_blank" rel="noopener">所有特征值大于零的矩阵一定是正定阵吗？</a></p><p><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="bold-italic">A</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{A}^T\boldsymbol{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.917341em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.917341em;"><span style="top:-3.1390100000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span></span></span></span>  是对称且非负定的。</strong><br>证明：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="bold-italic">A</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mo>=</mo><msup><mi mathvariant="bold-italic">A</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi></mrow><annotation encoding="application/x-tex">(\boldsymbol{A}^T\boldsymbol{A})^T=\boldsymbol{A}^T\boldsymbol{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.167341em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.917341em;"><span style="top:-3.1390100000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.917341em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.917341em;"><span style="top:-3.1390100000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span></span></span></span>, 因此对称。<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="bold-italic">x</mi><mi>T</mi></msup><mo stretchy="false">(</mo><msup><mi mathvariant="bold-italic">A</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi><mo stretchy="false">)</mo><mi mathvariant="bold-italic">x</mi><mo>=</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">x</mi></mrow><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">x</mi></mrow><mo>=</mo><mi mathvariant="normal">∥</mi><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">x</mi></mrow><mi mathvariant="normal">∥</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\boldsymbol{x}^T(\boldsymbol{A}^T\boldsymbol{A})\boldsymbol{x}=(\boldsymbol{Ax})^T\boldsymbol{Ax}=\Vert \boldsymbol{Ax} \Vert &gt;= 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.167341em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.917341em;"><span style="top:-3.1390100000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol">x</span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol">x</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol">x</span></span></span><span class="mord">∥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br><a href="https://www.3rxing.org/question/3b7705af11769615154.html" target="_blank" rel="noopener">矩阵乘矩阵的转置一定正定吗</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 矩阵分解 </tag>
            
            <tag> 奇异矩阵 </tag>
            
            <tag> 特征值 </tag>
            
            <tag> 特征向量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多元高斯分布推导及二维高斯分布的图像</title>
      <link href="/2021/04/15/Gaussian-Distribution/"/>
      <url>/2021/04/15/Gaussian-Distribution/</url>
      
        <content type="html"><![CDATA[<p>本文主要转载了关于多元高斯分布概率密度函数的推导过程，并画出了二维高斯分布的图像，以便得到更直观的理解。</p><a id="more"></a><p>在知乎上看到两篇文章，分别是<br><a href="https://zhuanlan.zhihu.com/p/58987388" target="_blank" rel="noopener"><font color="blue">多元高斯分布完全解析</font></a>, 记为 <strong>文章一</strong> ,    <a href="https://zhuanlan.zhihu.com/p/36522776" target="_blank" rel="noopener"><font color="blue">从零开始推导多元高斯分布</font></a>，记为 <strong>文章二</strong></p><h2 id="font-colorpurple文章一的流程大致为font"><a class="markdownIt-Anchor" href="#font-colorpurple文章一的流程大致为font"></a> <font color="purple"><strong>文章一的流程大致为</strong></font></h2><ul><li><p>给出一维高斯分布及其概率密度函数, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mi>μ</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \mathcal{N}(\mu, \sigma^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p></li><li><p>对随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 进行标准化，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac></mrow><annotation encoding="application/x-tex">Z=\frac{X-\mu}{\sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.269439em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.924439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 进行换元，得到的随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> 服从一元标准高斯分布，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z \sim \mathcal{N}(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><blockquote><p><strong>随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 标准化的过程, 实际上的消除量纲影响和分布差异的过程. 通过将随机变量的值减去其均值再除以标准差, 使得随机变量与其均值的差距可以用若干个标准差来衡量, 从而实现了不同随机变量与其对应均值的差距, 可以以一种相对的距离来进行比较.</strong></p></blockquote></li><li><p>将一元高斯分布和多元高斯分布联系起来。如果随机<strong>向量</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">[</mo><msub><mi>Z</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>Z</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\vec{Z}=[Z_1,\cdots, Z_n]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 中每个随机<strong>变量</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 都服从标准高斯分布且两两彼此独立，则随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">[</mo><msub><mi>Z</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>Z</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\vec{Z}=[Z_1,\cdots, Z_n]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 的联合概率密度函数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>z</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>⋯</mo><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(z_1,\cdots,z_n) = p(z_1)\cdots p(z_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，称之为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mn>0</mn><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="bold-italic">I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z} \sim \mathcal{N}(\vec{0}, \boldsymbol{I})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.17744em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.92744em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.21344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="mclose">)</span></span></span></span>. 即随机向量服从均值为零向量, 协方差矩阵为单位矩阵的高斯分布。</p></li><li><p>对于普通的随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{X} \sim \mathcal{N}(\vec{\mu}, \Sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mclose">)</span></span></span></span> , 即其每个随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><msub><mi>μ</mi><mi>i</mi></msub><mo separator="true">,</mo><msubsup><mi>σ</mi><mi>i</mi><mn>2</mn></msubsup><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_i \sim \mathcal{N}(\mu_i, \sigma^2_i)(i=1,\cdots,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.072772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_i,X_j(i,j=1,\cdots,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 彼此不独立的情况下 <strong>我们通过线性变换, 使得随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\vec{X}=[X_1,\cdots,X_n]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 中的每个随机变量彼此独立, 则我们也可以通过独立随机变量概率密度函数之间的关系求出其联合概率密度函数</strong></p></li><li><p>引入<strong>定理 1</strong>，将随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{X} \sim \mathcal{N}(\vec{\mu}, \Sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mclose">)</span></span></span></span> 变换为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mn>0</mn><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="bold-italic">I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z} \sim \mathcal{N}(\vec{0}, \boldsymbol{I})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.17744em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.92744em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.21344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="mclose">)</span></span></span></span>. 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><msup><mi>B</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z}=B^{-1}(\vec{X}-\vec{\mu})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.21633em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. 经过推导，得到最终的联合概率密度函数</p></li></ul><p><img src="therom.png" alt="定理1"></p><p><img src="eq0.svg" alt="联合概率密度函数"></p><h2 id="font-colorpurple文章二的流程大致为font"><a class="markdownIt-Anchor" href="#font-colorpurple文章二的流程大致为font"></a> <font color="purple"><strong>文章二的流程大致为</strong></font></h2><ul><li>给出一元标准高斯分布</li><li>给出均值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>，方差为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sigma^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 情况下，使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac></mrow><annotation encoding="application/x-tex">z=\frac{x-\mu}{\sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.199439em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 进行标准化。<strong>标准化的意义在于将数据点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 到均值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span> 的距离转化为数据点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 到均值的距离等于多少个总体的标准差 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span> ，这样，就消除了数据分布差异和量纲对概率计算的影响</strong>，此时的概率密度函数为：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>σ</mi><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><msup><mi>z</mi><mn>2</mn></msup><mn>2</mn></mfrac></mrow></msup><mo>=</mo><mfrac><mn>1</mn><mrow><mi>σ</mi><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">f(x)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{z^2}{2}}=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25144em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.20602em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1328857142857145em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.04844em;"><span style="top:-3.04844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25909em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.32909em;"><span style="top:-3.4534200000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.250957142857143em;"><span style="top:-2.5061857142857145em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9384399999999999em;"><span style="top:-2.93844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.5020714285714285em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.04844em;"><span style="top:-3.04844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49381428571428565em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>可见，<strong>高斯分布的概率密度计算核心在于计算数据点到中心的距离，并且除以标准差将这个绝对距离转化为相对距离，然后通过距离平方的指数衰减计算概率密度。</strong></p><ul><li>介绍各维度<strong>不相关</strong>的多元正态分布的概率密度函数的推导。</li><li>对各维度<strong>相关</strong>的多元正态分布，记为随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>，先将数据通过投影到正交单位向量上，进行去相关，投影过程用矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> 表示。（其实也可以理解为旋转，通过旋转，将随机向量的每个维度变得不相关）。记投影或旋转后的得到的随机向量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>。这时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 虽然已经去相关，但是还没有进行标准化，因此，对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 进行标准化，以得到随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span>。三者之间的关系如下</li><li></li></ul><p><img src="eq1.svg" alt="随机向量 X,Y,Z 之间的关系"></p><p>从公式可以看出，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> 是由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 减去均值后的向量，先通过矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>U</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">U^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 进行投影/旋转变换，去除相关性，然后通过矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 进行缩放变换得到的。</p><h2 id="font-colorpurple总结font"><a class="markdownIt-Anchor" href="#font-colorpurple总结font"></a> <font color="purple"><strong>总结</strong></font></h2><p>在文章一中，根据定理一得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><msup><mi>B</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z}=B^{-1}(\vec{X}-\vec{\mu})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.21633em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其具体操作了<br><img src="eq2.svg" alt="具体操作"></p><p>文章二中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mi>D</mi><msup><mi>U</mi><mi>T</mi></msup><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><msub><mi>μ</mi><mi>X</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z=DU^T(X-\mu_X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 为缩放矩阵，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>U</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">U^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 为旋转/投影矩阵</p><p>可以看出，<strong>文章一中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>B</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">B^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 等价于文章二中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><msup><mi>U</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">DU^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></strong></p><p>在文章一中，存在一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 空间和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> 空间的比例变化，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>z</mi><mn>1</mn></msub><mo>⋯</mo><mi>d</mi><msub><mi>z</mi><mi>n</mi></msub><mo>=</mo><msup><mrow><mo fence="true">∣</mo><mi>B</mi><msup><mi>B</mi><mi>T</mi></msup><mo fence="true">∣</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mi>d</mi><msub><mi>x</mi><mi>i</mi></msub><mo>⋯</mo><mi>d</mi><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">dz_1\cdots dz_n=\left|BB^T\right|^{-\frac{1}{2}}dx_i\cdots dx_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.55592em;vertical-align:-0.35000999999999993em;"></span><span class="minner"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.86199em;"><span style="top:-2.2559899999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86199em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000999999999993em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.86199em;"><span style="top:-2.2559899999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86199em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000999999999993em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.20591em;"><span style="top:-3.6148900000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (<strong><a href="https://my.oschina.net/mathinside/blog/4702928" target="_blank" rel="noopener">雅可比行列式</a>，目前还没搞懂，需要了解一下</strong>), 而又因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><msup><mi>B</mi><mi>T</mi></msup><mo>=</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">BB^T=\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>，因此最后的联合概率密度函数有一项为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><msup><mrow><mo fence="true">∣</mo><mi mathvariant="normal">Σ</mi><mo fence="true">∣</mo></mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\left|\Sigma\right|^{\frac{1}{2}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.687253em;vertical-align:-0.8421449999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.332855em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span><span class="mord mtight">Σ</span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.224492857142857em;"><span style="top:-3.48775em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size1 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03144em;"><span style="top:-2.468em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.387em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.532em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size1 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8421449999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。具体推导见文章一公式(9)-(14)</p><p>可以发现，两篇文章都是通过将随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \mathcal{N}(\vec{\mu}, \Sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mclose">)</span></span></span></span> 变换到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mn>0</mn><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="bold-italic">I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z \sim \mathcal{N}(\vec{0}, \boldsymbol{I})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.17744em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.92744em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.21344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="mclose">)</span></span></span></span> 来求随机变量的联合概率分布的。不同的是，文章一直接通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>B</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">B^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 来表示这种变换，而文章二中则通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>U</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">U^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 两个变换以及引入中间随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 来达到同样的效果。</p><p>在文章一中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mi>B</mi><msup><mi>B</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\Sigma=BB^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>, 且由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> 是实对称矩阵，因此可以正交对角化, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mi>Q</mi><mi mathvariant="normal">Λ</mi><msup><mi>Q</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\Sigma=Q \Lambda Q^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord">Λ</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>。根据定理1，我们有</p><p><img src="eq3.svg" alt="Z^T·Z推导(用B表示)"></p><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mi>Q</mi><mi mathvariant="normal">Λ</mi><msup><mi>Q</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\Sigma=Q \Lambda Q^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord">Λ</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 代入，得到</p><p><img src="eq4.svg" alt="推导(用Q表示)"></p><p><strong>问：这里为什么要计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mi>T</mi></msup><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{Z}^T\vec{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 呢？</strong><br>答：这是因为，由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 变换得到的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mn>0</mn><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="bold-italic">I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z} \sim \mathcal{N}(\vec{0},\boldsymbol{I})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.17744em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.92744em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.21344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="mclose">)</span></span></span></span>，因此，随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> 的联合概率密度函数为</p><p><img src="eq5.svg" alt="Z的联合概率密度函数"></p><p>其中，指数函数的指数部分就是用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mi>T</mi></msup><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{Z}^T\vec{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 来表示的。我们通过推导，得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mi>T</mi></msup><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">(</mo><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><msup><mo stretchy="false">)</mo><mi>T</mi></msup><msup><mi mathvariant="normal">Σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z}^T\vec{Z} = (\vec{X}-\vec{\mu})^T\Sigma^{-1}(\vec{X}-\vec{\mu})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.21633em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.21633em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。可以将其代入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>z</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(z_1,\cdots,z_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 中。又因为  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>z</mi><mn>1</mn></msub><mo>⋯</mo><mi>d</mi><msub><mi>z</mi><mi>n</mi></msub><mo>=</mo><msup><mrow><mo fence="true">∣</mo><mi>B</mi><msup><mi>B</mi><mi>T</mi></msup><mo fence="true">∣</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mi>d</mi><msub><mi>x</mi><mi>i</mi></msub><mo>⋯</mo><mi>d</mi><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">dz_1\cdots dz_n=\left|BB^T\right|^{-\frac{1}{2}}dx_i\cdots dx_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.55592em;vertical-align:-0.35000999999999993em;"></span><span class="minner"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.86199em;"><span style="top:-2.2559899999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86199em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000999999999993em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.86199em;"><span style="top:-2.2559899999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86199em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000999999999993em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.20591em;"><span style="top:-3.6148900000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (<strong>雅可比行列式</strong>) 关系，所以要在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>z</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(z_1,\cdots,z_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 上再乘上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mo fence="true">∣</mo><mi>B</mi><msup><mi>B</mi><mi>T</mi></msup><mo fence="true">∣</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">\left|BB^T\right|^{-\frac{1}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.55592em;vertical-align:-0.35000999999999993em;"></span><span class="minner"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.86199em;"><span style="top:-2.2559899999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86199em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000999999999993em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.86199em;"><span style="top:-2.2559899999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86199em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000999999999993em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.20591em;"><span style="top:-3.6148900000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mo fence="true">∣</mo><mi mathvariant="normal">Σ</mi><mo fence="true">∣</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">\left|\Sigma\right|^{-\frac{1}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.34392em;vertical-align:-0.25em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord">Σ</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.09392em;"><span style="top:-3.5029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>。这样也就得到了最后的概率密度函数。</p><p><font color="orange"><strong>个人理解：</strong></font><br>我个人比较倾向于文章一的推导流程。根据我自己的理解，我总结了完整的推导流程：</p><ul><li>给出一元标准高斯分布的概率密度函数，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">Z</mi><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{Z} \sim \mathcal{N}(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07944em;">Z</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 即</li></ul><p><img src="eq6.svg" alt="一元标准高斯分布的概率密度函数"></p><ul><li>根据标准高斯分布的概率密度函数，很容易得到内部每个随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 都服从标准高斯分布且两两彼此独立的随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">[</mo><msub><mi>Z</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>Z</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\vec{Z}=[Z_1,\cdots, Z_n]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 的概率密度函数。即</li></ul><p><img src="eq7.svg" alt="多元标准高斯分布"></p><ul><li><p>当面对普通的随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{X} \sim \mathcal{N}(\vec{\mu}, \Sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mclose">)</span></span></span></span> 时，即其每个随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><msub><mi>μ</mi><mi>i</mi></msub><mo separator="true">,</mo><msubsup><mi>σ</mi><mi>i</mi><mn>2</mn></msubsup><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_i \sim \mathcal{N}(\mu_i, \sigma_i^2) (i = 1, \cdots, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.072772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_i, X_j(i, j = 1, \cdots, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 彼此不独立的情况下, 我们该如何求随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 的联合概率密度函数呢?</p><blockquote><p>一个很自然的想法是, 如果我们能<strong>通过线性变换, 使得随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">\vec{X} = [X_1, \cdots, X_n]^\top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span> 中的每个随机变量彼此独立, 则我们也可以通过独立随机变量概率密度函数之间的关系求出其联合概率密度函数。</strong><br><strong>Note</strong>: 文章一说的是通过变换使得每个随机变量彼此独立，我觉得可以更进一步，通过变换使得每个随机变量彼此独立，并服从标准正态分布。文章一也正是这么做的。</p></blockquote></li><li><p>通过线性变换公式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><msup><mi>B</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z}=B^{-1}(\vec{X}-\vec{\mu})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.21633em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 替换掉联合概率密度函数中指数部分的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>Z</mi><mi>T</mi></msup><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z^TZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span>。这样，联合概率密度函数就变成了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的函数。</p></li><li><p>再通过积分的换元，得出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>z</mi><mn>1</mn></msub><mo>⋯</mo><mi>d</mi><msub><mi>z</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">dz_1\cdots dz_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>x</mi><mn>1</mn></msub><mo>⋯</mo><mi>d</mi><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">dx_1\cdots dx_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之间的关系，体现在联合概率密度函数的系数部分。</p></li><li><p>接着，通过推导得到的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><msup><mi>B</mi><mi>T</mi></msup><mo>=</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">BB^T=\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>, 将联合概率密度函数里的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 进行替换，则最后得到的概率密度函数与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 无关。因此，我们无需显式地求出变换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，就可以得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 的联合概率密度。</p></li></ul><h2 id="font-colorpurple二维高斯分布图像font"><a class="markdownIt-Anchor" href="#font-colorpurple二维高斯分布图像font"></a> <font color="purple"><strong>二维高斯分布图像</strong></font></h2><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1.5</mn><mo separator="true">;</mo><mn>1.5</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mu=(0,0), \Sigma=[1, 1.5; 1.5, 4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span></p><p><img src="Gaussian_1_1.5_1.5_4.svg" alt="二维高斯分布1"></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1.5</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">;</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mu=(1,1.5), \Sigma=[3, 0; 0, 3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span></p><p><img src="Gaussian_3_0_0_3.svg" alt="二维高斯分布2"></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>0.8</mn><mo separator="true">;</mo><mo>−</mo><mn>0.8</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mu=(0,0), \Sigma=[1, -0.8; -0.8, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><p><img src="Gaussian_1_-0.8_1_-0.8.svg" alt="二维高斯分布3"></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Gaussian </tag>
            
            <tag> Distribution </tag>
            
            <tag> 高斯分布 </tag>
            
            <tag> 正态分布 </tag>
            
            <tag> 概率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoU variants</title>
      <link href="/2021/03/30/IoU-variants/"/>
      <url>/2021/03/30/IoU-variants/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>激活函数详解</title>
      <link href="/2021/03/30/Activation-functions/"/>
      <url>/2021/03/30/Activation-functions/</url>
      
        <content type="html"><![CDATA[<p>本文主要总结了深度学习中出现的各种激活函数，从公式，函数曲线和导数函数曲线等角度进行了总结。</p><a id="more"></a><p>激活函数可分为 <strong>饱和激活函数</strong> 和 <strong>非饱和激活函数</strong> 两种。</p><p>饱和激活函数主要有 Sigmoid, tanh 等，饱和激活函数主要有 ReLU, Leaky ReLU, SELU, Swish, Mish, Maxout 等。</p><h2 id="饱和激活函数"><a class="markdownIt-Anchor" href="#饱和激活函数"></a> 饱和激活函数</h2><h3 id="sigmoid-函数"><a class="markdownIt-Anchor" href="#sigmoid-函数"></a> Sigmoid 函数</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac><mo>=</mo><mfrac><msup><mi>e</mi><mi>x</mi></msup><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">S(x) = \frac{1}{1+e^{-x}} = \frac{e^x}{e^x+1} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.110722em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.341392em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S&#x27;(x) = S(x)(1-S(x)) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><img src="sigmoid.png" alt="Sigmoid 函数曲线"></p><p><img src="g-sigmoid.png" alt="Sigmoid 梯度函数曲线"></p><p>Sigmoid 函数的三个主要缺陷：</p><ol><li><p>梯度消失：注意：Sigmoid 函数趋近 0 和 1 的时候变化率会变得平坦，也就是说，Sigmoid 的梯度趋近于 0。神经网络使用 Sigmoid 激活函数进行反向传播时，输出接近 0 或 1 的神经元其梯度趋近于 0。这些神经元叫作饱和神经元。因此，这些神经元的权重不会更新。此外，与此类神经元相连的神经元的权重也更新得很慢。该问题叫作梯度消失。因此，想象一下，如果一个大型神经网络包含 Sigmoid 神经元，而其中很多个都处于饱和状态，那么该网络无法执行反向传播。</p></li><li><p>不以零为中心：Sigmoid 输出不以零为中心的。</p></li><li><p>计算成本高昂：exp() 函数与其他非线性激活函数相比，计算成本高昂。</p></li></ol><p>下一个要讨论的非线性激活函数解决了 Sigmoid 函数中值域期望不为 0 的问题。</p><h3 id="tanh-函数"><a class="markdownIt-Anchor" href="#tanh-函数"></a> Tanh 函数</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac><mo>=</mo><mfrac><mn>2</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>x</mi></mrow></msup></mrow></mfrac><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">tanh(x) = \frac{e^x-e^{-x}}{e^x+e^{-x}} = \frac{2}{1+e^{-2x}}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.217661em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.448331em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><msup><mi>h</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">tanh&#x27;(x) = \frac{e^x+e^{-x}}{e^x-e^{-x}} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.217661em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.448331em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src="tanh.png" alt="tanh 函数曲线及其梯度函数曲线"></p><p>Tanh 激活函数又叫作双曲正切激活函数（hyperbolic tangent activation function）。与 Sigmoid 函数类似，Tanh 函数也使用真值，但 Tanh 函数将其压缩至 <code>-1</code> 到 <code>1</code> 的区间内。与 Sigmoid 不同，Tanh 函数的输出以零为中心，因为区间在 <code>-1</code> 到 <code>1</code> 之间。<code>可以把 tanh 函数看做是 sigmoid 向下平移和拉伸后的结果。</code> 在实践中，Tanh 函数的使用优先性高于 Sigmoid 函数。负数输入被当作负值，零输入值的映射接近零，正数输入被当作正值。<br>唯一的缺点是：</p><ol><li>Tanh 函数也会有梯度消失的问题，因此在饱和时也会「杀死」梯度。</li></ol><h3 id="hard-sigmoid-函数"><a class="markdownIt-Anchor" href="#hard-sigmoid-函数"></a> Hard-Sigmoid 函数</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>a</mi><mi>r</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>g</mi><mi>m</mi><mi>o</mi><mi>i</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mfrac><mrow><mn>2</mn><mi>x</mi><mo>+</mo><mn>5</mn></mrow><mn>10</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mi>f</mi><mtext> </mtext><mi>x</mi><mo>&lt;</mo><mo>−</mo><mn>2.5</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mn>0.2</mn><mo>∗</mo><mi>x</mi><mo>+</mo><mn>0.5</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mi>f</mi><mtext> </mtext><mo>−</mo><mn>2.5</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>2.5</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mi>f</mi><mtext> </mtext><mi>x</mi><mo>&gt;</mo><mn>2.5</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> hard\_sigmoid(x)=max(0,min(1, \frac{2x+5}{10}))=\left\{\begin{aligned}0 &amp; &amp; if \  x &lt;-2.5 \\0.2*x+0.5 &amp; &amp; if \  -2.5\leq x\leq 2.5 \\1 &amp; &amp; if \  x&gt;2.5\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-1.4999999999999991em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src="hardsigmoid.png" alt="Sigmoid 函数和 hard-Sigmoid 函数对比图"></p><p><img src="g-hardsigmoid.png" alt="Sigmoid 梯度函数和 hard-Sigmoid 梯度函数对比图"></p><p>Hard-Sigmoid 函数是 Sigmoid 激活函数的分段线性近似。从公式和曲线上来看，其更易计算，因此会提高训练的效率，不过同时会导致一个问题：就是首次派生值为零可能会导致神经元 died 或者过慢的学习率。</p><h2 id="非饱和激活函数"><a class="markdownIt-Anchor" href="#非饱和激活函数"></a> 非饱和激活函数</h2><h3 id="relu-修正线性单元"><a class="markdownIt-Anchor" href="#relu-修正线性单元"></a> ReLU （修正线性单元）</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)=max(0,x) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p><p><img src="relu.png" alt="ReLU 函数曲线"></p><p><img src="g-relu.png" alt="ReLU 梯度函数曲线"></p><p>该激活函数使网络更快速地收敛。它不会饱和，即它可以对抗梯度消失问题，至少在正区域（<code>x&gt;0</code> 时）可以这样，因此神经元至少在一半区域中不会把所有零进行反向传播。由于使用了简单的阈值化（thresholding），ReLU 计算效率很高。但是 ReLU 神经元也存在一些缺点：</p><ol><li>不以零为中心：和 Sigmoid 激活函数类似，ReLU 函数的输出不以零为中心。</li><li>前向传导（forward pass）过程中，如果 <code>x &lt; 0</code>，则神经元保持非激活状态，且在后向传导（backward pass）中「杀死」梯度。这样权重无法得到更新，网络无法学习。当 <code>x = 0</code> 时，该点的梯度未定义，但是这个问题在实现中得到了解决，通过采用左侧或右侧的梯度的方式。</li></ol><h3 id="relu6抑制其最大值"><a class="markdownIt-Anchor" href="#relu6抑制其最大值"></a> ReLU6（抑制其最大值）</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mn>6</mn><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ReLU6=min(6,max(0,x)) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><img src="relu6.png" alt="ReLU6 和 ReLU 函数曲线对比"></p><p><img src="g-relu6.png" alt="ReLU6 和 ReLU 梯度函数曲线对比"></p><p>主要是为了在移动端 float16 的低精度的时候，也能有很好的数值分辨率，如果对 ReLu 的输出值不加限制，那么输出范围就是 <code>0</code> 到正无穷，而低精度的 float16 无法精确描述其数值，带来精度损失。</p><h3 id="elu-指数线性单元-exponential-linear-units"><a class="markdownIt-Anchor" href="#elu-指数线性单元-exponential-linear-units"></a> ELU (指数线性单元 exponential linear units)</h3><p><img src="equation1.png" alt="ELU 公式"></p><p><img src="elu.png" alt="ELU 函数曲线"></p><p>其将激活函数的平均值接近零，从而加快学习的速度。同时，还可以通过正值的标识来避免梯度消失的问题。根据一些研究，ELU 的分类 精确度要高于 Relu。</p><ul><li><p>融合了 Sigmoid 和 ReLU，<strong>左侧具有软饱和性</strong>，右侧无饱和性。</p></li><li><p>右侧线性部分使得 ELU 能够缓解梯度消失，而<strong>左侧软饱能够让 ELU 对输入变化或噪声更鲁棒</strong>。</p></li><li><p>ELU 的输出<strong>均值接近于零</strong>，所以收敛速度更快。</p></li><li><p>在 ImageNet 上，不加 Batch Normalization 30 层以上的 ReLU, 网络会无法收敛，PReLU 网络在 MSRA 的 Fan-in（caffe）初始化下会发散，而 ELU 网络在 Fan-in/Fan-out 下都能收敛。</p></li></ul><h3 id="selu-缩放指数线性单元-scaled-exponential-linear-units"><a class="markdownIt-Anchor" href="#selu-缩放指数线性单元-scaled-exponential-linear-units"></a> SELU (缩放指数线性单元 scaled exponential linear units)</h3><p>就是给 ELU 乘上一个系数，该系数大于 <code>1</code>。</p><p>在这篇 paper Self-Normalizing Neural Networks 中，作者提到，SELU 可以使得输入在经过一定层数之后变为固定的分布。</p><p>以前的 ReLU、P-ReLU、ELU 等激活函数都是在负半轴坡度平缓，这样在激活的方差过大时可以让梯度减小，防止了梯度爆炸，但是在正半轴其梯度简单地设置为了 <code>1</code>。而 SELU 的正半轴大于 <code>1</code>，在方差过小的时候可以让它增大，但是同时防止了梯度消失。这样激活函数就有了一个不动点，网络深了之后每一层的输出都是均值为 <code>0</code>，方差为 <code>1</code>.</p><p>其中超参 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 的值是 <strong>证明得到</strong> 的（而非训练学习得到）</p><p><img src="equation3.png" alt="SELU 函数及其梯度函数公式"></p><p><img src="selu.png" alt="SELU 函数曲线"></p><h3 id="leaky-relu"><a class="markdownIt-Anchor" href="#leaky-relu"></a> Leaky-ReLU</h3><p>Leaky ReLU 和 ReLU 不同的是，ReLU 是将所有的负值设为零，而 Leaky ReLU 是给所有负值赋予一个非零斜率，即用一个负值部分除以大于 <code>1</code> 的数。(公式中 <code>a</code> 是大于 <code>1</code> 的一个常数)</p><p><img src="equation4.png" alt="Leaky ReLU 公式"></p><p><img src="lrelu.png" alt="Leaky ReLU 函数曲线"></p><h3 id="p-relu参数化修正线性单元"><a class="markdownIt-Anchor" href="#p-relu参数化修正线性单元"></a> P-ReLU（参数化修正线性单元）</h3><p><img src="equation5.svg" alt="P-ReLU 公式"></p><p>可以看作是 Leaky ReLU 的一个变体，不同的是，P-ReLU 中的负值部分的斜率是根据数据来定的，即 <code>a</code> 的值并不是一个常数。</p><p>注意区分 PReLU 和 LeakyReLU，PReLU 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 是一个可学习的数组，尺寸与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 相同。</p><p>PReLU 是针对 ReLU 的一个改进型，在负数区域内，PReLU 有一个很小的斜率，这样也可以避免 ReLU 死掉的问题。相比于 ELU，PReLU 在负数区域内是线性运算，斜率虽然小，但是不会趋于0，这算是一定的优势。</p><h3 id="r-relu-随机纠正线性单元"><a class="markdownIt-Anchor" href="#r-relu-随机纠正线性单元"></a> R-ReLU (（随机纠正线性单元)</h3><p>R-ReLU 也是 Leaky ReLU 的一个变体，只不过在这里负值部分的斜率在训练的时候是随机的，即在一个范围内随机抽取 <code>a</code> 的值，不过这个值在测试环节会固定下来。</p><h3 id="swish"><a class="markdownIt-Anchor" href="#swish"></a> Swish</h3><p>paper : Searching for Activation Functions</p><p>beta是个常数或者可以训练的参数。其具有无上界有下界、平滑、非单调的特性。其在模型效果上优于 ReLU。</p><blockquote><p>由于训练会受多种因素的影响，我们很难证明为什么一个激活函数会优于另一个。但是我们认为 Swish <strong>无上界有下界</strong>、<strong>非单调</strong>且<strong>平滑</strong>的特性都是优势。</p></blockquote><p><img src="equation6.png" alt="Swish 公式及其梯度函数公式"></p><p><img src="swish.png" alt="Swish 函数曲线"></p><p><img src="g-swish.png" alt="Swish 梯度函数曲线"></p><h3 id="hard-swish"><a class="markdownIt-Anchor" href="#hard-swish"></a> Hard-Swish</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>−</mo><mi>s</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mfrac><mrow><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mn>6</mn><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><mn>6</mn></mfrac></mrow><annotation encoding="application/x-tex">h-swish(x) = x \frac{ReLU6(x+3)}{6} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord mathdefault">x</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord">6</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>在论文 Searching for MobileNet V3 中，作者提到，虽然这种 Swish 非线性提高了精度，但是在嵌入式环境中，他的成本是非零的，因为在移动设备上计算 sigmoid 函数代价要大得多。</p><p>因此作者使用 hard-Swish 和 hard-Sigmoid 替换了 ReLU6 和 SE-block 中的 Sigmoid 层，但是只是在网络的后半段才将 ReLU6 替换为 h-Swish，因为作者发现 Swish 函数只有在更深的网络层使用才能体现其优势。</p><p>首先是肯定了 Swish 的重要性，然后指出<strong>在量化模式下，Sigmoid 函数比 ReLU6 的计算代价大的多，所以才有了这个 ReLU6 版本的 h-Swish</strong>。</p><p><img src="hardswish.png" alt="Swish 和 hard-Swish 函数曲线对比"></p><p><img src="g-hardswish.png" alt="Swish 和 hard-Swish 梯度函数曲线对比"></p><h3 id="mish"><a class="markdownIt-Anchor" href="#mish"></a> Mish</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>i</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><mi>t</mi><mi>a</mi><mi>n</mi><mi>h</mi><mo stretchy="false">(</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi>e</mi><mi>x</mi></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Mish(x) = x * tanh(ln(1+e^x)) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><img src="mish.png" alt="Mish 和 Swish 函数曲线对比"></p><p><img src="g-mish.png" alt="Mish 和 Swish 梯度函数曲线对比"></p><p>为什么 Mish 表现的更好：</p><blockquote><p>无边界(即正值可以达到任何高度)避免了由于封顶而导致的饱和。理论上对负值的轻微允许允许更好的梯度流，而不是像 ReLU 中那样的硬零边界。<br>平滑的激活函数允许更好的信息深入神经网络，从而得到更好的准确性和泛化。<br>Mish 函数在曲线上几乎所有点上的平滑度</p></blockquote><h3 id="maxout"><a class="markdownIt-Anchor" href="#maxout"></a> Maxout</h3><p>与常规的激活函数不同，Maxout 是一个可以学习的分段线性函数。</p><p>其可以看做是在深度学习网络中加入了一层激活函数层，包含一个参数 <code>k</code>，这一层相比 ReLU，Sigmoid 等，其在于增加了 <code>k</code> 个神经元，然后输出激活值最大的值。<br>其需要学习的参数就是 <code>k</code> 个神经元中的权值和偏置，这就相当于<strong>常规的激活函数一层，而 Maxout 是两层，而且参数个数增加了 <code>k</code> 倍</strong>。</p><p>其可以有效的原理是，<strong>任何 ReLU 及其变体等激活函数都可以看成分段的线性函数，而 Maxout 加入的一层神经元正是一个可以学习参数的分段线性函数</strong>。</p><p><strong>优点</strong>：<br>其拟合能力很强，理论上可以拟合任意的凸函数；<br>具有 ReLU 的所有优点，线性和非饱和性；<br>同时没有 ReLU 的一些缺点，如神经元的死亡；</p><p><strong>缺点</strong>：<br>导致整体参数的激增。</p><p><img src="maxout.png" alt="Maxout 示意图"></p><p><img src="maxoutnet.png" alt="Maxout network 示意图"></p><blockquote><p>对上图做个说明，第 <code>i</code> 层有 <code>3</code> 个节点，红点表示，而第 <code>i+1</code> 层有 <code>4</code> 个结点，用彩色点表示，此时在第 <code>i+1</code> 层采用 maxout（<code>k=3</code>）。我们看到第 <code>i+1</code> 层的每个节点的激活值都有 <code>3</code> 个值，<code>3</code> 次计算的最大值才是对应点的最终激活值。我举这个例子主要是为了说明，决定结点的激活值的时候并不是以层为单位，仍然以节点为单位。</p></blockquote><h3 id="softplus"><a class="markdownIt-Anchor" href="#softplus"></a> Softplus</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi>e</mi><mi>x</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y=log(1+e^x) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><img src="softplus.png" alt="Softplus 和 ReLU 的函数曲线对比"></p><blockquote><p>softplus可以看作是 ReLU 的平滑。根据神经科学家的相关研究，softplus 和 ReLU 与脑神经元激活频率函数有神似的地方。也就是说，相比于早期的激活函数，softplus 和 ReLU 更加接近脑神经元的激活模型，而神经网络正是基于脑神经科学发展而来，这两个激活函数的应用促成了神经网络研究的新浪潮。</p></blockquote><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://blog.csdn.net/jsk_learner/article/details/102822001" target="_blank" rel="noopener">深度学习—激活函数详解（Sigmoid、tanh、ReLU、ReLU6及变体P-R-Leaky、ELU、SELU、Swish、Mish、Maxout、hard-sigmoid、hard-swish）</a><br><a href="https://www.jiqizhixin.com/articles/2017-11-02-26" target="_blank" rel="noopener">一文概览深度学习中的激活函数</a><br><a href="https://zhuanlan.zhihu.com/p/122267172" target="_blank" rel="noopener">深度学习中常用的激活函数详解</a><br><a href="https://blog.csdn.net/Chaolei3/article/details/78873039" target="_blank" rel="noopener">深度学习笔记–激活函数：sigmoid，maxout</a></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>YOLOv4</title>
      <link href="/2021/03/29/YOLOv4/"/>
      <url>/2021/03/29/YOLOv4/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了关于 yolo v4 的内容。</p><a id="more"></a><h1 id="0-序言"><a class="markdownIt-Anchor" href="#0-序言"></a> 0. 序言</h1><p>Yolo v4 论文主要由 <strong>目标检测网络构成</strong>，<strong>Bag of freebies</strong>, <strong>Bag of specials</strong> 这三部分组成。</p><p>作者首先详细列举了目前已有的目标检测网络构成部件，以及已有的 Bag of freebies, Bag of specials, 然后分别从这三大部分中选取合适的内容，组成了 Yolo v4.</p><p>列举的三大部分如下面三张图</p><p><img src="detector-parts.png" alt="目标检测网络的构成部件"></p><p><img src="freebies.png" alt="Bag of freebies"></p><p><img src="specials.png" alt="Bag of specials"></p><h1 id="1-yolo-v4-的选择"><a class="markdownIt-Anchor" href="#1-yolo-v4-的选择"></a> 1. YOLO v4 的选择</h1><p>YOLO v4 对各个部分的选择如下图所示</p><p><img src="selections.png" alt="YOLO v4 的选择"></p><h1 id="2-各部分详细解读"><a class="markdownIt-Anchor" href="#2-各部分详细解读"></a> 2. 各部分详细解读</h1><h2 id="21-backbone"><a class="markdownIt-Anchor" href="#21-backbone"></a> 2.1 Backbone</h2><h3 id="211-densenet"><a class="markdownIt-Anchor" href="#211-densenet"></a> 2.1.1 DenseNet</h3><p>Transition layer 由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的卷积和 pooling 组成，分别用来降低通道数和空间尺寸。</p><p><img src="denseblock.jpeg" alt="DenseBlock"></p><p><img src="densenet.png" alt="DenseNet"></p><h3 id="212-cross-stage-partial-connections-csp"><a class="markdownIt-Anchor" href="#212-cross-stage-partial-connections-csp"></a> 2.1.2 Cross-Stage-Partial-connections (CSP)</h3><p>CSP 可以用在不同的网络上，下面的图展示了在 DenseNet 上使用 CSP 的结构。</p><p>CSPNet 将输入分成两部分 (沿通道分开)，一部分经过 DenseBlock 的处理，另一部分直接跳过处理，输入最后的输出层。</p><p><img src="CSP1.jpeg" alt="CSP Block"></p><p><img src="CSP2.png" alt="CSPNet"></p><h3 id="213-cspdarknet53"><a class="markdownIt-Anchor" href="#213-cspdarknet53"></a> 2.1.3 CSPDarknet53</h3><p>YOLO v4 使用 Darknet53 + CSP 连接组成的 CSPDarknet53 作为 backbone.</p><p><img src="CSPDarknet53.png" alt="YOLO v4 网络结构"></p><h2 id="22-neck"><a class="markdownIt-Anchor" href="#22-neck"></a> 2.2 Neck</h2><h3 id="221-feature-pyramid-networks-fpn"><a class="markdownIt-Anchor" href="#221-feature-pyramid-networks-fpn"></a> 2.2.1 Feature Pyramid Networks (FPN)</h3><p><img src="FPN.png" alt="FPN"></p><h3 id="222-spp-spatial-pyramid-pooling-layer"><a class="markdownIt-Anchor" href="#222-spp-spatial-pyramid-pooling-layer"></a> 2.2.2 SPP (spatial pyramid pooling layer)</h3><p><img src="SPP.jpeg" alt="原始的SPP"></p><h3 id="223-yolo-with-spp"><a class="markdownIt-Anchor" href="#223-yolo-with-spp"></a> 2.2.3 YOLO with SPP</h3><p>YOLO 中的 SPP 和本来的作用有点不一样，YOLO 中的 SPP 使用不同的 pooling 层对输入进行池化，但是不改变空间尺寸。然后不同 pooling 层得到的结果和原始的输入都 concatenate 在一起。</p><p><img src="SPP-yolo.jpeg" alt="YOLO 中的 SPP"></p><h3 id="224-path-aggregation-network-pan"><a class="markdownIt-Anchor" href="#224-path-aggregation-network-pan"></a> 2.2.4 Path Aggregation Network (PAN)</h3><p>下图是目标检测的 Path Aggregation Network(PAN)。 自底向上的路径 (b) 被扩展，使低层信息更容易传播到顶层。 在 FPN 中，局部空间信息在红色箭头中向上传递。 虽然在图中没有清楚地显示，但是红色的路径穿过了大约 <code>100</code> 多层。 PAN 引入了一条简捷的路径(绿色路径) ，只需要大约 <code>10</code> 层就可以到达顶层 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">N_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。 <strong>这种短路概念使细粒度的本地化信息可用于顶层</strong>。</p><p><img src="PAN.png" alt="PAN 结构"></p><p><img src="view-pan.jpeg" alt="另一种看待 PAN 的方法"></p><p>不过在 YOLOv4 中，特征图不是加上邻居层，而是 concate 在一起。</p><p><img src="modified-pan.jpg" alt="YOLO v4 中修改过的 PAN"></p><h3 id="225-spatial-attention-module-sam"><a class="markdownIt-Anchor" href="#225-spatial-attention-module-sam"></a> 2.2.5 Spatial Attention Module (SAM)</h3><p>注意力 (Attention) 在 DL 设计中有着广泛的应用。 在 SAM 中，最大池化和平均池化分别应用于输入特征图，生成两组特征图。 这些结果被输入到一个卷积层，然后经过 sigmoid 函数，以产生空间注意力。</p><p><img src="SAM.jpeg" alt="SAM 模块"></p><p>对应 空间注意力模块 (SAM)，也有 通道注意力模块 (CAM)</p><p><img src="CAM.png" alt="CAM 模块"></p><p>在 YOLOv4 中，使用了一个修改的 SAM，没有应用最大和平均池化。</p><p><img src="modified-sam.jpeg" alt="YOLO v4 中 SAM"></p><p>在 YOLO v4 中，FPN 概念逐渐被修改版的 SPP和 PAN 实现/取代。</p><h2 id="23-bag-of-freebies-bof-for-backbone"><a class="markdownIt-Anchor" href="#23-bag-of-freebies-bof-for-backbone"></a> 2.3 Bag of Freebies (BoF) for backbone</h2><p>YOLOv4 backbone 的 BoF 特性包括:</p><ul><li>CutMix 和 Mosaic 数据增强</li><li>DropBlock 正则化</li><li>类别标签平滑</li></ul><h3 id="231-cutmix-数据增强"><a class="markdownIt-Anchor" href="#231-cutmix-数据增强"></a> 2.3.1 CutMix 数据增强</h3><p>Cutout 数据增强删除图像的一个区域(见下图)。 <strong>这迫使模型在进行分类时不要对特定特性过于自信</strong>。 然而这样的话，图像的一部分充满了没用的信息，这是一种浪费。 在 CutMix 中，图像的一部分被剪切并粘贴到另一个图像上。 Ground truth 标签会根据补丁的面积按比例重新调整，例如 <code>0.6</code> 像狗，<code>0.4</code> 像猫。</p><p><img src="cutmix.jpeg" alt="CutMix 与其他方法效果比较"></p><p>从概念上讲，CutMix 对于一个对象可能由什么组成有更广阔的视野。 CutOut 区域迫使模型学习目标分类的不同特征集合。 这样可以避免过度自信。 由于该区域被替换为另一个图像，图像中的信息量和训练效率也不会受到显著影响。</p><h3 id="232-mosaic-数据增强"><a class="markdownIt-Anchor" href="#232-mosaic-数据增强"></a> 2.3.2 Mosaic 数据增强</h3><p>Mosaic 是一种数据增强方法，组合了 4 个训练图像到一个训练图像中(而不是 CutMix 中的2个)。 这增强了对其正常 context 之外的对象的检测。 此外，每个 mini-batch 都包含更大数量的图像 (4x)，因此减少了估计均值和方差时对大的 mini-batch 的需求。</p><p><img src="mosaic.jpeg" alt="Mosaic 增强示意图"></p><h3 id="233-dropblock-正则化"><a class="markdownIt-Anchor" href="#233-dropblock-正则化"></a> 2.3.3 DropBlock 正则化</h3><p>在全连接层中，我们可以应用 dropout 强制模型从各种特征中学习，而不是对一些特征过于自信。然而这可能对卷积层无效。相邻位置是高度相关的。所以即使有些像素被去掉了(下面的中图) ，空间信息仍然可以被检测到。 DropBlock 正则化基于一个类似的概念，但适用于卷积层。</p><p><img src="dropblock.png" alt="DropBlock"></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><msub><mi>k</mi><mi>s</mi></msub><mi>i</mi><mi>z</mi><mi>e</mi><mo>×</mo><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><msub><mi>k</mi><mi>s</mi></msub><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">block_size × block_size</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span></span></span></span> 大小的块被整块删除，而不是删掉单独的像素。</p><p><img src="dropblock2.jpg" alt="dropblock算法"></p><h3 id="234-类别标签平滑class-label-smoothing"><a class="markdownIt-Anchor" href="#234-类别标签平滑class-label-smoothing"></a> 2.3.4 类别标签平滑(Class label smoothing)</h3><p>每当你觉得自己绝对正确的时候，你很可能是错的。 100% 相信一个预测可能会显示出这个模型是在记忆数据而不是在学习。 标签平滑将预测的目标上限调整为一个较低的值，比如 <code>0.9</code>。 它将使用这个值而不是 <code>1.0</code> 来计算损失。 这个概念减轻了 overfitting 问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p = tf.placeholder(tf.float32, shape=[<span class="keyword">None</span>, <span class="number">10</span>])</span><br><span class="line"><span class="comment"># Use 0.9 instead of 1.0.</span></span><br><span class="line">feed_dict = &#123;</span><br><span class="line">  p: [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]] <span class="comment"># Image with label "3"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># logits_real_image is the logits calculated by </span></span><br><span class="line"><span class="comment"># the discriminator for real images.</span></span><br><span class="line">d_real_loss = tf.nn.sigmoid_cross_entropy_with_logits(</span><br><span class="line">                    labels=p, logits=logits_real_image)</span><br></pre></td></tr></table></figure><h2 id="24-bag-of-specials-bos-for-backbone"><a class="markdownIt-Anchor" href="#24-bag-of-specials-bos-for-backbone"></a> 2.4 Bag of Specials (BoS) for backbone</h2><p>YOLOv4 backbone 的 BoS 特性包括:</p><ul><li>Mish 激活</li><li>Cross-stage partial connections (CSP)</li><li>Multi-input weighted residual connections (MiWRC)</li></ul><h3 id="241-mish-激活"><a class="markdownIt-Anchor" href="#241-mish-激活"></a> 2.4.1 Mish 激活</h3><p>下面这个新的激活函数，称为 Swish，表现出比 ReLU 和很多其它激活函数更好的性能。</p><p><img src="swish.jpeg" alt="不同  值下的 Swish 激活函数"></p><p>Mish 是另一个与 ReLU 和 Swish 非常相似的激活函数。 正如论文所宣称的，Mish 在很多深层网络不同数据集的表现都优于它们。</p><p><img src="mish.jpeg" alt="Mish 激活函数"></p><p>关于激活函数的详细内容，请看这篇文章 <a href="//2021/03/30/Activation-functions/" title="激活函数详解">激活函数详解</a></p><h3 id="242-multi-input-weighted-residual-connections-miwrc"><a class="markdownIt-Anchor" href="#242-multi-input-weighted-residual-connections-miwrc"></a> 2.4.2 Multi-input weighted residual connections (MiWRC)</h3><blockquote><p>讲了 EfficientDet 中的逆残差块 (inverted residual block)</p></blockquote><p>在许多 ML 和 DL 问题中，我们学习输入的低维表示。 我们通过创建“信息”瓶颈 (bottleneck) 来提取数据的核心信息。 这迫使我们去发现最重要的信息，这是学习的核心原则。 根据这一原则，一个逆残差块以一个低维表示作为输入，并通过卷积(线性运算)和非线性运算对其进行操作。 但是像 ReLU 这样的非线性部分存在一个主要问题。非线性操作不成比例地拉伸或压缩区域。在这种压缩中，输入可能映射到相同的区域/点。 例如，ReLU 可能在这个低维空间中折叠通道，从而不可避免地丢失信息。 正如论文上引用的:</p><blockquote><p>为了保持表达能力，在窄层上消除非线性是很重要的。</p></blockquote><p>为了解决这个问题，我们可以暂时扩展维度(通道数量)。 我们希望在有很多的通道的情况下，在非线性操作之后，信息仍然可以保存在某些通道中。 下面是一个逆残留块的细节:</p><p><img src="inverted.jpeg" alt="逆残差模块 Inverted residual block"></p><p>如图所示，低维表示首先扩展到 tk 通道。 然后，用轻量级的 3x3 depthwise 卷积滤波。 然后在模块的末端将特性降低到低维。 在高维空间中时，会加上非线性操作。</p><p><img src="inverted-block.png" alt="逆残差模块示意图"></p><p>残差连接从模块的开始添加到尾部。 左图是传统的残差块，右图是描述的逆残差块。</p><p><img src="inverted-compare.png" alt="传统残差模块和逆残差模块对比"></p><p>理解 EfficientDet 的关键概念是件好事。 但 EfficientDet 对 YOLOv4的主要贡献是多Multi-input weighted residual connections。 在 EfficientDet 论文中，我们观察到不同的输入特征在不同的分辨率下，对输出特征的贡献是不均匀的。 但是在我们之前的讨论中，我们平等地加上了这些特性。 在 EfficientDet 中，输入特征在合成输出时的权重是不同的:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>=</mo><msub><mi>Σ</mi><mi>i</mi></msub><mfrac><msub><mi>w</mi><mi>i</mi></msub><mrow><mi>ϵ</mi><mo>+</mo><msub><mi>Σ</mi><mi>j</mi></msub><msub><mi>w</mi><mi>j</mi></msub></mrow></mfrac><mo>⋅</mo><msub><mi>I</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\it O =  \Sigma_i \frac{w_i}{\epsilon + \Sigma_jw_j} \cdot {I_i} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.079668em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mord mathit">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathit">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.308752em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30875199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathit">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30875199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.308752em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mord mathit">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.308752em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\it w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathit">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.308752em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 会像其它可训练的参数一样被训练和学习。</p><h2 id="25-bag-of-freebies-bof-for-detector"><a class="markdownIt-Anchor" href="#25-bag-of-freebies-bof-for-detector"></a> 2.5 Bag of Freebies (BoF) for detector</h2><p>Yolov4检测器的 BoF 功能包括:</p><ul><li>CIoU-loss</li><li>CmBN</li><li>DropBlock 正则化</li><li>Mosaic 数据增强</li><li>Self-Adversarial 训练</li><li>消除网格敏感性 (Eliminate grid sensitivity)</li><li>用多个 anchors 来对应单个 ground truth</li><li>Cosine annealing scheduler</li><li>最佳超参数</li><li>随机训练形状</li></ul><h3 id="251-ciou-loss"><a class="markdownIt-Anchor" href="#251-ciou-loss"></a> 2.5.1 CIoU-loss</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>C</mi><mi>I</mi><mi>o</mi><mi>U</mi></mrow></msub><mo>=</mo><mn>1</mn><mo>−</mo><mi>I</mi><mi>o</mi><mi>U</mi><mo>+</mo><mfrac><mrow><msup><mi>ρ</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><msup><mi>b</mi><mrow><mi>g</mi><mi>t</mi></mrow></msup><mo stretchy="false">)</mo></mrow><msup><mi>c</mi><mn>2</mn></msup></mfrac><mo>+</mo><mi>α</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">L_{CIoU} = 1- IoU + \frac{\rho^2(b,b^{gt})}{c^2} + \alpha v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.177108em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>=</mo><mfrac><mn>4</mn><msup><mi>π</mi><mn>2</mn></msup></mfrac><mo stretchy="false">(</mo><mi>a</mi><mi>r</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mfrac><msup><mi>w</mi><mrow><mi>g</mi><mi>t</mi></mrow></msup><msup><mi>h</mi><mrow><mi>g</mi><mi>t</mi></mrow></msup></mfrac><mo>−</mo><mi>a</mi><mi>r</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mfrac><mi>w</mi><mi>h</mi></mfrac><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">v = \frac{4}{\pi^2}(arctan\frac{w^{gt}}{h^{gt}} - arctan\frac{w}{h})^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3482399999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.00324em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7253428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8703428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1591079999999998em;vertical-align:-0.345em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mi>v</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>I</mi><mi>o</mi><mi>U</mi><mo stretchy="false">)</mo><mo>+</mo><mi>v</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\alpha=\frac{v}{(1-IoU)+v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.215392em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>关于各种 IoU 的详细内容，请看这篇文章。<a href="//2021/03/30/IoU-variants/" title="IoU variants">IoU variants</a></p><h3 id="252-cmbn"><a class="markdownIt-Anchor" href="#252-cmbn"></a> 2.5.2 CmBN</h3><p>原始的 Batch normalization 在一个 mini-batch 收集样本的均值和方差，以对层输入进行白话 (whiten)。 然而，如果 mini-batch size 很小，这些估计就会产生很大的噪声。一个解决方案是在很多 mini-batches 中估计它们。 但是，由于权重在每次迭代中都在变化，在这些权重下收集的统计信息在新的权重下可能变得不准确。 简单地进行平均是不正确的。幸运的是，权重是逐渐变化的。在 Cross-Iteration Batch Normalization(CBN) 中，它使用下面的调整来估计前面 <code>k</code> 次迭代中的统计信息。</p><p><img src="CBN.jpeg" alt="CBN 和 BN 的对比"></p><p>CmBN 是一个修改过的版本，它只收集单个 batch 内的 mini-batches 之间的统计数据。</p><h3 id="253-self-adversarial-training-sat"><a class="markdownIt-Anchor" href="#253-self-adversarial-training-sat"></a> 2.5.3 Self-Adversarial Training (SAT)</h3><p>SAT 是一种数据增强技术。首先，它对训练样本进行前向传播。在传统的反向传播算法中，我们通过调整模型权重来改进检测器的性能。在这里，它朝着相反的方向。它改变图像来最大化降低检测器的性能。也就是说，尽管新图片在视觉上看起来是一样的，但它会对当前模型产生对抗性攻击。接下来，使用原始边界框和类标签对模型进行训练。这有助于模型泛化并减少过拟合。</p><h3 id="254-消除网格敏感性eliminate-grid-sensitivity"><a class="markdownIt-Anchor" href="#254-消除网格敏感性eliminate-grid-sensitivity"></a> 2.5.4 消除网格敏感性(Eliminate grid sensitivity)</h3><p>边界框 b 的计算方法是:</p><p><img src="box.jpeg" alt="yolo 中边界框的计算方式"></p><p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>x</mi></msub><mo>=</mo><msub><mi>c</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">b_x=c_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>x</mi></msub><mo>=</mo><msub><mi>c</mi><mi>x</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">b_x=c_x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，我们需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">t_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别有一个巨大的负值和正值。但是我们可以用比例因子 (&gt;1.0) 来乘 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\it\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">σ</span></span></span></span></span>，这样更简单。 以下是源代码的更改:</p><p><img src="sensitivity.png" alt="源码的更改"></p><h3 id="255-multiple-anchors-for-a-single-ground-truth"><a class="markdownIt-Anchor" href="#255-multiple-anchors-for-a-single-ground-truth"></a> 2.5.5 Multiple anchors for a single ground truth</h3><p>如果 IoU(ground true，anchor) &gt; IoU 阈值，则使用多个 anchors。 (注意，我还没有足够的信息来确定它在 YOLOv4中的作用。)</p><h3 id="256-cosine-annealing-scheduler"><a class="markdownIt-Anchor" href="#256-cosine-annealing-scheduler"></a> 2.5.6 Cosine annealing scheduler</h3><p>余弦 schedule 根据余弦函数调整学习率。 它从缓慢降低大的学习率开始。 然后在中途迅速降低学习率，最终学习率降低以微小的斜率告终。</p><p><img src="cosine-formation.jpeg" alt="余弦学习率公式"></p><p>图表显示了学习率是如何衰减的(学习率 warmup 也在下面的图表中应用)及其对 mAP 的影响。 这可能不是很明显，新的 schedule 有稳定的变化，而不是停滞很长一段时间后再次发生变化。</p><p><img src="step-cosine.jpeg" alt="余弦学习率和阶梯学习率的对比"></p><h3 id="257-基于遗传算法的超参数选择进化算法"><a class="markdownIt-Anchor" href="#257-基于遗传算法的超参数选择进化算法"></a> 2.5.7 基于遗传算法的超参数选择(进化算法)</h3><h3 id="258-随机训练形状"><a class="markdownIt-Anchor" href="#258-随机训练形状"></a> 2.5.8 随机训练形状</h3><h2 id="26-bag-of-specials-bos-for-detector"><a class="markdownIt-Anchor" href="#26-bag-of-specials-bos-for-detector"></a> 2.6 Bag of Specials (BoS) for detector</h2><p>YOLOv4检测器的 BoS 功能包括:</p><ul><li>Mish 激活</li><li>改进的 SPP-block</li><li>改进的 SAM-block</li><li>改进的 PAN path-aggregation block</li><li>DIoU-NMS</li></ul><h3 id="261-diou-nms"><a class="markdownIt-Anchor" href="#261-diou-nms"></a> 2.6.1 DIoU-NMS</h3><p>NMS 过滤掉其它预测相同目标的边界框，并保留一个最有信心的边界框。</p><p>在 NMS 中使用了 DIoU (前面讨论过)作为因子。该方法利用 IoU 和两个边界框中心点之间的距离来抑制冗余边界框。这使得它对于遮挡的情况更加鲁棒。</p><p><img src="NMS.jpeg" alt="YOLO 中 NMS 流程"></p><h1 id="3-yolo-v4-网络结构分析"><a class="markdownIt-Anchor" href="#3-yolo-v4-网络结构分析"></a> 3. YOLO v4 网络结构分析</h1><p><img src="yolov4.jpg" alt="YOLO v4 网络结构"></p><blockquote><p>这里我们直接从代码上看看这个 CSPDarknet53 什么样子，定义如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">darknet_body</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''Darknent body having 52 Convolution2D layers'''</span></span><br><span class="line">    x = DarknetConv2D_BN_Mish(<span class="number">32</span>, (<span class="number">3</span>,<span class="number">3</span>))(x)</span><br><span class="line">    x = resblock_body(x, <span class="number">64</span>, <span class="number">1</span>, <span class="keyword">False</span>)</span><br><span class="line">    x = resblock_body(x, <span class="number">128</span>, <span class="number">2</span>)</span><br><span class="line">    x = resblock_body(x, <span class="number">256</span>, <span class="number">8</span>)</span><br><span class="line">    x = resblock_body(x, <span class="number">512</span>, <span class="number">8</span>)</span><br><span class="line">    x = resblock_body(x, <span class="number">1024</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果把 <strong>堆叠的残差单元</strong> (resblock_body)看成整体的话，那么这个结构和 Darknet53 以及 ResNet 等的确差别不大，特别是 resblock_body 的 num_blocks为 <code>1，2，8，8，4</code>, 和darknet53一模一样。</p><p>那么我们解析一下resblock_body的定义，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resblock_body</span><span class="params">(x, num_filters, num_blocks, all_narrow=True)</span>:</span></span><br><span class="line">    <span class="string">'''A series of resblocks starting with a downsampling Convolution2D'''</span></span><br><span class="line">    <span class="comment"># Darknet uses left and top padding instead of 'same' mode</span></span><br><span class="line">    preconv1 = ZeroPadding2D(((<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)))(x)</span><br><span class="line">    preconv1 = DarknetConv2D_BN_Mish(num_filters, (<span class="number">3</span>,<span class="number">3</span>), strides=(<span class="number">2</span>,<span class="number">2</span>))(preconv1)</span><br><span class="line">    shortconv = DarknetConv2D_BN_Mish(num_filters//<span class="number">2</span> <span class="keyword">if</span> all_narrow <span class="keyword">else</span> num_filters, (<span class="number">1</span>,<span class="number">1</span>))(preconv1)</span><br><span class="line">    mainconv = DarknetConv2D_BN_Mish(num_filters//<span class="number">2</span> <span class="keyword">if</span> all_narrow <span class="keyword">else</span> num_filters, (<span class="number">1</span>,<span class="number">1</span>))(preconv1)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_blocks):</span><br><span class="line">        y = compose(</span><br><span class="line">                DarknetConv2D_BN_Mish(num_filters//<span class="number">2</span>, (<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                DarknetConv2D_BN_Mish(num_filters//<span class="number">2</span> <span class="keyword">if</span> all_narrow <span class="keyword">else</span> num_filters, (<span class="number">3</span>,<span class="number">3</span>)))(mainconv)</span><br><span class="line">        mainconv = Add()([mainconv,y])</span><br><span class="line">    postconv = DarknetConv2D_BN_Mish(num_filters//<span class="number">2</span> <span class="keyword">if</span> all_narrow <span class="keyword">else</span> num_filters, (<span class="number">1</span>,<span class="number">1</span>))(mainconv)</span><br><span class="line">    route = Concatenate()([postconv, shortconv])</span><br><span class="line">    <span class="keyword">return</span> DarknetConv2D_BN_Mish(num_filters, (<span class="number">1</span>,<span class="number">1</span>))(route)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这么一看，和传统的ResBlock差别就出来了，为了大家更清晰地了解结构，我把这个残差单元的结构绘制出来，如下：</p><p><img src="resblock_body.jpg" alt="resblock_body 的结构图 (相对于 res_stage)"></p><p>对照代码和上面的图片，可以比较清晰地看出来这个 <strong>CSP 残差单元</strong>和 <strong>DarkNet/ResNet 的残差单元</strong>的区别了。</p><p>其中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DarknetConv2D_BN_Mish</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Darknet Convolution2D followed by BatchNormalization and LeakyReLU."""</span></span><br><span class="line">    no_bias_kwargs = &#123;<span class="string">'use_bias'</span>: <span class="keyword">False</span>&#125;</span><br><span class="line">    no_bias_kwargs.update(kwargs)</span><br><span class="line">    <span class="keyword">return</span> compose(</span><br><span class="line">        DarknetConv2D(*args, **no_bias_kwargs),</span><br><span class="line">        BatchNormalization(),</span><br><span class="line">        Mish())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DarknetConv2D</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Wrapper to set Darknet parameters for Convolution2D."""</span></span><br><span class="line">    darknet_conv_kwargs = &#123;&#125;</span><br><span class="line">    darknet_conv_kwargs[<span class="string">'kernel_initializer'</span>] = keras.initializers.RandomNormal(mean=<span class="number">0.0</span>, stddev=<span class="number">0.01</span>)</span><br><span class="line">    darknet_conv_kwargs[<span class="string">'padding'</span>] = <span class="string">'valid'</span> <span class="keyword">if</span> kwargs.get(<span class="string">'strides'</span>)==(<span class="number">2</span>,<span class="number">2</span>) <span class="keyword">else</span> <span class="string">'same'</span></span><br><span class="line">    darknet_conv_kwargs.update(kwargs)</span><br><span class="line">    <span class="keyword">return</span> Conv2D(*args, **darknet_conv_kwargs)</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><blockquote><p>在 YOLO V4 Keras 代码中，通常将 YOLO HEAD (图片上的橙色块）紧接在 SSP+PAN 后面。为了便于说明，这里我们根据总图上的 process1-5 与三个 YOLO HEAD, 对 SSP+PAN+YOLO HEAD 部分进行解析。</p><p><strong>其中 process1 的代码实现为</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(darknet.output)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">1024</span>, (<span class="number">3</span>,<span class="number">3</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(y19)</span><br><span class="line">maxpool1 = MaxPooling2D(pool_size=(<span class="number">13</span>,<span class="number">13</span>), strides=(<span class="number">1</span>,<span class="number">1</span>), padding=<span class="string">'same'</span>)(y19) <span class="comment">#（19，19）</span></span><br><span class="line">maxpool2 = MaxPooling2D(pool_size=(<span class="number">9</span>,<span class="number">9</span>), strides=(<span class="number">1</span>,<span class="number">1</span>), padding=<span class="string">'same'</span>)(y19) <span class="comment">#（19，19）</span></span><br><span class="line">maxpool3 = MaxPooling2D(pool_size=(<span class="number">5</span>,<span class="number">5</span>), strides=(<span class="number">1</span>,<span class="number">1</span>), padding=<span class="string">'same'</span>)(y19) <span class="comment">#（19，19）</span></span><br><span class="line">y19 = Concatenate()([maxpool1, maxpool2, maxpool3, y19])</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">1024</span>, (<span class="number">3</span>,<span class="number">3</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(y19)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>显而易见，该进程接受 CSPDarknet53 最终的输出，返回变量 <code>y19</code> (如总图上 process1 所示），这里我们也给出图示，如下：</p><p><img src="process1.jpg" alt="process 1"></p><p><strong>process2 代码如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">y19_upsample = compose(DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>)), UpSampling2D(<span class="number">2</span>))(y19)</span><br><span class="line"></span><br><span class="line"><span class="comment">#38x38 head</span></span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(darknet.layers[<span class="number">204</span>].output)</span><br><span class="line">y38 = Concatenate()([y38, y19_upsample])</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(y38)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>即先将上述的 <code>y19</code> 进行上采样至大小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>38</mn><mi>x</mi><mn>38</mn></mrow><annotation encoding="application/x-tex">38x38</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mord mathdefault">x</span><span class="mord">3</span><span class="mord">8</span></span></span></span>，然后再和 CSPDarknet53 的 <code>204</code> 层输出进行堆叠，最后通过一系列 DarknetConv2D_BN_Leaky 模块，获得特征图 <code>y38</code>。</p><p><strong>process3</strong></p><p>process3 的代码接受 <code>y_38</code> 上采样后的特征图 <code>y38_upsample</code> 以及 darknet 网络的第 <code>131</code> 层输出作为输入，从而获得特征图 <code>y_38</code>，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y38_upsample = compose(DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">1</span>,<span class="number">1</span>)), UpSampling2D(<span class="number">2</span>))(y38)</span><br><span class="line"></span><br><span class="line">y76 = DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">1</span>,<span class="number">1</span>))(darknet.layers[<span class="number">131</span>].output)</span><br><span class="line">y76 = Concatenate()([y76, y38_upsample])</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>YOLO HEAD 1</strong></p><p>紧接在 process3 之后，代码中使用简单的 5+2 层卷积层对上面的 <code>y76</code> 进行输出。其实这里的卷积层就是图中橙色区域 YOLO HEAD1 ,在后面的 <code>y38_output</code> 和 <code>y19_output</code> 的输出过程中仍能够看到。其中代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#YOLO HEAD 1</span></span><br><span class="line">y76 = DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">1</span>,<span class="number">1</span>))(y76)</span><br><span class="line">y76 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">3</span>,<span class="number">3</span>))(y76)</span><br><span class="line">y76 = DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">1</span>,<span class="number">1</span>))(y76)</span><br><span class="line">y76 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">3</span>,<span class="number">3</span>))(y76)</span><br><span class="line">y76 = DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">1</span>,<span class="number">1</span>))(y76)</span><br><span class="line"><span class="comment">#76x76 output</span></span><br><span class="line">y76_output = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">3</span>,<span class="number">3</span>))(y76)</span><br><span class="line">y76_output = DarknetConv2D(num_anchors*(num_classes+<span class="number">5</span>), (<span class="number">1</span>,<span class="number">1</span>))(y76_output)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>该网络最后使用 <code>1x1</code> 卷积输出最大的一张特征图 <code>y76_output</code>，维度为 <code>(76,76,num_anchor*(num_classes+5))</code>。对应结构图中最大的输出特征图（最右边的淡蓝色特征图）。</p><p><strong>process4 的代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#38x38 output</span></span><br><span class="line">y76_downsample = ZeroPadding2D(((<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)))(y76)</span><br><span class="line">y76_downsample = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">3</span>,<span class="number">3</span>), strides=(<span class="number">2</span>,<span class="number">2</span>))(y76_downsample)</span><br><span class="line">y38 = Concatenate()([y76_downsample, y38])</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这一步骤比较关键，PAN 和 FPN 的差异在于，<strong>FPN</strong> 是<strong>自顶向下</strong>的特征融合，<strong>PAN 在 FPN 的基础上</strong>，多了个<strong>自底向上</strong>的特征融合。具体自底向上的特征融合，就是 process4 完成的，可以看到该步骤先将 <code>y76</code> 下采样至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>38</mn><mi>x</mi><mn>38</mn></mrow><annotation encoding="application/x-tex">38x38</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mord mathdefault">x</span><span class="mord">3</span><span class="mord">8</span></span></span></span> 大小，再和 <code>y38</code> 堆叠，作为 YOLO HEAD2 的输入。</p><p><strong>YOLO HEAD 2</strong></p><p>类似于 YOLO HEAD 1, YOLO HEAD 2 也进行一系列卷积运算，获得维度大小为 <code>(38,38,num_anchor*(num_classes+5))</code> 的输出 <code>y38_output</code>，其中代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#YOLO HEAD 2</span></span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(y38)</span><br><span class="line"></span><br><span class="line">y38_output = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>))(y38)</span><br><span class="line">y38_output = DarknetConv2D(num_anchors*(num_classes+<span class="number">5</span>), (<span class="number">1</span>,<span class="number">1</span>))(y38_output)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>其中process4和YOLO HEAD2如下图所示。</p><p><img src="head2.jpg" alt="process4 和 yolo head2 的流程"></p><p><strong>Process 5代码如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#19x19 output</span></span><br><span class="line">y38_downsample = ZeroPadding2D(((<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)))(y38)</span><br><span class="line">y38_downsample = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>), strides=(<span class="number">2</span>,<span class="number">2</span>))(y38_downsample)</span><br><span class="line">y19 = Concatenate()([y38_downsample, y19])</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Process 5 和 process 4 进程类似，不多赘述。后面接上 YOLO HEAD 3。</p><p><strong>YOLO HEAD 3</strong></p><p>和 YOLO HEAD 1 以及 YOLO HEAD 2 定义几乎类似，YOLO HEAD 3 定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">1024</span>, (<span class="number">3</span>,<span class="number">3</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">1024</span>, (<span class="number">3</span>,<span class="number">3</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(y19)</span><br><span class="line"></span><br><span class="line">y19_output = DarknetConv2D_BN_Leaky(<span class="number">1024</span>, (<span class="number">3</span>,<span class="number">3</span>))(y19)</span><br><span class="line">y19_output = DarknetConv2D(num_anchors*(num_classes+<span class="number">5</span>), (<span class="number">1</span>,<span class="number">1</span>))(y19_output)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>YOLO HEAD 3 输出为 <code>(19,19,num_anchor*(num_classes+5))</code> 的特征图 <code>y19_output</code>.</p></blockquote><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><ul><li><a href="https://jonathan-hui.medium.com/yolov4-c9901eaa8e61" target="_blank" rel="noopener">YOLOv4</a></li><li><a href="https://zhuanlan.zhihu.com/p/138510087" target="_blank" rel="noopener">YOLOv4</a></li><li><a href="https://blog.csdn.net/qq_48984174/article/details/111680645?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">CSPDarkNet53学习</a></li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> yolo </tag>
            
            <tag> CSP </tag>
            
            <tag> SPP </tag>
            
            <tag> PAN </tag>
            
            <tag> CutMix </tag>
            
            <tag> 数据增强 </tag>
            
            <tag> DropBlock </tag>
            
            <tag> GIoU </tag>
            
            <tag> DIoU </tag>
            
            <tag> CIoU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Making Convolutional Networks Shift-Invariant Again</title>
      <link href="/2021/03/19/Make-CNN-shift-invariant-again/"/>
      <url>/2021/03/19/Make-CNN-shift-invariant-again/</url>
      
        <content type="html"><![CDATA[<p>本文讨论了关于下采样所带来的平移等变性被破坏的情况，并提出通过整合经典的抗锯齿操作来提升网络的平移等变性，进而提升平移不变性。(在后面的层中，平移不变性等于平移等变性)</p><br><a id="more"></a><blockquote><p>这文章通篇证明了一件事：<strong>CNN 下采样导致的混叠会降低性能</strong>(之前也有文章说过)，我们建议在下采样之前加低通滤波。<br>文章的工作量很大，尤其是在很多应用方向都做了实验，说明了<strong>移不变的CNN可以在相关方向获得更好的性能</strong>。<br><a href="https://www.zhihu.com/question/329025043/answer/720840077" target="_blank" rel="noopener"><font color="purple">2019 年 ICML 有哪些糟糕的论文？ - SuperMHP的回答 - </font></a></p></blockquote><br><blockquote><p>先解释两个概念 平移不变性：指的是输入平移一定距离，最终的结果不变，分类里面就是分类的概率结果是不变的。 平移同变性：指的是输入平移一定距离，其对应的 feature 也做同样的平移。 本文主要是针对特征的平移同变性去解决问题，而<strong>实际上实现了特征的平移同变形，后面接的是 fc 层，最后一层的平移不变性是等价于平移同变性的，所以实现了特征的平移同变性就是实现了整个网络输出的平移不变性</strong>。例如，vgg 网络的最后两层是 fc 层和 softmax，显然 fc 层的 spatial dim 只有唯一一个元素(高维向量)，所以平移不变性和平移等变性在这一层是等价的。<br><a href="https://my.oschina.net/u/4357035/blog/3313711" target="_blank" rel="noopener"><font color="purple"> [论文理解] Making Convolutional Networks Shift-Invariant Again</font></a></p></blockquote><br><h1 id="0-abstract"><a class="markdownIt-Anchor" href="#0-abstract"></a> 0. Abstract</h1><ol><li>现代 CNN 没有移不变性，输入的很小的平移都可能造成输出的剧烈变化。</li><li>Pooling 和步长大于1的卷积等下采样手段，忽略了采样定理。<blockquote><p>个人理解这句话的意思是：pooling 和 strided-convolution 后的结果，不满足奈奎斯特采样定理，即输入频率较高，采样频率太低，造成信息损失很大。</p></blockquote></li><li>不能简单地在网络结构中插入低通滤波。</li></ol><br><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><ol><li>在对信号下采样前，对信号进行低通滤波来抗锯齿是教科书式的操作。</li><li>否则，高频分量会混叠进低频分量。（因为不满足采样定理）</li><li>早期网络采用的 average pooling 是一种形式的模糊后下采样。</li><li>经过观察，我们把 max pooling 分成 max 和 pooling 两步。</li><li>有一种担忧是，过度使用滤波会造成严重的信息损失，降低性能。</li><li>本文具体操作<ol><li>整合经典的抗锯齿操作来提高深度网络的<strong>平移等变性</strong>。</li><li>在不同网络结构上测试了 max pooling，average pooling, 带步长卷积 等下采样操作，并在不同任务上进行了测试。</li><li>发现增加了抗锯齿操作后，accuracy 不降反升，且泛化性能也更好了。</li></ol></li></ol><br><h1 id="2-related-work"><a class="markdownIt-Anchor" href="#2-related-work"></a> 2. Related Work</h1><ol><li>近来很多工作涉及了旋转，光照和尺度的不变性，这里我们专注于平移不变性。</li><li>Simioncelli 等人的工作认为，进行下采样时，严格意义的平移等变性 (shift-equivariance) 是不成立的。<ol><li>当特征被 densely extracted 时，平移等变性是可被恢复的。(意思是采样频率够高？)</li><li>深度网络也可以通过去除 stride 来达到 dense 的效果，但这会使计算量剧增，不合适。</li><li>因此，本文研究通过<strong>在下采样之前进行模糊</strong>的方法来提高平移等变性。</li></ol></li><li>早期网络是使用 average pooling 的，但是后来由于 max pooling 的效果更好，因此 max pooling 更流行。</li></ol><br><h1 id="3-methods"><a class="markdownIt-Anchor" href="#3-methods"></a> 3. Methods</h1><h2 id="31-preliminaries"><a class="markdownIt-Anchor" href="#31-preliminaries"></a> 3.1. Preliminaries</h2><ol><li>N-周期 平移不变性/等变性</li><li>环状卷积和平移来获取边界的内容。</li></ol><br><h2 id="32-anti-aliasing-to-improve-shift-equivariance"><a class="markdownIt-Anchor" href="#32-anti-aliasing-to-improve-shift-equivariance"></a> 3.2 Anti-aliasing to improve shift-equivariance</h2><ol><li>传统的降低空间分辨率的方法都会打破平移等变性。</li><li>将 max pooling 拆解为 max 和 pooling 两步操作。<ol><li>max 保留了 平移等变性。</li><li>后续 pooling 破坏了平移等变性。</li></ol></li><li>提出<ol><li>MaxPool -&gt; MaxBlurPool</li><li>StridedConv -&gt; ConvBlurPool</li><li>AveragePool -&gt; BlurPool</li></ol></li></ol><br><h1 id="4-experiments"><a class="markdownIt-Anchor" href="#4-experiments"></a> 4. Experiments</h1><h2 id="41-testbeds"><a class="markdownIt-Anchor" href="#41-testbeds"></a> 4.1. Testbeds</h2><ul><li>CIFAR Classification</li><li>ImageNet Classification</li><li>Conditional Image Generation</li></ul><br><h2 id="42-shift-invarianceequivariance-metrics"><a class="markdownIt-Anchor" href="#42-shift-invarianceequivariance-metrics"></a> 4.2. Shift-Invariance/Equivariance Metrics</h2><p>理想情况下，输入的偏移会导致特征图的相同偏移。评价指标为：</p><ul><li><strong>Internal feature distance.</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>S</mi><mi>h</mi><mi>i</mi><mi>f</mi><msub><mi>t</mi><mrow><mi>Δ</mi><mi>h</mi><mo separator="true">,</mo><mi>Δ</mi><mi>w</mi></mrow></msub><mo stretchy="false">(</mo><mover accent="true"><mi>F</mi><mo stretchy="true">~</mo></mover><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mover accent="true"><mi>F</mi><mo stretchy="true">~</mo></mover><mo stretchy="false">(</mo><mi>S</mi><mi>h</mi><mi>i</mi><mi>f</mi><msub><mi>t</mi><mrow><mi>Δ</mi><mi>h</mi><mo separator="true">,</mo><mi>Δ</mi><mi>w</mi></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it d(Shift_{\Delta{h},\Delta{w}}(\widetilde{F}(X)),  \widetilde{F}(Shift_{\Delta{h},\Delta{w}}(X)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.229438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">S</span><span class="mord mathit">h</span><span class="mord mathit">i</span><span class="mord mathit">f</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">Δ</span><span class="mord mtight"><span class="mord mathit mtight">h</span></span><span class="mpunct mtight">,</span><span class="mord mathit mtight">Δ</span><span class="mord mtight"><span class="mord mathit mtight">w</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94333em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">F</span></span></span><span class="svg-align" style="top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width="100%" height="0.26em" viewbox="0 0 600 260" preserveaspectratio="none"><path d="M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z"/></svg></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">X</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94333em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">F</span></span></span><span class="svg-align" style="top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width="100%" height="0.26em" viewbox="0 0 600 260" preserveaspectratio="none"><path d="M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z"/></svg></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">S</span><span class="mord mathit">h</span><span class="mord mathit">i</span><span class="mord mathit">f</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">Δ</span><span class="mord mtight"><span class="mord mathit mtight">h</span></span><span class="mpunct mtight">,</span><span class="mord mathit mtight">Δ</span><span class="mord mtight"><span class="mord mathit mtight">w</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">X</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></li><li><strong>Classification consistency</strong>: 同一张图做两种平移，输出同样结果的频率。</li><li><strong>Generation stability.</strong></li></ul><br><h2 id="43-internal-shift-equivariance"><a class="markdownIt-Anchor" href="#43-internal-shift-equivariance"></a> 4.3. Internal shift-equivariance</h2><p><img src="heatmap.png" alt="与完美平移不变性的偏差"></p><ul><li>内部特征距离被看作偏移量和层数的函数。</li><li>在第一次下采样 <code>max1</code> 前的所有层，都是平移等变的，一旦发生下采样 <code>pool1</code>，平移等变性就被破坏了。</li><li>但是，如 <code>pool1</code> 中的 stippling pattern 所示，N-周期的平移不变性仍然成立，且每下采样一次，N 翻番一次。</li><li>heatmap 中的每个像素代表一个偏移 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Δ</mi><mi>h</mi><mo separator="true">,</mo><mi>Δ</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\it \Delta{h}, \Delta{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathit">Δ</span><span class="mord"><span class="mord mathit">h</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">Δ</span><span class="mord"><span class="mord mathit">w</span></span></span></span></span></span></li><li>在 pool5, 分类器和 softmax 层中，等变性和不变性是一个东西，因为特征没有空间维度。</li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>How much Position Information Do Convolutional Neural Networks Encode?</title>
      <link href="/2021/03/19/Position-information-CNN-encode/"/>
      <url>/2021/03/19/Position-information-CNN-encode/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了关于论文 How much Position Information Do Convolutional Neural Networks Encode? 所表达的内容。</p><a id="more"></a><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/99766566" target="_blank" rel="noopener">CNN是怎么学到图片内的绝对位置信息的?</a></p><p>[2] <a href="https://zhuanlan.zhihu.com/p/265801525" target="_blank" rel="noopener">[论文分享]CNN中编码了多少位置信息？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> position </tag>
            
            <tag> CNN </tag>
            
            <tag> zero padding </tag>
            
            <tag> CoordConv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Why do deep convolutional networks generalize so poorly to small image transformations</title>
      <link href="/2021/03/19/CNN-generalize-poorly/"/>
      <url>/2021/03/19/CNN-generalize-poorly/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了关于论文 Why do deep convolutional networks generalize so poorly to small image transformations 所表达的内容。</p><a id="more"></a><blockquote><p>这篇文章实在是太难读了，看着非常不舒服！</p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/301522740/answer/531606623" target="_blank" rel="noopener"><font color="purple">既然cnn对图像具有平移不变性，那么利用 图像平移（shift）进行数据增强来训练cnn会有效果吗？ - Hengkai Guo的回答 - 知乎</font></a></p><p>首先，解释一下什么是CNN的<strong>平移不变性</strong>。简单来说，平移不变性（translation invariant）指的是CNN对于同一张图及其平移后的版本，都能输出同样的结果。这对于图像分类（image classification）问题来说肯定是最理想的，因为对于一个物体的平移并不应该改变它的类别。而对于其它问题，比如物体检测（detection）、物体分割（segmentation）来说，这个性质则不应该有，原因是当输入发生平移时，输出也应该相应地进行平移。这种性质又称为<strong>平移等价性</strong>（translation equivalence）。这两个概念是比较混淆的，但确实是两个不同的东西（敲黑板）。</p><p>那么，平移不变性是从哪里来的呢？一般来说，一个 CNN 的性质，要么是从它本身使用的<strong>结构</strong>得到的，要么是从它在数据集中学到的<strong>参数</strong>得到的。前者的简单例子是加了 sigmoid 层的网络的输出范围自然变成了<code>0</code>到<code>1</code>之间，后者的例子则是 CNN 在 ImageNet 上训练之后就有了能分类图像的能力且特征也具有一定的泛化性。</p><p>CNN 比较常见的层有卷积层、池化层（max 或者 mean）、全连接层，其中池化层又包括普通池化层和用在全连接层之前的全局池化层（global pooling）。按照市面上最常见的观点，CNN 本身结构中卷积+池化就具有平移不变性。本人并不同意这个观点，下面具体分析一下。</p><p>先来分析单层的情况。</p><p>(1) 卷积层：在信号处理中，卷积（以及相关）的性质包含了平移等价性。对于共享权值的卷积层来说，只在平移量为 stride 的整数倍时平移等价性才严格成立。而仅仅在卷积核比较均匀而且输入也有很多均匀区域的时候才有比较弱的平移不变性，因为此时微小的移动对于输出改变比较少。</p><p>(2) 池化层：普通池化层中，均值池化等价于固定卷积核的卷积层，因此性质也相同；最大值池化也类似，但取最大值的操作使其相对于均值带有更强的平移不变性。全局池化层将整个输入变成 <code>1x1</code> 大小的输出，忽略了特征的位置信息，当前面的输入具有平移等价性的时候具有比较强的平移不变性。</p><p>(3) 全连接层：全连接层这两个性质都没有，因为没有在不同位置共享权值，特征在不同位置对于输出的贡献变化很大。因此，从单层来看，只有全局池化有一定的平移不变性，其它都比较弱甚至没有。</p><p>如果把这些层串起来，那么在使用全连接层的时候整个CNN的结构一般不具有平移不变性。就算用了全局池化层，由于前面叠加的多层卷积层的累计效应，最后的平移不变性也很弱，只有当<strong>位移是整个网络的降采样倍数的整数倍</strong>才存在，概率很低。因此，能用于分类的平移不变性主要来源于参数。因为卷积层的平移等价性，这种平移不变性主要是由最后的全连接层来学习，而对于没有全连接层的网络更难有这种性质。</p><p>参数的学习需要数据，由于数据中平移的分布一般都比较不均匀，引入平移的数据增强（augmentation）肯定是必要的。那有人会问，为什么好像没看到有这个增强方式？其实裁切（crop）就是一种平移的数据增强方式，因为不同裁切方式对应的patch之间的变换就是平移。而且这种方式相比于平移更加自然，没有周围的黑边padding，因此更加常用。</p><p>总结起来，就是 <strong>CNN 的平移不变性主要是通过数据学习来的</strong>，结构只能带来非常弱的平移不变性，而学习又依赖于数据增强中的裁切，裁切相当于一种更好的图像平移。</p><p>最后再说点题外话。正是因为池化本身带有弱的平移不变性，且会损失一些信息，在对平移需要等价性的一些任务里（比如检测、分割）会经常用 stride 为 <code>2</code> 的卷积层来替代池化层。而在很多分类任务中，为了学习到一些全局特征，常常会在网络的最后使用全局池化或者金字塔池化的方式来消除平移的影响。</p></blockquote><br><h1 id="0-abstract"><a class="markdownIt-Anchor" href="#0-abstract"></a> 0. Abstract</h1><ul><li>以前以为 CNN 对小的图像变形具有不变性（结构或者数据增强的原因），但事实并非如此。</li><li>讨论了两种解决办法：<ul><li>Anti-alisaing</li><li>增加数据增强</li></ul></li><li>数据增强不会带来不变性，因为 CNN 只会学到对与数据集中非常相似的图的不变性。</li><li>结果表明，在保留高频信息的情况下，确保网络对小的变换的不变性的问题仍然没有得到解决。</li></ul><br><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><ul><li>机器学习方法的 <font color="purple" size="3"> <strong>归纳偏置</strong> </font> 是其成功的关键。</li><li>很显然，NN 中架构的选取对归纳偏置有重大影响。</li><li>归纳偏置的另一个来源是数据增强。</li><li>感觉，所谓归纳偏置，就是<strong>从现实生活中观察到的现象中归纳出一定的规则（heuristics） ，选择出更符合现实规则的模型。</strong></li><li>归纳偏置的一个来源就是<strong>网络的结构设计</strong>，卷积，池化的设计方式本身就引入了归纳偏置。比如卷积的局部链接和权值共享。</li><li>归纳偏置的另一个来源就是<strong>数据增强</strong>。通过剪切等变换处理过的图片就是告诉网络，发生了这些变换的图片依旧是与之前同一类别。</li></ul><br><h1 id="2-quantifying-the-lack-of-invariance-in-modern-cnns"><a class="markdownIt-Anchor" href="#2-quantifying-the-lack-of-invariance-in-modern-cnns"></a> 2. Quantifying the lack of invariance in modern CNNs</h1><p>基础实验：<br>从ImageNet测试集中随机选取一张图片，用四种方式对图片进行一个像素的扰动，测量网络的敏感程度。</p><ul><li>敏感程度的测量使用两种方法：<ul><li>P(Top-1 change): 一像素扰动后网络top-1预测发生改变的概率。<ul><li>它对网络最后一层输出的任何单调性变形都具有不变性。</li></ul></li><li>mean absolute change: 最高类别（即在两帧的第一帧中具有最高概率的类别）在发生一像素扰动后，网络计算出的概率的平均绝对变化。<ul><li>这个 metric 的作用是排除 top-1 预测的变化是由最可能类别和此可能类别之间的微小差别造成的可能性。</li></ul></li></ul></li><li>四种方式：<ul><li>在图像中随机截取一个框再 resize 到 224x224。再进行一个像素的对角线平移</li><li>embedding: 保持长宽比降采样到短边尺寸为 <code>100</code>，再随机嵌入到 224x224 图像中的随机位置，空余用黑色像素填充。再进行一个像素平移</li><li>类似第二种方法，但是用图像修复算法补全空余部分。</li><li>类似第二种方法，增大被嵌入图像一个像素单位。</li><li>优劣势：<ul><li>第一种方法可能导致重要信息丢失，平移后边缘信息会有区别。</li><li>第二种方法虽然保留了所有信息，但是可能引入非典型边界像素。</li></ul></li><li>带来的细微变化都是人类无法感知到的、可辨识度没有变化</li><li>景观变化是人类难以感知的，但模型预测类别变化的概率可以达到 <code>30%</code>，故此前论文中关于CNN缺乏不变性的报告不是偶然而是有着很高的出现频率。</li></ul></li><li>对于此结果的质疑可以是这些变换的图像在训练集中没有见过。引出两个对不变性的定义<ul><li>完全不变性：对任何模式以及其变换的形式输出相同的结果</li><li>部分不变性：在某种模式或与其类似的模式在训练集中出现的前提下，输出相同的结果。</li></ul></li><li>实验结果指明 CNN 并不具有完全不变性。</li></ul><br><h1 id="3-ignoring-the-sampling-theorem"><a class="markdownIt-Anchor" href="#3-ignoring-the-sampling-theorem"></a> 3. Ignoring the Sampling Theorem</h1><ul><li>Stride 永远是 1 的 CNN 是平移不变的.</li><li>如果对任何<code>x</code>来说，检测器在<code>x</code>位置的输出都可以被下采样网格中的响应线性插值恢复的话，那么下采样参数为<code>s</code>的特征检测器<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>可以被称为 shiftable.</li><li>VGG16 网络，表征向量似乎是跟随物体一起偏移的，包括最后一层。即使随后一层不是简单的原来响应的偏移，但是似乎是保留了这张图的全局和。</li></ul><p><img src="vgg.png" alt="vgg"></p><ul><li>当基于早期的层训练分类器时，一个像素的偏移导致输出改变的概率低于<code>5%</code>，但是当层数越来越深时，下采样操作和非线性会使得表征不再 shiftable, 网络也丢失了不变性。</li></ul><p><img src="depth.png" alt="不同深度的层由于像素偏移造成的输出改变"></p><ul><li>非线性操作可能带来输入中所不具有的高频</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathit">r</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span> 是先下采样（采样率<code>s</code>），然后经过一系列卷积和非线性操作的结果。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn mathvariant="italic">2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r_2(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathit">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span> 是不下采样，直接进行同样的卷积和非线性操作（所有的卷积核都是空洞率为 <code>s</code>）。对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn mathvariant="italic">2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r_2(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathit">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span> 下采样（采样率为<code>s</code>）得到的结果就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></li><li>对 CNN 中一个 stride 为 <code>s</code> 的层，对任何后面的层，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathit">r</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span>, 试想一个等价于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn mathvariant="italic">2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r_2(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathit">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span> 的层，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn mathvariant="italic">2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r_2(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathit">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span> 包含超过奈奎斯特频率 <code>s</code> 的频率，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathit">r</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span> 则不是 shiftable 的。</li></ul><br><h1 id="4-why-dont-modern-cnns-learn-to-be-invariant-from-data-augmentation"><a class="markdownIt-Anchor" href="#4-why-dont-modern-cnns-learn-to-be-invariant-from-data-augmentation"></a> 4. Why don’t modern CNNs learn to be invariant from data augmentation?</h1><ul><li>CNN的结构不能带来平移不变性，但是通过训练样本来学习到平移不变性还是有可能的。</li><li>这可以通过网络学习到能量集中在低频的 filter 来实现。</li><li>使用数据增强训练得到这样的 filter 是可以期待的。</li><li>数据增强使用了很多随机 crop 的图像，所以网络有同样的概率看到一张图以及它的平移一个像素的版本。为什么这样不能使得网络学到一个对一个像素偏移具有不变性的判别函数呢？<ul><li>一个可能的原因是网络只能学到对数据集里存在的图的不变性。网络的泛化性能可能只能泛化到跟训练集里图像比较相似的图像。</li></ul></li><li>如果CNN中大多数的平移不变性是网络在训练时学到的<strong>部分平移不变性</strong>的话，那么网络对大的嵌入图像应该更平移不变，对小的嵌入图像不那么平移不变。图6证实了这点</li></ul><p><img src="embedding.png" alt="不同embedding window size造成的不同程度的不变性"></p><br><h1 id="5-possible-solutions"><a class="markdownIt-Anchor" href="#5-possible-solutions"></a> 5. Possible Solutions</h1><h2 id="51-antialiasing"><a class="markdownIt-Anchor" href="#51-antialiasing"></a> 5.1 Antialiasing</h2><h2 id="52-increased-data-augmentation"><a class="markdownIt-Anchor" href="#52-increased-data-augmentation"></a> 5.2 Increased Data Augmentation</h2><h2 id="53-reducing-subsampling"><a class="markdownIt-Anchor" href="#53-reducing-subsampling"></a> 5.3 Reducing subsampling</h2><br><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/50222337" target="_blank" rel="noopener">难以泛化的卷积神经网络</a></p><p>[2] <a href="https://lossherl.github.io/2020/04/28/2019%20Why%20do%20deep%20convolutional%20networks%20generalize%20so%20poorly%20to%20small%20image%20transformation/" target="_blank" rel="noopener">Why do deep convolutional networks generalize so poorly to small image transformation?</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> generalize </tag>
            
            <tag> transformation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】谈谈CNN中的位置和尺度问题</title>
      <link href="/2021/03/18/Location-and-scale-in-CNN/"/>
      <url>/2021/03/18/Location-and-scale-in-CNN/</url>
      
        <content type="html"><![CDATA[<p>在知乎上看到一篇关于 CNN 的平移不变性和平移等变性以及 CNN 对位置和深度信息预测的文章，觉得很有收获，因此转载在这里。里面也会穿插自己的理解。</p><a id="more"></a><p><strong>提示：</strong><br>转载文章中与不变性同时提到的 相等性（equivalence）其实是作者的错误，在图像中，一般同时出现的是 不变性(invariance) 和 等变性(equivariance)。而不是这里所说的相等性(equivalence)。</p><p><strong>个人总结:</strong></p><blockquote><ul><li>Making Convolutional Networks Shift-Invariant Again:<ul><li>窗户实验表明<strong>传统的CNN网络并不具有平移不变性</strong>。</li><li>Max pooling 及 <code>stride&gt;1</code> 的卷积等操作涉及下采样，此操作对平移等变性影响更大。</li><li>提出 Anti aliasing 方法，在下采样前进行 blur 操作，即进行低通滤波，降低输入内容的频率。</li></ul></li><li>Why do deep convolutional networks generalize so poorly to small image transformations：<ul><li>作者发现<ul><li>较小的图像变换或缩放导致网络的预测结果变换极大。</li></ul></li><li>作者认为<ul><li>卷积架构忽视了传统的采样定理。</li><li>数据增强仅能让CNN对类似训练集中的变换具有不变性。</li></ul></li></ul></li><li>How much Position Information Do Convolutional Neural Networks Encode <a href="//2021/03/19/Position-information-CNN-encode/" title="详细内容">详细内容</a><br>提出结论<ul><li>位置信息是 zero-padding 透露的</li></ul></li><li>How Do Neural Networks See Depth in Single Images<br>实验发现<ul><li>CNN 网络是通过目标纵坐标来估计深度的</li><li>由于深度与目标纵坐标有关系，那么 pitch 角的影响很大</li><li>相对的，roll 的影响就比较小了</li></ul></li><li>On Translation Invariance in CNNs: Convolutional Layers can Exploit Absolute Spatial Location</li></ul></blockquote><br>以下为正文：<br><h1 id="1-cnn是否存在平移和尺度的不变性和相等性"><a class="markdownIt-Anchor" href="#1-cnn是否存在平移和尺度的不变性和相等性"></a> 1. CNN是否存在平移和尺度的不变性和相等性</h1><h2 id="11-不变性和相等性的定义"><a class="markdownIt-Anchor" href="#11-不变性和相等性的定义"></a> 1.1 不变性和相等性的定义</h2><p>在介绍卷积神经网络（CNN）之前，我们对于不变性和相等性的理解可能来自于传统图像处理算法中的，平移、旋转、光照和尺度等不变性，比如 HOG 梯度方向直方图，由于<code>cell</code>的存在，其对于平移、旋转有一定的不变性，另外由于对图像局部对比度归一化的操作，使其对于光照也有着一定的不变性。又比如说 SIFT 特征提取，其对于以上四点都有着不变性，其中由于尺度金字塔，使得对尺度也有不变性。这里我们对于不变性的理解就是，同一对象发生平移、旋转、光照变化、尺度变换甚至形变等，其属性应该一致。下面我们给出具体的不变性和相等性的定义。</p><p>其中不变性（invariance）的定义正如上文所说，因此其形式为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">[</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F(x)=F[transform(x)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p><p>而对于相等性（equivalence），顾名思义，就是对输入进行变换之后，输出也发生相应的变换：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mo stretchy="false">[</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mi>F</mi><mo stretchy="false">[</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">transform[F(x)]=F[transform(x)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p><p>不过如果我们只考虑输出对于输入不变性和相等性的情况，则会难以理解，因为我们更多地是想象着特征层面的映射，比如：</p><p><img src="invariance-equivalence.jpg" alt="不变性和等变性"></p><p>那么特征层面对于输出的影响我们可能考虑得比较少，但是却实质存在，比如目标在图像中的平移和尺度等变换，<strong>在目标检测任务中，必须要使得网络具有相关的变换相等性，由此捕捉目标的位置和形状变化</strong>。<strong>而在图像分类、目标识别、行人重识别等任务中，又必须使得网络具有相关变换的不变性</strong>。这两点也是目标检测和行人检索领域中一个经典的矛盾问题，目前好像还没有特别好的解决，更多地是分阶段地执行不同的任务，防止特征共用。比如：经典的两阶段目标检测任务中，第一阶段是粗检测和前景背景分类，第二阶段是精修和具体类别分类，有一定的偏重。行人检索算法则大多是先检测后识别的策略。当然除了不变性和相等性的问题，还存在类内差异的问题，比如不同的人对于检测而言都是行人类别，对于识别而言则是不同的人，这对于特征提取也存在挑战。</p><blockquote><p><font color="orange">这部分观点应该是来自 DCNv2 </font></p></blockquote><br><h2 id="12-cnn网络的执行过程"><a class="markdownIt-Anchor" href="#12-cnn网络的执行过程"></a> 1.2 CNN网络的执行过程</h2><p>我记得我几年前第一次接触到深度学习的时候，对于全连接和 CNN 的局部连接形式，都有平移、尺度不变性的说法。对于全连接网络，由于下一层的每个节点都会与上一层进行连接：</p><p><img src="fc.jpg" alt="全连接网络"></p><p>因此无论输入发生了平移、尺度等什么变换，只要其属性没变，全连接网络更能捕捉其中的不变性。而对于卷积神经网络，我们都知道两个特点：局部连接和权值共享。</p><p><img src="cnn.jpg" alt="卷积神经网络和全连接网络对比"></p><p>对于局部连接，因为全连接参数太多，容易造成过拟合，并且图像领域更多地关注局部细节信息，所以局部连接方式有效。至于权值共享，也有减少参数的作用，很像图像处理中的滤波器。我们早期对于其不变性的理解更多是遵循一个宏观的感受，即由于卷积核的移位滤波，上一层的特征到下一层的特征相对位置 <strong>宏观不变</strong>，直到最后输出，类似于全连接的效果，从而获得不变性。</p><br><h2 id="13-cnn网络潜在问题与改进"><a class="markdownIt-Anchor" href="#13-cnn网络潜在问题与改进"></a> 1.3 CNN网络潜在问题与改进</h2><p>正因为我刚说的宏观不变，使得输入在经过多次卷积、池化之后，微观/细节的变化累积放大，从而失去了这种不变性，接下来我会结合两篇论文进行介绍。</p><p>第一个是为了解决 CNN 平移不变性对抗性攻击的一篇 ICML2019 论文《<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1904.11486.pdf%3Ffbclid%3DIwAR1VRPIrctulC6EhTAhKFjIFrlx_JjKR09JnESzLELUnlTL40iOT5tYwotA" target="_blank" rel="noopener">Making Convolutional Networks Shift-Invariant Again</a>》。这篇文章主要讨论了CNN网络中的降采样对于平移不变性的影响：</p><p><img src="window1.jpg" alt=""></p><p>上图是对于一个窗户分别采用从<code>0~7</code>的平移量，其特征图与不平移的差异，可以明显看到，特征图出现了波动。相应地，上半部分是利用 pix2pix 生成的图像，我们可以看到随着平移量的增大，窗户中的竖直线从两根变成了一根。<font color="red"> <strong>这一点就表明传统的 CNN 网络并不具有平移不变性。</strong></font></p><p>首先，作者做了这样一个小实验，即采用 max pooling 对一维向量<code>[0011001100]</code>进行池化，由此得到向量<code>[01010]</code>：</p><p><img src="experiment.jpg" alt="小实验"></p><p>接着，如果将输入向右平移一个单位，则得到向量<code>[111111]</code>：</p><p><img src="res.jpg" alt="小实验结果"></p><p>很明显，<strong>平移相等性和不变性都丢失了</strong>。接着作者做了进一步实验，利用余弦距离来刻画平移相等性，采用 VGG 网络对 Cifar 数据集进行试验：</p><p><img src="experiment2.jpg" alt=""></p><p>其中颜色越深说明差异越大，可以看到每次 max pooling 都增加了特征的差异性，不过作者将 max 和 pool 操作分开了，为了区分取最大值和降采样的影响：</p><p><img src="maxpooling.jpg" alt=""></p><p>很明显，<strong>降采样对于平移相等性的影响更大</strong>，而 CNN 中涉及到降采样的操作有：池化（max pooling 和 average pooling）和带步长的卷积（strided convolution）。对此作者提出了一种名为 <strong>Anti_aliasing</strong> 方法，中文叫做抗锯齿处理。传统信号处理领域中对于抗锯齿的技术，一般要么增大采样频率，但由于图像处理任务一般都需要降采样，这一点不适合。要么采用图像模糊（bluring）技术，<font color="orange"><em>根据 Nyquist 采样理论，是给定采样频率，通过降低原始信号的频率来使得信号能够被重构出来</em> </font>，如下图所示。对模糊化处理和未处理的原图像进行下采样，得到图中底部的两张图，模糊化处理的原图像下采样的图像还能看出一些轮廓，而未处理的原图像下采样的图像就显得更加混乱。</p><blockquote><p><font color="orange"><strong>对橙色部分的理解：</strong></font> 在信号处理中，根据 奈奎斯特 采样定理，如果采样频率大于信号最大频率的两倍，则原始信号能够被完全恢复出来。在这里，pooling 就是一种下采样的过程，当其参数固定后，相当于其采样频率也是固定的。在原图中，有很多边缘等细节，属于高频内容。因此，如果直接对其进行 pooling，也就是下采样，则采样频率无法达到原图最大频率的两倍，从而无法恢复出原图内容。这时，可以逆向思维，通过降低原图的频率，则相对地提高了 pooling 的采样频率。因此，先对原图进行一次低通滤波，也就是模糊处理，来降低它的频率，这样，经过 pooling 下采样后的图像就相对原图下采样的结果可理解了很多。<br>关于图像滤波的内容，可以参考 <a href="//2021/03/18/Image-and-Filtering/" title="【转载】图像与滤波">【转载】图像与滤波</a></p></blockquote><p><img src="blur.jpg" alt="原图下采样和模糊后图像下采样对比"></p><p>作者就是采用了模糊的方式，提出了三种不同的 blur kernel：</p><ul><li>Rectangle-2：<code>[1, 1]</code>，类似于均值池化和最近邻插值；</li><li>Triangle-2：<code>[1, 2, 1]</code>，类似于双线性插值；</li><li>Binomial-5：<code>[1, 4, 6, 4, 1]</code>，这个被用在拉普拉斯金字塔中。</li></ul><p>每个核都需要归一化，即除以核内所有元素之和，然后加入到降采样过程，即在降采样之前使用 blur kernel 进行卷积滤波：</p><p><img src="aa.jpg" alt=""></p><p>可以看到其效果很不错：</p><p><img src="res1.jpg" alt="实验效果"></p><p><img src="table1.jpg" alt="实验结果"></p><p>代码和模型见：<a href="https://richzhang.github.io/antialiased-cnns/" target="_blank" rel="noopener">https://richzhang.github.io/antialiased-cnns/</a>或者<a href="https://github.com/adobe/antialiased-cnns" target="_blank" rel="noopener">https://github.com/adobe/antialiased-cnns</a></p><br><p><strong>第二篇</strong>是同年发表在 JMLR 的一篇论文《<a href="https://link.zhihu.com/?target=http%3A//www.jmlr.org/papers/volume20/19-519/19-519.pdf" target="_blank" rel="noopener">Why do deep convolutional networks generalize so poorly to small image transformations?</a>》。作者首先给出了几组示例，分别表示了平移、尺度以及轻微图像差异对网络预测分类置信度的影响：</p><p><img src="transformation.jpg" alt="平移、尺度和轻微图像差异对预测分类置信度的影响"></p><p>作者认为 CNN 忽视了采样定理，这一点之前 Simoncelli 等人已经在论文 Shiftable multiscale transforms 中验证了二次采样在平移不变性上的失败，他们在文中说：</p><blockquote><p>我们不能简单地把系统中的平移不变性寄希望于卷积和二次采样，输入信号的平移不意味着变换系数的简单平移，除非这个平移是每个二次采样因子的倍数。</p></blockquote><p>我们现有的网络框架中，越深的网络，降采样次数越多，因此出现的问题更多。紧接着，作者提出了几点论述：</p><ul><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 是经过卷积操作且满足平移不变性的特征，那么全局池化操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∑</mo><mi>i</mi></msub><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_i r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 也满足平移不变性；</li><li>对于特征提取器 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 和降采样因子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> ，如果输入的平移都可以在输出上线性插值反映出来：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mi>i</mi></munder><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>r</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i}B(x-x_i)r(x_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.327674em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>由香农-奈奎斯特定理知， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 满足可移位性，要保证采样频率至少为最高信号频率的2倍。</p><p>接下来，作者对这些问题做了一些改进尝试：</p><ul><li><strong>抗锯齿</strong>，这个就是我们刚刚介绍的方法；</li><li><strong>数据增强</strong>，当前在很多图像任务中，我们基本都会采用随机裁剪、多尺度、颜色抖动等等数据增强手段，的确也让网络学习到了部分不变性；</li><li><strong>减少降采样</strong>，也就是说只依赖卷积对于输入尺度的减小来变化，这一点只对小图像适用，主要是因为计算代价太高。</li></ul><br><h1 id="2-cnn对于位置和深度信息的预测"><a class="markdownIt-Anchor" href="#2-cnn对于位置和深度信息的预测"></a> 2. CNN对于位置和深度信息的预测</h1><h2 id="21-cnn如何获取目标的位置信息"><a class="markdownIt-Anchor" href="#21-cnn如何获取目标的位置信息"></a> 2.1 CNN如何获取目标的位置信息</h2><p>最早接触神经网络和深度学习相关任务时，我的感觉就是这类算法本质是做的分类任务，比如图像分割是对前景背景的分类和具体类别分类，识别任务就是类间类内的区分任务。其中图像分割任务就利用了 CNN 中的部分相等性，那么对于目标检测任务中的目标位置回归是怎么获取的呢？我们可以知道的是同样是对目标位置的搜索，在单目标跟踪任务中，存在有置信图：</p><p><img src="confmap.png" alt="置信图"></p><p>但是置信图本质上是对区域进行搜索得到的，因此可以近似为对多个子区域的识别过程，所以单目标跟踪中的目标定位也可以用分类的理解，但是目标检测则不好用分类来理解了。</p><p>接下来我们思考一个问题，我们所设计的网络究竟包含了哪些信息？图像特征、网络结构（卷积核大小、padding）。从上一章我们可以知道，网络可以学习到一定的相等性：</p><p><img src="vgg16.jpg" alt=""></p><p>因此，通过不断地训练，<font color="orange"><em>网络在最后的特征输出中是可以通过对应的特征数值和区域大小，结合一定的倍数（降采样大小）估计目标尺度的</em>。</font>但是对于目标的位置，我们人眼对于目标位置的判定是通过坐标系的，即目标距离图像的边缘距离，但是网络是如何了解这一信息的呢？</p><blockquote><p><font color="orange">对橙色部分的理解:</font>对一个物体的检测包括两个部分，位置(x,y)和尺度(w,h)，这里所说的，就是如何从网络的输出特征中计算得到目标的尺度的。这里认为，通过 对应的特征数值（即找到激活区域）和 区域大小 （激活区域的大小），结合一定的倍数 (feature map 相对于原图降采样的倍数)，可以估计出目标在原图的尺度。</p></blockquote><br><p>《How much Position Information Do Convolutional Neural Networks Encode?》这篇文章做出了回答。</p><p>作者首先做了一组实验：</p><p><img src="hvg.jpg" alt=""></p><p>对于不同的输入图像，采用多种 mask 扰动，H、V、G 分别代表水平、竖直和高斯等分布，用这种方式生成多种 groundtruth，对于这点我们可能对单目标跟踪中以目标中心为均值的高斯分布比较熟悉。结果发现：</p><p><img src="hvg2.jpg" alt=""></p><p>GT 是三种分布生成的 groundtruth，PosENet 是作者提出的网络，没有 padding。我们可以看到 PosENet 并没有得到位置分布信息，而是保持了相等性。而存在 padding 的 VGG 和 ResNet 则都预测出了位置分布。由此可见 padding 对于位置的作用，也对上一章的内容作了补充，padding 对于平移不变性和相等性也有影响。</p><p>不过这里我们可能不好理解，我做了个小测试，不过不一定是这么做的，仅仅方便我理解：</p><p><img src="equation.svg" alt=""></p><p>上面是两个不同位置“目标”的卷积结果，可以看到，从输出结果得不到什么位置反映，如果加入 padding：</p><p><img src="equation2.svg" alt=""></p><p>首先我们可以知道的是，加入了 zero-padding 之后，目标边缘相对中心的输出更小了，其次目标距离图像边缘距离越远，其特征映射中出现<code>0</code>的次数越多。所以我猜网络就是在训练过程中让 padding 和这个相对的关系对应上了，如果没有 padding，目标距离边缘越远，同样出现<code>0</code>的次数也会越多，但问题在于无法跟 padding 造成的边缘数值小，中心数值大的特殊分布相比。当然，以上仅仅是我个人的理解，为了帮助我加深印象罢了。也有人说加入了 padding 影响了 CNN 的平移相等性，从而使得 CNN 学到了位置信息，但这个不大好解释。</p><p>不过有关 padding 的问题，在 CVPR2019 的一片单目标跟踪算法 SiamRPN++ 中也做了探讨。其出发点在于为何 Siamese 网络无法扩展为大型网络，其原因就在于 padding 影响了平移相等性，从而让目标位置的分布发生了偏移。所以作者通过对目标中心的随机扰动，使得网络克服自身的偏移：</p><p><img src="shift.jpg" alt=" "></p><p>也有一些研究探索了如何让 CNN 结合绝对位置信息，比较出名的应该是当前很热门的 SOLO 单阶段实例分割算法。SOLO 的出发点很简单，我们都知道语义分割只需要分割出不同类别的目标，而实例分割对于同一类别的个体还需要区分。但是显而易见，同一类别的目标只要位置和形状不同则可以区分。因此 SOLO 就是将位置和形状（用尺寸简化）信息结合进来。具体而言，就是将输入系统的图像统一划分为 S\timesS 的网格，如果对象的中心落入网格单元，那么这个网格单元就负责预测语义类别以及分割该对象实例。</p><p><img src="solo.jpg" alt="SOLO"></p><p>特别地，SOLO 算法中采用 CoordConv 策略（代码：<a href="https://github.com/uber-research/coordconv" target="_blank" rel="noopener">https://github.com/uber-research/coordconv</a>），该算法将每个特征区域的坐标信息结合进来，从而让网络显示地学会记忆特征的绝对位置信息。SOLO 通过这个策略提升了 <code>3.6AP</code>，并且论证只需要一层提供该信息即可达到稳定的提升。</p><p><img src="coordconv.jpg" alt="CoordConv引入了每个像素的绝对坐标"></p><br><h2 id="22-cnn如何预测目标的深度信息"><a class="markdownIt-Anchor" href="#22-cnn如何预测目标的深度信息"></a> 2.2 CNN如何预测目标的深度信息</h2><p>深度估计也是一个类似的问题，不同的是，图像中并没有包含深度信息，但是网络是如何获取深度信息的呢。How Do Neural Networks See Depth in Single Images?这篇文章给出了回答，关于这篇文章 NaiyanWang 老师已经在博客里讨论过，我这里也就再整理下。</p><p><img src="camera.jpg" alt=""></p><p>我们可以看到，物体的绝对深度与相机位姿有着很大关系，那么 CNN 如何学习到这种需要几何先验的绝对信息的呢？作者做了这样一个实验：</p><p><img src="depth.jpg" alt=""></p><p>上图中作者做了三组实验：同时变化目标位置和尺寸、只变化位置以及只变化尺寸，我们从上面的定性结果好像看不出什么问题，下面是定量的结果：</p><p><img src="ana.jpg" alt="定量分析结果"></p><p>可以发现，尺度对于深度信息的预测没有什么影响，也就是说<font color="red"><strong>CNN网络是通过目标纵坐标来估计深度的</strong></font>，所以说网络实际上是在过拟合训练集，从中学习到一些固定场景下的深度和相对位置的对应关系。</p><p>作者又讨论了相机运动对于深度预测的影响，既然深度与目标纵坐标有关系，那么 pitch 角的影响应该很大：</p><p><img src="pitch.jpg" alt="pitch俯仰角的影响较大"></p><p>可以发现，<strong>pitch的确影响比较大</strong>，相对的, roll 的影响就比较小了：</p><p><img src="roll.jpg" alt="roll翻滚角的影响较小"></p><p>最后作者还讨论了颜色和纹理对深度估计的影响：</p><p><img src="texture.jpg" alt="颜色和纹理对深度估计的影响"></p><p>可以发现，<strong>仅仅是改变目标的颜色纹理，深度估计的效果也会下降</strong>，可将CNN网络在训练时有多“偷懒”，不知道如果将上述实验变成数据增强的手段的话会让深度估计网络失效还是变强。</p><br><h1 id="2020318更新"><a class="markdownIt-Anchor" href="#2020318更新"></a> 2020.3.18更新</h1><p>昨天碰巧看到一篇 CVPR2020 的文章《On Translation Invariance in CNNs: Convolutional Layers can Exploit Absolute Spatial Location》，其中也提到了 CNN 中的平移不变性问题和绝对位置信息编码问题，其切入点是 CNN 中的边界问题。</p><p>作者首先以三种卷积方式为例，full/same/valid，各自的区别在于 padding 的大小，具体方式我就不细说了，给个示意图：</p><p><img src="padding.jpg" alt=""></p><p><img src="1dpadding.jpg" alt=""></p><p>其中红色部分表示 padding，绿色部分表示边界区域。很明显，<code>valid</code>模式下卷积核最右边的<code>1</code>永远无法作用于绿色部分的<code>1</code>，<code>same</code>模式下的卷积核最右边 <code>1</code>永远无法作用于绿色部分的<code>1</code> 。作者以 <code>zero-padding</code> 和<code>circular-padding</code> 两种模式做了一个例子说明：</p><br><p><img src="compare.jpg" alt=""></p><p>可以看到 Class-1 中前两个例子都没有检测到<code>1</code>，<code>valid</code> 和 <code>same+zero-padding</code> 模式对于待卷积区域的绝对位置比较敏感。紧接着作者又分析了每个位置被卷积的次数：</p><p><img src="equation3.svg" alt=""></p><p>由此引出距离图像边界多远时某一固定像素可以被检测到这一问题，于是作者通过给图片四周添加不同大小的黑色边界进行试验：</p><p><img src="border.jpg" alt=""></p><p>有意思的是，<strong>增加了黑色边界之后分类的准确率都出现了明显的下滑，只不过不同的训练策略和不同的 backbone 的抗干扰能力不同罢了。</strong></p><p><img src="border_result.jpg" alt=""></p><p>为了定量分析各个卷积策略对于边界的处理区别，建了一个分类数据集，特殊点都分布在边界：</p><p><img src="dataset.jpg" alt=""></p><p>结果差别很大：</p><p><img src="res2.jpg" alt=""></p><p>可以发现，跟之前的观察结果一样，前两种策略的泛化能力很差，而基于 <code>Circular padding</code> 和 <code>full convolution</code> 的模式效果最好。接着作者为了降低边界的影响，采用了前文介绍卷积平移不变性里面提到的 <code>blur pooling+Tri3</code> 卷积核。然后对比 S<code>-conv+circular padding</code> 和 <code>F-conv</code> 两种策略对于不同的图像对角平移的鲁棒性：</p><p><img src="ana2.jpg" alt=""></p><p><img src="res3.jpg" alt=""></p><p>结果显示 <strong>Full conv 模式效果更好</strong>，在后续实验中还说明了其有助于降低过拟合风险，对于小数据集更有效。</p><p>代码即将开源 <a href="https://link.zhihu.com/?target=https%3A//github.com/oskyhn/CNNs-Without-Borders" target="_blank" rel="noopener">https://link.zhihu.com/?target=https%3A//github.com/oskyhn/CNNs-Without-Borders</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 平移不变性 </tag>
            
            <tag> 平移等变性 </tag>
            
            <tag> translation invariance </tag>
            
            <tag> translation equivalence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】图像与滤波</title>
      <link href="/2021/03/18/Image-and-Filtering/"/>
      <url>/2021/03/18/Image-and-Filtering/</url>
      
        <content type="html"><![CDATA[<p>看到了一篇关于图像滤波的文章，详细地解释了从波和信号处理的角度来理解图像。</p><p>以下为原文。</p><a id="more"></a><hr><p>前几天读到一篇<a href="https://medium.com/statuscode/filtering-images-using-web-audio-api-276555cca6ad" target="_blank" rel="noopener">文章</a>，它提到<strong>图像其实是一种波，可以用波的算法处理图像</strong>。我顿时有一种醍醐灌顶的感觉，从没想到这两个领域是相关的，图像还可以这样玩！下面我就来详细介绍这篇文章。</p><h1 id="一-为什么图像是波"><a class="markdownIt-Anchor" href="#一-为什么图像是波"></a> 一、为什么图像是波？</h1><p>我们知道，图像由像素组成。下图是一张 400 x 400 的图片，一共包含了 16 万个像素点。<br><img src="pic1.jpg" alt="lena"><br>每个像素的颜色，可以用红、绿、蓝、透明度四个值描述，大小范围都是<code>0 ～ 255</code>，比如黑色是<code>[0, 0, 0, 255]</code>，白色是<code>[255, 255, 255, 255]</code>。通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas" target="_blank" rel="noopener">Canvas API</a> 就可以拿到这些值。</p><p>如果把每一行所有像素（上例是400个）的红、绿、蓝的值，依次画成三条曲线，就得到了下面的图形。<br><img src="wave1.png" alt="RGB像素值变化"><br>可以看到，每条曲线都在不停的上下波动。有些区域的波动比较小，有些区域突然出现了大幅波动（比如 54 和 324 这两点）。</p><p>对比一下图像就能发现，曲线波动较大的地方，也是图像出现突变的地方。<br><img src="wave2.png" alt="原图与曲线波动较大地方的对应"><br>这说明波动与图像是紧密关联的。<strong>图像本质上就是各种色彩波的叠加。</strong></p><h1 id="二-频率"><a class="markdownIt-Anchor" href="#二-频率"></a> 二、频率</h1><p>综上所述，<strong>图像就是色彩的波动：波动大，就是色彩急剧变化；波动小，就是色彩平滑过渡。因此，波的各种指标可以用来描述图像。</strong></p><p>频率（frequency）是波动快慢的指标，单位时间内波动次数越多，频率越高，反之越低。<br><img src="wave3.jpg" alt="正弦波"><br>上图是函数 <code>sin(Θ)</code> 的图形，在 <code>2π</code> 的周期内完成了一次波动，频率就是1。<br><img src="wave4.jpg" alt="2倍频率"><br>上图是函数<code>sin(2Θ)</code>的图形，在<code>2π</code>的周期内完成了两次波动，频率就是2。</p><p>所以，<strong>色彩剧烈变化的地方，就是图像的高频区域；色彩稳定平滑的地方，就是低频区域</strong>。</p><h1 id="三-滤波器"><a class="markdownIt-Anchor" href="#三-滤波器"></a> 三、滤波器</h1><p>物理学对波的研究已经非常深入，提出了很多处理波的方法，其中就有滤波器（filter）：过滤掉某些波，保留另一些波。</p><p>下面是两种常见的滤波器 。</p><blockquote><ul><li>低通滤波器（lowpass）：减弱或阻隔高频信号，保留低频信号</li><li>高通滤波器（highpass）：减弱或阻隔低频信号，保留高频信号</li></ul></blockquote><p>下面是低通滤波的例子。<br><img src="lowpass.png" alt="低通滤波"><br>上图中，蓝线是原始的波形，绿线是低通滤波 <code>lowpass</code> 后的波形。可以看到，绿线的波动比蓝线小很多，非常平滑。</p><p>下面是高通滤波的例子。<br><img src="highpass.png" alt="高通滤波"></p><p>上图中，黄线是原始的波形，蓝线是高通滤波 <code>highpass</code> 后的波形。可以看到，黄线的三个波峰和两个波谷（低频波动），在蓝线上都消失了，而黄线上那些密集的小幅波动（高频波动），则是全部被蓝线保留。</p><p>再看一个例子。<br><img src="examp1.png" alt=""><br>上图有三根曲线，黄线是高频波动，红线是低频波动。它们可以合成为一根曲线，就是绿线<br><img src="examp2.png" alt=""><br>上图中，绿线进行低通滤波和高通滤波后，得到两根黑色的曲线，它们的波形跟原始的黄线和红线是完全一致的。</p><h1 id="四-图像的滤波"><a class="markdownIt-Anchor" href="#四-图像的滤波"></a> 四、图像的滤波</h1><p>浏览器实际上包含了滤波器的实现，因为 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" target="_blank" rel="noopener">Web Audio API</a> 里面定义了<a href="https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode/type" target="_blank" rel="noopener">声波的滤波</a>。这意味着可以通过浏览器，将 <code>lowpass</code> 和 <code>highpass</code> 运用于图像。</p><p><code>lowpass</code> 使得图像的高频区域变成低频，即色彩变化剧烈的区域变得平滑，也就是出现模糊效果。<br><img src="lena2.jpg" alt="低通使图像产生模糊的效果"><br><img src="res1.png" alt="低通后的曲线"><br>上图中，红线是原始的色彩曲线，蓝线是低通滤波后的曲线。</p><p><code>highpass</code> 正好相反，过滤了低频，只保留那些变化最快速最剧烈的区域，也就是图像里面的物体边缘，所以常用于边缘识别。<br><img src="lena3.jpg" alt="高通使图像保留边缘"><br><img src="res2.png" alt="高通后的曲线"></p><p>上图中，红线是原始的色彩曲线，蓝线是高通滤波后的曲线。</p><p>下面这个<a href="http://fellipe.com/demos/lena-js/" target="_blank" rel="noopener">网址</a>，可以将滤波器拖到图像上，产生过滤后的效果。<br><img src="webtool.jpg" alt="网页工具"></p><p>浏览器实现滤波的范例代码，可以看这个<a href="https://github.com/rssilva/web-audio-image-filtering" target="_blank" rel="noopener">仓库</a>。</p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="http://www.ruanyifeng.com/blog/2017/12/image-and-wave-filters.html" target="_blank" rel="noopener">图像与滤波</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 图像 </tag>
            
            <tag> 滤波 </tag>
            
            <tag> filter </tag>
            
            <tag> 高通滤波器 </tag>
            
            <tag> 低通滤波器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匈牙利算法</title>
      <link href="/2021/03/08/Hungarian-algorithm/"/>
      <url>/2021/03/08/Hungarian-algorithm/</url>
      
        <content type="html"><![CDATA[<p>一些有关匈牙利算法的文章。</p><a id="more"></a><p><a href="https://blog.csdn.net/u013384984/article/details/90718287" target="_blank" rel="noopener">匈牙利算法-看这篇绝对就够了！</a></p><p><a href="https://blog.csdn.net/C20180630/article/details/70175814" target="_blank" rel="noopener">二分图匹配——匈牙利算法和KM算法</a></p><p><a href="https://blog.csdn.net/u013384984/article/details/90718287" target="_blank" rel="noopener">趣写算法系列之–匈牙利算法</a></p><h3 id="矩阵处理相关代码可以看-sklearn-中的-linear_assignmentpy"><a class="markdownIt-Anchor" href="#矩阵处理相关代码可以看-sklearn-中的-linear_assignmentpy"></a> 矩阵处理相关，代码可以看 sklearn 中的 linear_assignment.py</h3><p><a href="https://www.feiyilin.com/munkres.html" target="_blank" rel="noopener">Munkres Algorithm For Assignment Problem: A Tutorial</a></p><p><a href="https://blog.csdn.net/u014754127/article/details/78086014" target="_blank" rel="noopener">Hungarian Algorithm匈牙利算法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hungarian algorithm </tag>
            
            <tag> 二分图 </tag>
            
            <tag> 最大匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】进程？线程？小朋友你是否有很多问号？</title>
      <link href="/2021/01/05/Process-and-Thread-1/"/>
      <url>/2021/01/05/Process-and-Thread-1/</url>
      
        <content type="html"><![CDATA[<p>本文转载自<a href="https://mp.weixin.qq.com/s/4uhfJeYwQgzd6A6nTBj_Gg" target="_blank" rel="noopener">这篇文章</a></p><a id="more"></a><p><img src="menu.jpg" alt="目录"></p><h1 id="什么是进程"><a class="markdownIt-Anchor" href="#什么是进程"></a> 什么是进程？</h1><p><strong>标准定义</strong>：进程是一个具有一定独立功能的程序在一个数据集合上依次动态执行的过程。进程是一个正在执行程序的实例，包括程序计数器、寄存器和程序变量的当前值。</p><p>简单来说<strong>进程就是一个程序的执行流程，内部保存程序运行所需的资源</strong></p><p>在操作系统中可以有多个进程在运行，可对于CPU来说，同一时刻，一个CPU只能运行一个进程，但在某一时间段内，CPU将这一时间段拆分成更短的时间片，CPU不停地在各个进程间游走，这就给人一种并行的错觉，像CPU可以同时运行多个进程一样，这就是伪并行。</p><hr><h1 id="进程和程序有什么联系"><a class="markdownIt-Anchor" href="#进程和程序有什么联系"></a> 进程和程序有什么联系？</h1><p>一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</p><ul><li>程序是产生进程的基础</li><li>程序的每次运行产生不同的进程</li><li>进程是程序功能的体现</li><li>通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序</li></ul><hr><h1 id="进程和程序有什么区别"><a class="markdownIt-Anchor" href="#进程和程序有什么区别"></a> 进程和程序有什么区别？</h1><p><strong>进程是动态的，程序是静态的</strong>：程序是有序代码的集合，进程是程序的执行。</p><p><strong>进程是暂时的，程序是永久的</strong>：进程是一个状态变化的过程，程序可长久保存。</p><p><strong>进程和程序的组成不同</strong>：进程的组成包括程序、数据和进程控制块（进程状态信息）。</p><hr><h1 id="进程有什么特点"><a class="markdownIt-Anchor" href="#进程有什么特点"></a> 进程有什么特点？</h1><p><strong>动态性</strong>：可动态地创建和结束进程</p><p><strong>并发性</strong>：可以被独立的调度并占用处理机并发运行</p><p><strong>独立性</strong>：不同进程的工作不相互影响</p><p><strong>制约性</strong>：因访问共享资源或进程间同步而产生制约</p><hr><h1 id="进程如何创建"><a class="markdownIt-Anchor" href="#进程如何创建"></a> 进程如何创建？</h1><p>有什么事件会触发进程的创建呢？</p><p><strong>系统初始化</strong>：当启动操作系统时，通常会创建很多进程，有些是同用户交互并替他们完成工作的前台进程，其它的都是后台进程，后台进程和特定用户没有关系，但也提供某些专门的功能，例如接收邮件等，这种功能的进程也称为守护进程。计划任务是个典型的守护进程，它每分钟运行一次来检查是否有工作需要它完成。如果有工作要做，它就会完成此工作，然后进入休眠状态，直到下一次检查时刻的到来。</p><p><strong>正在运行的程序执行了创建进程的系统调用</strong>：在一个进程中又创建了一个新的进程，这种情况很常见。</p><p><strong>用户请求创建一个新进程</strong>：这种情况相信每个人都见过，用电脑时双击某个应用图标，就会有至少一个进程被创建。</p><p><strong>一个批处理作业的初始化</strong>：这种情形不常见，仅在大型机的批处理系统中应用，用户在这种系统中提交批处理作业，在操作系统认为有资源可运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。</p><p>归根到底：在UNIX系统中，只有fork系统调用才可以创建新进程，使用方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"父进程\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程创建之后，父子进程都有<strong>各自不同的地址空间</strong>，其中一个进程在其地址空间的修改对另一个进程不可见。子进程的初始化空间是父进程的一个副本，这里涉及两个不同地址空间，不可写的内存区是共享的，某些UNIX的实现使程序正文在两者间共享，因为它是不可修改的。</p><p>还有一种<strong>写时复制</strong>共享技术，子进程共享父进程的所有内存，一旦两者之一想要修改部分内存，则这块内存被复制确保修改发生在当前进程的私有内存区域。</p><hr><h1 id="进程为何终止"><a class="markdownIt-Anchor" href="#进程为何终止"></a> 进程为何终止？</h1><p>有什么事件会触发进程的终止呢？</p><p><strong>正常退出</strong>（自愿）：进程完成了工作正常终止，UNIX中退出进程的系统调用是exit。</p><p><strong>出错退出</strong>（自愿）：进程发现了错误而退出。可以看如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123; <span class="comment">// 有错误就退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>严重错误</strong>（非自愿）：进程发生了严重的错误而不得不退出，通常是程序的错误导致，例如执行了一条非法指令，引用不存在的内存，或者除数是0等，出现这些错误时进程默认会退出。而有些时候如果用户想自行处理某种类型的错误，发生不同类型错误时进程会收到不同类型的信号，用户注册处理不同信号的函数即可。</p><p><strong>被其它进程杀死</strong>（非自愿）：其它进程执行kill系统调用通知操作系统杀死某个进程。</p><hr><h1 id="操作系统如何进行进程管理"><a class="markdownIt-Anchor" href="#操作系统如何进行进程管理"></a> 操作系统如何进行进程管理？</h1><p>这里就不得不提到一个数据结构：进程控制块（PCB），<strong>操作系统为每个进程都维护一个PCB</strong>，用来保存与该进程有关的各种状态信息。进程可以抽象理解为就是一个PCB，<strong>PCB是进程存在的唯一标志</strong>，操作系统用PCB来描述进程的基本情况以及运行变化的过程，进程的任何状态变化都会通过PCB来体现。</p><p><strong>PCB包含进程状态的重要信息</strong>，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其它在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未中断过一样。后一小节会具体介绍PCB。</p><p>提到进程管理，有一个概念我们必须要知道，就是<strong>中断向量</strong>，中断向量是指中断服务程序的入口地址。一个进程在执行过程中可能会被中断无数次，但是每次中断后，被中断的进程都要返回到与中断发生前完全相同的状态。</p><p>中断发生后操作系统最底层做了什么呢？</p><blockquote><p>1）硬件压入堆栈程序计数器等；<br>2）硬件从中断向量装入新的程序计数器；<br>3）汇编语言过程保存寄存器值；<br>4）汇编语言过程设置新的堆栈；<br>5）C中断服务例程运行（典型的读和缓冲输入）；<br>6）调度程序决定下一个将运行的进程；<br>7）C过程返回到汇编代码；<br>8）汇编语言过程开始运行新的当前进程。</p></blockquote><hr><h1 id="进程控制块中存储了什么信息"><a class="markdownIt-Anchor" href="#进程控制块中存储了什么信息"></a> 进程控制块中存储了什么信息？</h1><p><strong>进程标识信息</strong>：如本进程的标识，本进程的父进程标识，用户标识等。</p><p><strong>处理机状态信息保护区</strong>：用于保存进程的运行现场信息。</p><ul><li>用户可见寄存器：用户程序可以使用的数据、地址等寄存器。</li><li>控制和状态寄存器：程序计数器，程序状态字。</li><li>栈指针：过程调用、系统调用、中断处理和返回时需要用到它。</li></ul><p><strong>进程控制信息</strong>：</p><ul><li>调度和状态信息：用于操作系统调度进程使用。</li><li>进程间通信信息：为支持进程间与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中。</li><li>存储管理信息：包含有指向本进程映像存储空间的数据结构。</li><li>进程所用资源：说明由进程打开使用的系统资源，如打开的文件等。</li><li>有关数据结构连接信息：进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。</li></ul><hr><h1 id="进程如何进行生命周期管理"><a class="markdownIt-Anchor" href="#进程如何进行生命周期管理"></a> 进程如何进行生命周期管理？</h1><p><strong>进程创建</strong>：</p><p>创建进程有三个主要事件：</p><ul><li>系统初始化</li><li>用户请求创建一个新进程</li><li>一个正在运行的进程执行创建进程的系统调用</li></ul><p><strong>进程运行</strong>：内核选择一个就绪的进程，让它占用处理机并运行，这里就涉及到了进程的调度策略，选择哪个进程调度？为什么选择调度这个进程呢？（莫慌，下面会介绍哈）</p><p><strong>进程等待</strong>：</p><ul><li>在以下情况下进程会等待（阻塞）：</li><li>请求并等待系统服务，无法马上完成</li><li>启动某种操作，无法马上完成</li><li>需要的数据没有到达</li></ul><p><strong>注意：进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生</strong>。</p><p><strong>进程唤醒</strong>：<br>进程只能被别的进程或操作系统唤醒，唤醒进程的原因有：</p><ul><li>被阻塞进程需要的资源可被满足</li><li>被阻塞进程等待的事件到达</li><li>将该进程的PCB插入到就绪队列</li></ul><p><strong>进程结束</strong>：<br>在以下四种情况下进程会结束：</p><ul><li>自愿型正常退出</li><li>自愿型错误退出</li><li>强制型致命错误退出</li><li>强制型被其它进程杀死退出</li></ul><hr><h1 id="进程都有什么状态"><a class="markdownIt-Anchor" href="#进程都有什么状态"></a> 进程都有什么状态？</h1><p>不同系统设置的进程状态是不同的，多数系统中的进程在生命结束前有三种基本状态，进程只会处于三种基本状态之一：</p><p><strong>运行状态</strong>：进程正在处理机上运行时就处在运行状态，该时刻进程时钟占用着CPU；</p><p><strong>就绪状态</strong>：万事俱备，只欠东风，进程已经获得了除处理机之外的一切所需资源，一旦得到处理机就可以运行；就绪态中的进程其实可以运行，但因为其它进程正在占用着CPU而暂时停止运行；</p><p><strong>等待状态（阻塞状态）</strong>：进程正在等待某一事件而暂停运行，等待某个资源或者等待输入输出完成。除非某种外部事件发生，否则阻塞态的进程不能运行；</p><p>进程状态变化图如下：<br><img src="status.jpg" alt="进程状态变化图"></p><p>在操作系统发现进程不能继续运行下去时，进程因为等待输入而被阻塞，进程从<strong>运行态转换到阻塞态</strong>！</p><p>调度程序选择了另一个进程执行时，当前程序就会从<strong>运行态转换到就绪态</strong>！</p><p>被调度程序选择的程序会从<strong>就绪态转换到运行态</strong>！</p><p>当阻塞态的进程等待的一个外部事件发生时，就会从<strong>阻塞态转换到就绪态</strong>，此时如果没有其他进程运行时，则立刻从<strong>就绪态转换到运行态</strong>！</p><p>有些与进程管理相关的系统调用读者有必要了解一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pid=fork(); // 创建一个与父进程一样的子进程</span><br><span class="line"></span><br><span class="line">pid=waitpid(); // 等待子进程终止</span><br><span class="line"></span><br><span class="line">s=execve(); // 替换进程的核心映像</span><br><span class="line"></span><br><span class="line">exit(); // 终止进程运行并返回状态值</span><br><span class="line"></span><br><span class="line">s=sigaction(); // 定义信号处理的动作</span><br><span class="line"></span><br><span class="line">s=sigprocmask(); // 检查或更换信号掩码</span><br><span class="line"></span><br><span class="line">s=sigpending(); // 获得阻塞信号集合</span><br><span class="line"></span><br><span class="line">s=sigsuspend(); // 替换信号掩码或挂起进程</span><br><span class="line"></span><br><span class="line">alarm(); // 设置定时器</span><br><span class="line"></span><br><span class="line">pause(); // 挂起调用程序直到下一个信号出现</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>某些系统设置下进程还会有其它状态：<br>创建状态：进程正在被创建还没被转到就绪状态之前的状态；<br>结束状态：进程正在从系统中消失时的状态。</p><hr><h1 id="什么是进程挂起为什么会出现进程挂起"><a class="markdownIt-Anchor" href="#什么是进程挂起为什么会出现进程挂起"></a> 什么是进程挂起？为什么会出现进程挂起？</h1><p>进程挂起就是为了合理且充分的利用系统资源，把一个进程从内存转到外存。进程在挂起状态时，意味着进程没有占用内存空间，处在挂起状态的进程映射在磁盘上。进程挂起通常有两种状态：</p><ul><li><p>阻塞挂起状态：进程在外存并等待某事件的出现；</p></li><li><p>就绪挂起状态：进程在外存，但只要进入内存即可运行。</p></li></ul><p>有什么与进程挂起相关的状态转换？</p><p>进程挂起可能有以下几种情况：</p><p><strong>阻塞到阻塞挂起</strong>：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程；</p><p><strong>就绪到就绪挂起</strong>：当有高优先级阻塞进程或低优先级就绪进程时，系统会选择挂起低优先级就绪进程；</p><p><strong>运行到就绪挂起</strong>：对于抢占式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；</p><p><strong>阻塞挂起到就绪挂起</strong>：当有阻塞挂起进程有相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。</p><p><strong>有进程挂起那就有进程解挂：指一个进程从外存转到内存，相关状态有</strong>：</p><p><strong>就绪挂起到就绪</strong>：没有就绪进程或就绪挂起进程优先级高于就绪进程时，就会进行这种转换；</p><p><strong>阻塞挂起到阻塞</strong>：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起进程转换为阻塞进程。</p><hr><h1 id="什么是进程调度操作系统对于进程调度都有什么策略"><a class="markdownIt-Anchor" href="#什么是进程调度操作系统对于进程调度都有什么策略"></a> 什么是进程调度？操作系统对于进程调度都有什么策略？</h1><p>当系统中有多个进程同时竞争CPU，如果只有一个CPU可用，那同一时刻只会有一个进程处于运行状态，操作系统必须要选择下一个要运行的是哪个进程，在操作系统中，完成选择工作的这部分称为调度程序，该程序使用的算法称作<strong>调度算法</strong>。</p><p><strong>什么时候进行调度？</strong></p><ol><li>系统调用创建一个新进程后，需要决定是运行父进程还是运行子进程。</li><li>一个进程退出时需要做出调度决策，需要决定下一个运行的是哪个进程。</li><li>当一个进程阻塞在I/O和信号量或者由于其它原因阻塞时，必须选择另一个进程运行。</li><li>当一个I/O中断发生时，如果中断来自IO设备，而该设备现在完成了工作，某些被阻塞的等待该IO的进程就成为可运行的就绪进程了，是否让新就绪的进程运行，或者让中断发生时运行的进程继续运行，或者让某个其它进程运行，这就取决于调度程序的抉择了。</li></ol><p><strong>调度算法分类</strong>：</p><p><strong>非抢占式调度算法</strong>：挑选一个进程，然后让该进程运行直至被阻塞，或者直到该进程自动释放CPU，即使该进程运行了若干个小时，它也不会被强迫挂起。这样做的结果是，在时钟中断发生时不会进行调度，在处理完时钟中断后，如果没有更高优先级的进程等待，则被中断的进程会继续执行。简单来说，<strong>调度程序必须等待事件结束</strong>。</p><p>非抢占方式引起进程调度的条件：</p><ul><li>进程执行结束，或发生某个事件而不能继续执行</li><li>正在运行的进程因有I/O请求而暂停执行</li><li>进程通信或同步过程中执行了某些原语操作（wait、block等）</li></ul><p><strong>抢占式调度算法</strong>：挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行，进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便CPU控制返回给调度程序，如果没有可用的时钟，那么非抢占式调度就是唯一的选择。简单来说，<strong>就是当前运行的进程在事件没结束时就可以被换出，防止单一进程长时间独占CPU资源</strong>。下面会介绍很多抢占式调度算法：优先级算法、短作业优先算法、轮转算法等。</p><p><strong>调度策略</strong>：不同系统环境下有不同的调度策略算法。调度算法也是有KPI的，对调度算法首先提的需求就是：</p><ul><li><strong>公平</strong>：调度算法需要给每个进程公平的CPU份额，相似的进程应该得到相似的服务，对一个进程给予较其它等价的进程更多的CPU时间是不公平的，被普通水平的应届生工资倒挂也是不公平的！</li><li><strong>执行力</strong>：每一个策略必须强制执行，需要保证规定的策略一定要被执行。</li><li><strong>平衡</strong>：需要保证系统的所有部分尽可能都忙碌。</li></ul><p>但是因为不同的应用有不同的目标，不同的系统中，调度程序的优化也是不同的，大体可以分为三种环境：</p><br><p><strong>批处理系统</strong></p><blockquote><p>批处理系统的管理者为了掌握系统的工作状态，主要关注三个指标：</p><ul><li>吞吐量：是系统每小时完成的作业数量</li><li>周转时间：指从一个作业提交到完成的平均时间</li><li>CPU利用率：尽可能让CPU忙碌，但又不能过量</li></ul><p><strong>调度算法</strong>：</p><p><strong>先来先服务</strong><br>先来后到嘛，就像平时去商店买东西需要排队一样，使用该算法，进程按照它们请求CPU的顺序来使用CPU，该算法最大的优点就是简单易于实现，太容易的不一定是好的，该算法也有很大的<strong>缺点</strong>：平均等待时间波动较大，时间短的任务可能排队排在了时间长的任务后面。举个生活中的例子，排着队去取快递，如果每个人都很快取出来快递还好，如果前面有几个人磨磨唧唧到快递柜前才拿出手机打开app，再找半分钟它的取件码，就会严重拖慢后面的人取快递的速度，同理排着队的进程如果每个进程都很快就运行完还好，如果其中有一个得到了CPU的进程运行时候磨磨唧唧很长时间都运行不完，那后面的进程基本上就没有机会运行了！</p><p><strong>最短作业优先</strong><br>该调度算法是非抢占式的算法，每个进程执行期间不会被打断，每次都选择执行时间最短的进程来调度，但问题来了，操作系统怎么可能知道进程具体的执行时间呢，所以该算法注定是基于预测性质的理想化算法，而且有违公平性，而且可能导致运行时间长的任务得不到调度。</p><p><strong>最短剩余时间优先</strong><br>该调度算法是抢占式的算法，是最短作业优先的抢占版本，在进程运行期间，如果来了个更短时间的进程，那就转而去把CPU时间调度给这个更短时间的进程，它的缺点和最短作业优先算法类似。</p></blockquote><br><p><strong>交互式系统</strong></p><blockquote><p>对于交互系统最重要的指标就是响应时间和均衡性啦：</p><ul><li>响应时间：一个请求被提交到产生第一次响应所花费的时间。你给别人发微信别人看后不回复你或者几个小时后才回复你，你是什么感受，这还是交互式吗？</li><li>均衡性：减少平均响应时间的波动。需要符合固有期望和预期，你给别人发微信，他有时候秒回复，有时候几个小时后才回复。在交互式系统中，可预测性比高差异低平均更重要。</li></ul><p><strong>调度算法：</strong></p><p><strong>轮转调度</strong><br>每个进程被分配一个时间段，称为时间片，即CPU做到雨露均沾，轮流翻各个进程的牌子，这段时间宠幸进程A，下一段时间宠幸进程B，再下一段时间宠幸进程C，确保每个进程都可以获得CPU时间，如果CPU时间特别短的话，在外部看来像是同时宠幸了所有进程一样。那么问题来了，这个时间片究竟多长时间好呢？如果时间片设的太短会导致过多的进程切换，频繁的上下文切换会降低CPU效率，而如果时间片设的太长又可能对短的交互请求的响应时间变长，通常将时间片设为20-50ms是个比较合理的折中，大佬们的经验规则时维持上下文切换的开销处于1%以内。</p><p><strong>优先级调度</strong><br>上面的轮转调度算法是默认每个进程都同等重要，都有相同优先级，然而有时候进程需要设置优先级，例如某些播放视频的前台进程可以优先于某些收发邮件的后台守护进程被调度，在优先级调度算法中，每个优先级都有相应的队列，队列里面装着对应优先级的进程，首先在高优先级队列中进行轮转调度，当高优先级队列为空时，转而去低优先级队列中进行轮转调度，如果高优先级队列始终不为空，那么低优先级的进程很可能就会饥饿到很久不能被调度。</p><p><strong>多级队列</strong><br>多级队列算法与优先级调度算法不同，优先级算法中每个进程分配的是相同的时间片，而在多级队列算法中，不同队列中的进程分配给不同的时间片，当一个进程用完分配的时间片后就移动到下一个队列中，这样可以更好的避免上下文频繁切换。举例：有一个进程需要100个时间片，如果每次调度都给分配一个时间片，则需要100次上下文切换，这样CPU运行效率较低，通过多级队列算法，可以考虑最开始给这个进程分配1个时间片，然后被换出，下次分给它2个时间片，再换出，之后分给它4、8、16、64个时间片，这样分配的话，该进程只需要7次交换就可以运行完成，相比100次上下文切换运行效率高了不少，但顾此就会失彼，那些需要交互的进程得到响应的速度就会下降。</p><p><strong>最短进程优先</strong><br>交互式系统中应用最短进程优先算法其实是非常适合的，每次都选择执行时间最短的进程进行调度，这样可以使任务的响应时间最短，但这里有个任务，还没有运行呢，我怎么知道进程的运行时间呢？根本没办法非常准确的再当前可运行进程中找出最短的那个进程。有一种办法就是根据进程过去的行为进行预测，但这能证明是个好办法吗？</p><p><strong>保证调度</strong><br>这种调度算法就是向用户做出明确的可行的性能保证，然后去实现它。一种很实际的可实现的保证就是确保N个用户中每个用户都获得CPU处理能力的1/N，类似的，保证N个进程中每个进程都获得1/N的CPU时间。</p><p><strong>彩票调度</strong><br>彩票调度算法基本思想是为进程提供各种资源（CPU时间）的彩票，一旦需要做出调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源，很明显，拥有彩票越多的进程，获得资源的可能性越大。该算法在程序喵看来可以理解为股票算法，将CPU的使用权分成若干股，假设共100股分给了3个进程，给这些进程分别分配20、30、50股，那么它们大体上会按照股权比例（20：30：50）划分CPU的使用。</p><p><strong>公平分享调度</strong><br>假设有系统两个用户，用户1启动了1个进程，用户2启动了9个进程，如果使用轮转调度算法，那么用户1将获得10%的CPU时间，用户2将获得90%的CPU时间，这对用户来说公平吗？如果给每个用户分配50%的CPU时间，那么用户2中的进程获得的CPU时间明显比用户1中的进程短，这对进程来说公平吗？这就取决于怎么定义公平啦？</p></blockquote><br><p><strong>实时系统</strong></p><blockquote><p>实时系统顾名思义，最关键的指标当然是实时啦：</p><ul><li>满足截止时间：需要在规定deadline前完成作业；</li><li>可预测性：可预测性是指在系统运行的任何时刻，在任何情况下，实时系统的资源调配策略都能为争夺资源的任务合理的分配资源，使每个实时任务都能得到满足。</li></ul><p><strong>调度算法分类</strong>：</p><p><strong>硬实时</strong><br>必须在deadline之前完成工作，如果delay，可能会发生灾难性或发生严重的后果；</p><p><strong>软实时</strong><br>必须在deadline之前完成工作，但如果偶尔delay了，也可以容忍。</p><p><strong>调度算法</strong>：</p><p><strong>单调速率调度</strong><br>采用抢占式、静态优先级的策略，调度周期性任务。<br>每个任务最开始都被配置好了优先级，当较低优先级的进程正在运行并且有较高优先级的进程可以运行时，较高优先级的进程将会抢占低优先级的进程。在进入系统时，每个周期性任务都会分配一个优先级，周期越短，优先级越高。这种策略的理由是：更频繁的需要CPU的任务应该被分配更高的优先级。</p><p><strong>最早截止时间调度</strong><br>根据截止时间动态分配优先级，截止时间越早的进程优先级越高。</p><p>该算法中，当一个进程可以运行时，它应该向操作系统通知截止时间，根据截止时间的早晚，系统会为该进程调整优先级，以便满足可运行进程的截止时间要求。它与单调速率调度算法的区别就是一个是静态优先级，一个是动态优先级。</p></blockquote><p><strong>如何配置调度策略</strong>？<br>调度算法有很多种，各有优缺点，操作系统自己很少能做出最优的选择，那么可以把选择权交给用户，由用户根据实际情况来选择适合的调度算法，这就叫策略与机制分离，调度机制位于内核，调度策略由用户进程决定，将调度算法以某种形式参数化，由用户进程来选择参数从而决定内核使用哪种调度算法。</p><hr><h1 id="操作系统怎么完成进程调度"><a class="markdownIt-Anchor" href="#操作系统怎么完成进程调度"></a> 操作系统怎么完成进程调度？</h1><p>进程的每次变化都会有相应的状态，而操作系统维护了一组状态队列，表示系统中所有进程的当前状态；不同的状态有不同的队列，有就绪队列阻塞队列等，每个进程的PCB都根据它的状态加入到相应的队列中，当一个进程的状态发生变化时，它的PCB会从一个状态队列中脱离出来加入到另一个状态队列。</p><p><img src="scheduling.jpg" alt="进程调度"></p><p>注意图中同一种状态为什么有多个队列呢？因为进程有优先级概念，相同状态的不同队列的优先级不同。</p><hr><h1 id="什么是线程"><a class="markdownIt-Anchor" href="#什么是线程"></a> 什么是线程？</h1><p>线程是进程当中的一条执行流程，这几乎就是进程的定义，一个进程内可以有多个子执行流程，即线程。可以从两个方面重新理解进程：</p><ul><li>从资源组合的角度：进程把一组相关的资源组合起来，构成一个资源平台环境，包括地址空间（代码段、数据段），打开的文件等各种资源</li><li>从运行的角度：代码在这个资源平台上的执行流程，然而线程貌似也是这样，但是进程比线程多了资源内容列表样式：那就有一个公式：进程 = 线程 + 共享资源</li></ul><hr><h1 id="为什么使用线程"><a class="markdownIt-Anchor" href="#为什么使用线程"></a> 为什么使用线程？</h1><p>因为要并发编程，在许多情形中同时发生着许多活动，而某些活动有时候会被阻塞，通过将这些活动分解成可以准并行运行的多个顺序流程是必须的，而如果使用多进程方式进行并发编程，进程间的通信也很复杂，并且<strong>维护进程的系统开销较大</strong>：创建进程时分配资源建立PCB，撤销进程时回收资源撤销PCB，进程切换时保存当前进程的状态信息。所以为了使并发编程的开销尽量小，所以引入多线程编程，可以并发执行也可以<strong>共享相同的地址空间</strong>。并行实体拥有共享同一地址空间和所有可用数据的能力，这是多进程模型所不具备的能力。</p><p>使用线程有如下优点：</p><ul><li>可以多个线程存在于同一个进程中</li><li>各个线程之间可以并发的执行</li><li>各个线程之间可以共享地址空间和文件等资源</li><li>线程比进程更轻量级，创建线程撤销线程比创建撤销进程要快的多，在许多系统中，创建一个线程速度是创建一个进程速度的10-100倍。</li><li>如果多个线程是CPU密集型的，并不能很好的获得更好的性能，但如果多个线程是IO密集型的，线程存在着大量的计算和大量的IO处理，有多个线程允许这些活动彼此重叠进行，从而会加快整体程序的执行速度。</li></ul><p>但也有<strong>缺点</strong>：</p><ul><li>一旦一个线程崩溃，会导致其所属进程的所有线程崩溃。</li><li>由于各个线程共享相同的地址空间，那么读写数据可能会导致竞争关系，因此对同一块数据的读写需要采取某些同步机制来避免线程不安全问题。</li></ul><hr><h1 id="什么时候用进程-线程"><a class="markdownIt-Anchor" href="#什么时候用进程-线程"></a> 什么时候用进程、线程？</h1><ol><li>进程是资源分配单位，线程是CPU调度单位；</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li><li>线程同样具有就绪阻塞和执行三种基本状态，同样具有状态之间的转换关系；</li><li>线程能减少并发执行的时间和空间开销：<ul><li>线程的创建时间比进程短</li><li>线程的终止时间比进程短</li><li>同一进程内的线程切换时间比进程短</li><li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信</li></ul></li></ol><p><strong>结论</strong>：可以在强调性能时候使用线程，如果追求更好的容错性可以考虑使用多进程，google浏览器据说就是用的多进程编程。在多CPU系统中，多线程是有益的，在这样的系统中，通常情况下可以做到真正的并行。</p><p><strong>C/C++中如何使用多线程编程？</strong></p><p>POSIX使用如下线程封装函数来操作线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_create               创建一个新线程</span><br><span class="line">pthread_exit                 结束调用的线程</span><br><span class="line">pthread_join                 等待一个特定的线程退出</span><br><span class="line">pthread_yield                释放CPU来运行另外一个线程</span><br><span class="line">pthread_attr_init            创建并初始化一个线程的属性结构</span><br><span class="line">pthread_attr_destroy         删除一个线程的属性结构</span><br></pre></td></tr></table></figure><p>后两个函数是有关线程属性的调用。pthread_attr_init建立关联一个线程的属性结构并初始化成默认值，这些值（优先级等）可以通过修改属性结构中的对应值来改变；pthread_attr_destroy会删除一个线程的属性结构，释放它占用的内存，它不会影响调用它的线程，线程依然会继续存在。</p><p>C++中有std::thread和async，可以很方便地操作多线程，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">r</span><span class="params">(F)</span></span>;</span><br><span class="line">    r.detach();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">20</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="线程是如何实现的"><a class="markdownIt-Anchor" href="#线程是如何实现的"></a> 线程是如何实现的？</h1><p>线程的实现可分为用户线程和内核线程：</p><p><strong>用户线程</strong>：在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建终止同步和调度等。</p><p><img src="user_thread.jpg" alt="用户线程"></p><p>用户线程有如下优点：</p><ul><li>由于用户线程的维护由相应进程来完成（通过线程库函数），不需要操作系统内核了解内核了解用户线程的存在，可用于不支持线程技术的多进程操作系统。</li><li>每个进程都需要它自己私有的线程控制块列表，用来跟踪记录它的各个线程的状态信息（PC，栈指针，寄存器），TCB由线程库函数来维护；</li><li>用户线程的切换也是由线程库函数来完成，无需用户态/核心态切换，所以速度特别快；</li><li>允许每个进程拥有自定义的线程调度算法；</li></ul><p>但用户线程也有<strong>缺点</strong>：</p><ul><li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待。</li><li>当一个线程开始运行后，除非它主动交出CPU的使用权，否则它所在进程当中的其它线程将无法运行；</li><li>由于时间片分配给进程，与其它进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢</li></ul><p><strong>内核线程</strong>：是指在操作系统的内核中实现的一种线程机制，由操作系统的内核来完成线程的创建终止和管理。</p><p><img src="kernel_thread.jpg" alt="内核线程"></p><p><strong>特点：</strong></p><ul><li>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB TCB）；</li><li>线程的创建终止和切换都是通过系统调用内核函数的方式来进行，由内核来完成，因此系统开销较大；</li><li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其它内核线程的运行；</li><li>时间片分配给线程，多线程的进程获得更多CPU时间；</li></ul><p><em><strong>tips</strong></em><br>由于在内核中创建或撤销线程的代价比较大，某些系统采取复用的方式回收线程，当某个线程被撤销时，就把它标记不可运行，但是内核数据结构没有受到任何影响，如果后续又需要创建一个新线程时，就重新启动被标记为不可运行的旧线程，从而节省一些开销。</p><p><strong>注意</strong><br>尽管使用内核线程可以解决很多问题，但还有些问题，例如：当一个多线程的进程创建一个新的进程时会发生什么？新进程是拥有与原进程相同数量的线程还是只有一个线程？在很多情况下，最好的选择取决于进程计划下一步做什么？如果它要调用exec启动一个新程序，或许一个线程正合适，但如果它继续运行，那么最好复制所有的线程。</p><p><strong>轻量级进程</strong>：它是内核支持的用户线程模型，一个进程可以有多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。</p><p><img src="LWP.jpg" alt="轻量级进程"></p><p>在Linux下是没有真正的线程的，它所谓的线程其实就是使用进程来实现的，就是所谓的轻量级进程，其实就是进程，都是通过clone接口调用创建的，只不过两者传递的参数不同，通过参数决定子进程和父进程共享的资源种类和数量，进而有了普通进程和轻量级进程的区别。</p><hr><h1 id="什么是上下文切换"><a class="markdownIt-Anchor" href="#什么是上下文切换"></a> 什么是上下文切换？</h1><p>上下文切换指的是操作系统停止当前运行进程（从运行状态改变成其它状态）并且调度其它进程（就绪态转变成运行状态）。操作系统必须在切换之前存储许多部分的进程上下文，必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过，同时切换上下文这个过程必须快速，因为上下文切换操作是非常频繁的。那<strong>上下文指的是什么呢</strong>？指的是任务所有共享资源的工作现场，每一个共享资源都有一个<strong>工作现场</strong>，包括用于处理函数调用、局部变量分配以及工作现场保护的栈顶指针，和用于指令执行等功能的各种寄存器。</p><p><strong>注意</strong><br>这里所说的进程切换导致上下文切换其实不太准确，准确的说应该是任务的切换导致上下文切换，这里的任务可以是进程也可以是线程，准确的说线程才是CPU调度的基本单位，但是因为各个资料都这么解释上下文切换，所以上面也暂时这么介绍，只要读者心里有这个概念就好。</p><p><img src="context.png" alt="上下文切换"></p><hr><h1 id="进程间通信有几种方式"><a class="markdownIt-Anchor" href="#进程间通信有几种方式"></a> 进程间通信有几种方式？</h1><p>由于各个进程不共享相同的地址空间，任何一个进程的全局变量在另一个进程中都不可见，所以如果想要在进程之间传递数据就需要通过内核，在内核中开辟出一块区域，该区域对多个进程都可见，即可用于进程间通信。有读者可能有疑问了，文件方式也是进程间通信啊，也要在内核开辟区域吗？这里说的内核区域其实是一段缓冲区，文件方式传输数据也有内核缓冲区的参与（零拷贝除外）。</p><p><img src="IPC.jpg" alt="进程间通信"></p><p>如何开辟这种公共区域来进行进程间通信呢？</p><p><strong>匿名管道</strong></p><p>匿名管道就是<strong>pipe</strong>，pipe只能在父子进程间通信，而且数据只能<strong>单向流动</strong>（半双工通信）。</p><p><strong>使用方式</strong>：<br>1）父进程创建管道，会得到两个文件描述符，分别指向管道的两端；<br>2）父进程创建子进程，从而子进程也有两个文件描述符指向同一管道；<br>3）父进程可写数据到管道，子进程就可从管道中读出数据，从而实现进程间通信，下面的示例代码中通过pipe实现了每秒钟父进程向子进程都发送消息的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(_pipe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pipe\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        close(_pipe[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> _mesg[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(_mesg, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(_mesg));</span><br><span class="line">            read(_pipe[<span class="number">0</span>], _mesg, <span class="keyword">sizeof</span>(_mesg));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, _mesg);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">        close(_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> *mesg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            mesg = <span class="string">"父进程来写消息了"</span>;</span><br><span class="line">            write(_pipe[<span class="number">1</span>], mesg, <span class="built_in">strlen</span>(mesg) + <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们平时也经常使用关于管道的命令行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | less</span><br></pre></td></tr></table></figure><p>该命令行的流向图如下：</p><p><img src="unnamed_pipe.jpg" alt="命令行流向图"></p><p>1：创建管道<br>2：为ls创建一个进程，设置stdout为管理写端<br>3：为less创建一个进程，设置stdin为管道读端</p><p><strong>高级管道</strong><br>通过<strong>popen</strong>将另一个程序当作一个新的进程在当前进程中启动，它算作当前进程的子进程，高级管道只能用在有亲缘关系的进程间通信，这种亲缘关系通常指父子进程，下面的GetCmdResult函数可以获取某个Linux命令执行的结果，实现方式就是通过popen。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetCmdResult</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;cmd, <span class="keyword">int</span> max_size = <span class="number">10240</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *data = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(max_size);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"malloc fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, max_size);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_buffer = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[max_buffer];</span><br><span class="line">    <span class="comment">// 将标准错误重定向到标准输出</span></span><br><span class="line">    FILE *fdp = popen((cmd + <span class="string">" 2&gt;&amp;1"</span>).c_str(), <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">int</span> data_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fdp) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!feof(fdp)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fgets(buffer, max_buffer, fdp)) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buffer);</span><br><span class="line">                <span class="keyword">if</span> (data_len + len &gt; max_size) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"data size larger than "</span> &lt;&lt; max_size;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(data + data_len, buffer, len);</span><br><span class="line">                data_len += len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pclose(fdp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">ret</span><span class="params">(data, data_len)</span></span>;</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命名管道</strong><br>匿名管道有个缺点就是通信的进程一定要有亲缘关系，而命名管道就不需要这种限制。</p><p>命名管道其实就是一种特殊类型的文件，所谓的命名其实就是文件名，文件对各个进程都可见，通过命名管道创建好特殊文件后，就可以实现进程间通信。</p><p>可以通过mkfifo创建一个特殊的类型的文件，参数读者看名字应该就了解，一个是文件名，一个是文件的读写权限：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>当返回值为0时，表示该命名管道创建成功，至于如何通信，其实就是个读写文件的问题！</p><p><strong>消息队列</strong><br>队列想必大家都知道，像FIFO一样，这里可以有多个进程写入数据，也可以有多个进程从队列里读出数据，但消息队列有一点比FIFO还更高级，它读消息不一定要使用先进先出的顺序，每个消息可以赋予类型，可以按消息的类型读取，不是指定类型的数据还存在队列中。本质上MessageQueue是存放在内核中的消息链表，每个消息队列链表会由消息队列标识符表示，这个消息队列存于内核中，只有主动的删除该消息队列或者内核重启时，消息队列才会被删除。</p><p>在Linux中消息队列相关的函数调用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建和访问一个消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span>, key, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 用来把消息添加到消息队列中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsend</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">const</span> <span class="keyword">void</span> *msg_ptr, <span class="keyword">size_t</span> msg_sz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// msg_ptr是结构体数据的指针，结构第一个字段要有个类型：struct Msg &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> message_type;</span><br><span class="line">    <span class="comment">// 想要传输的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 从消息队列中获取消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">void</span> *msg_ptr, <span class="keyword">size_t</span> msg_st, <span class="keyword">long</span> <span class="keyword">int</span> msgtype, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 用来控制消息队列，不同的command参数有不同的控制方式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">int</span> command, struct msgid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZ 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msg_type;</span><br><span class="line">    <span class="keyword">char</span> text[BUFFER_SIZ];</span><br><span class="line">&#125; MsgWrapper;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MsgWrapper data;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msgtype = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1024</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (msgid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgget error \n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msgid, (<span class="keyword">void</span> *)&amp;data, BUFFER_SIZ, msgtype, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"error "</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"read data "</span> &lt;&lt; data.text &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(data.text) &gt; <span class="number">6</span>) &#123;  <span class="comment">// 发送超过6个字符的数据，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgctl(msgid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgctl error \n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Receive ok \n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MsgWrapper data;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msgtype = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1024</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (msgid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgget error \n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data.msg_type = msgtype;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(data.text, <span class="number">0</span>, BUFFER_SIZ);</span><br><span class="line">        <span class="keyword">char</span> a = <span class="string">'a'</span> + i;</span><br><span class="line">        <span class="built_in">memset</span>(data.text, a, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msgid, (<span class="keyword">void</span> *)&amp;data, BUFFER_SIZ, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgsnd error \n"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(data.text, <span class="string">"1234567"</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgsnd(msgid, (<span class="keyword">void</span> *)&amp;data, BUFFER_SIZ, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgsnd error \n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">r</span><span class="params">(Receive)</span></span>;</span><br><span class="line">    r.detach();</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">s</span><span class="params">(Send)</span></span>;</span><br><span class="line">    s.detach();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">20</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：root@iZuf64idor3ej648ciairaZ:~# ./a.out</span><br><span class="line">read data a</span><br><span class="line">read data b</span><br><span class="line">read data c</span><br><span class="line">read data d</span><br><span class="line">read data e</span><br><span class="line">read data f</span><br><span class="line">read data g</span><br><span class="line">read data h</span><br><span class="line">read data i</span><br><span class="line">read data j</span><br><span class="line">read data <span class="number">1234567</span></span><br><span class="line">Receive ok</span><br></pre></td></tr></table></figure><p>代码中为了演示方便使用消息队列进行的线程间通信，该代码同样用于进程间通信，消息队列的实现依赖于内核的支持，上述代码可能在某些系统（WSL）上不能运行，在正常的Ubuntu上可以正常运行。</p><p><strong>消息队列VS命名管道</strong></p><p><strong>消息队列&gt;命名管道</strong></p><p>1）消息队列收发消息自动保证了同步，不需要由进程自己来提供同步方法，而命名管道需要自行处理同步问题；<br>2）消息队列接收数据可以根据消息类型有选择的接收特定类型的数据，不需要像命名管道一样默认接收数据。</p><p><strong>消息队列&lt;命名管道</strong><br>消息队列有一个缺点就是发送和接收的每个数据都有最大长度的限制。</p><p><strong>共享内存</strong><br>可开辟中一块内存，用于各个进程间共享，使得各个进程可以直接读写同一块内存空间，就像线程共享同一块地址空间一样，该方式基本上是最快的进程间通信方式，因为没有系统调用干预，也没有数据的拷贝操作，但由于共享同一块地址空间，数据竞争的问题就会出现，需要自己引入同步机制解决数据竞争问题。</p><p>共享内存只是一种方式，它的实现方式有很多种，主要的有mmap系统调用、Posix共享内存以及System V共享内存等。通过这三种“工具”共享地址空间后，通信的目的自然就会达到。</p><p><strong>信号</strong><br>信号也是进程间通信的一种方式，信号可以在任何时候发送给某一个进程，如果进程当前并未处于执行状态，内核将信号保存，直到进程恢复到执行态再发送给进程，进程可以对信号设置预处理方式，如果对信号设置了阻塞处理，则信号的传递会被延迟直到阻塞被取消，如果进程结束，那信号就被丢弃。我们常用的CTRL+C和kill等就是信号的一种，也达到了进程间通信的目的，进程也可以对信号设置signal捕获函数自定义处理逻辑。这种方式有很大的<strong>缺点</strong>：只有通知的作用，通知了一下消息的类型，但不能传输要交换的任何数据。</p><p>Linux系统中常见的信号有：</p><ul><li>SIGHUP：该信号在用户终端结束时发出，通常在中断的控制进程结束时，所有进程组都将收到该信号，该信号的默认操作是终止进程；</li><li>SIGINT：程序终止信号，通常的CTRL+C产生该信号来通知终止进程；</li><li>SIGQUIT：类似于程序错误信号，通常的CTRL+\产生该信号通知进程退出时产生core文件；</li><li>SIGILL：执行了非法指令，通常数据段或者堆栈溢出可能产生该信号；</li><li>SIGTRAP：供调试器使用，由断电指令或其它陷阱指令产生；</li><li>SIGABRT：使程序非正常结束，调用abort函数会产生该信号；</li><li>SIGBUS：非法地址，通常是地址对齐问题导致，比如访问一个4字节长的整数，但其地址不是4的倍数；</li><li>SIGSEGV：合理地址的非法访问，访问了未分配的内存或者没有权限的内存区域；</li><li>SIGPIPE：管道破裂信号，socket通信时经常会遇到，进程写入了一个无读者的管道；</li><li>SIGALRM：时钟定时信号，由alarm函数设置的时间终止时产生；</li><li>SIGFPE：出现浮点错误（比如除0操作）；</li><li>SIGKILL：杀死进程（不能被捕捉和忽略）；</li></ul><p><strong>信号量</strong><br>想必大家都听过信号量，信号量就是一个特殊的变量，程序对其访问都是原子操作，每个信号量开始都有个初始值。最简单最常见的信号量是只能取0和1的变量，也叫二值信号量。</p><p>信号量有两个操作，P和V：</p><p>P：如果信号量变量值大于0，则变量值减1，如果值为0，则阻塞进程；<br>V：如果有进程阻塞在该信号量上，则唤醒阻塞的进程，如果没有进程阻塞，则变量值加1</p><blockquote><p>Q: 信号量和信号有什么关系？<br>A: 没有任何关系，完全是不同的东西。</p></blockquote><blockquote><p>Q: 信号量与互斥量有什么区别？<br>A: 互斥量用于<strong>互斥</strong>，信号量用于<strong>同步</strong>，互斥指的是某一资源同一时间只允许一个访问者访问，但无法限制访问顺序，访问是无序的，而同步在互斥的基础上可以控制访问者对资源的顺序。</p></blockquote><p><strong>套接字</strong>：就是网络传输，不用多说，网络通信都可以多机通信呢，更不用说进程间通信啦，你能看到程序喵的文章也是套接字的功劳。</p><p><strong>文件</strong>：显而易见，多个进程可以操作同一个文件，所以也可以通过文件来进行进程间通信。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
            <tag> Process </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】5万字、97 张图总结操作系统核心知识点</title>
      <link href="/2020/12/10/OS/"/>
      <url>/2020/12/10/OS/</url>
      
        <content type="html"><![CDATA[<p>本文章介绍了操作系统的一些核心知识点。</p><h2 id="文章地址"><a class="markdownIt-Anchor" href="#文章地址"></a> <a href="https://mp.weixin.qq.com/s/G4Xs8BDYo8YK4qHuGdB7DA" target="_blank" rel="noopener">文章地址</a></h2><a id="more"></a><p>文章从以下几个方面对操作系统进行了介绍:</p><ol><li><strong>计算机硬件</strong><br><img src="hardware.png" alt="计算机硬件"></li><li><strong>进程和线程</strong><ul><li>进程</li><li>线程</li><li>进程间通信</li><li>调度<br><img src="process.jpg" alt="进程和线程"></li></ul></li><li><strong>内存管理</strong><ul><li>地址空间</li><li>虚拟内存</li><li>页表置换算法<br><img src="memory.png" alt="内存管理"></li></ul></li><li><strong>文件系统的实现</strong><ul><li>文件</li><li>目录</li><li>文件系统的实现</li><li>文件系统的管理和优化<br><img src="filesystem.png" alt="文件系统"></li></ul></li><li><strong>I/O 流程</strong><ul><li>I/O 设备</li><li>I/O 软件原理</li><li>I/O 层次结构</li><li>盘</li><li>时钟<br><img src="IO.png" alt="I/O 流程"></li></ul></li><li><strong>资源</strong><br><img src="resource.png" alt="资源"></li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 Non-local</title>
      <link href="/2020/11/05/Understanding-Non-local/"/>
      <url>/2020/11/05/Understanding-Non-local/</url>
      
        <content type="html"><![CDATA[<p>之前一直没有深入地了解 Non-local 的来源，以为只是同名论文中提出的一个 Block 设计，最近阅读 AlphAction 论文时，突然发现其是来自于 Attention is all you need 中 self-attention 的思想。虽然 Attention 此文是针对 NLP 领域的，但是其思想逐渐被延伸到了视觉领域。在阅读关于 Transformer 中 self-attention 的文章后，在这里记录下对 Non-local 的理解。</p><a id="more"></a><p>首先介绍 Self-Attention</p><h1 id="self-attention-模块"><a class="markdownIt-Anchor" href="#self-attention-模块"></a> Self-attention 模块</h1><h2 id="公式"><a class="markdownIt-Anchor" href="#公式"></a> 公式</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mfrac><mrow><mi>A</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac><mo stretchy="false">)</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">Attention(Q,K,V)=softmax({AK^T\over\sqrt{d_k}})V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.448331em;vertical-align:-0.93em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span></span></p><blockquote><p>在 self-attention 中，每个单词有 3 个不同的向量，它们分别是 Query 向量（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> ），Key 向量（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> ）和 Value 向量（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> ），长度均是 64。<strong>它们是通过3个不同的权值矩阵由嵌入向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 乘以三个不同的权值矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>W</mi><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">W^Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>W</mi><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">W^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>W</mi><mi>V</mi></msup></mrow><annotation encoding="application/x-tex">W^V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span></span></span></span></span></span></span> 得到，其中三个矩阵的尺寸也是相同的</strong>。均是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>512</mn><mo>×</mo><mn>416</mn></mrow><annotation encoding="application/x-tex">512\times416</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mord">6</span></span></span></span> 。</p></blockquote><br><p><img src="QKV.jpg" alt="Q, K, V的计算示例图"></p><h2 id="attention-的计算方法"><a class="markdownIt-Anchor" href="#attention-的计算方法"></a> Attention 的计算方法</h2><ol><li>将输入单词转化成嵌入向量;</li><li>根据嵌入向量得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 三个向量;</li><li>为每个向量计算一个 score: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>=</mo><mi>q</mi><mo>⋅</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">score=q\cdot{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span>;</li><li>为了梯度的稳定，Transformer 使用了 score 归一化，即除以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.18278000000000005em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span></span>;</li><li>对 score 施以 softmax 激活函数;</li><li>softmax 点乘 Value 值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，得到加权的每个输入向量的评分 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>;</li><li>相加之后得到最终的输出结果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mo>∑</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">z=\sum{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span></span></li></ol><p>以上步骤可以表示成下图</p><p><img src="self-attention.jpg" alt="Self-Attention计算示例图"></p><p>实际计算过程中是采用基于矩阵的计算方式，那么论文中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 的计算方式如下图<br><img src="QKV-M.jpg" alt="Q, K, V的矩阵表示"></p><p>Self-Attention 的计算示例图可以总结为下图所示的矩阵形式<br><img src="self-attention-M.jpg" alt="Selef-Attention的矩阵表示"><br>而这，也是公式的计算方式。</p><hr><p>接下来看 Non-local 模块</p><h1 id="non-local-的图像"><a class="markdownIt-Anchor" href="#non-local-的图像"></a> Non-local 的图像</h1><p><img src="original-nonlocal.jpg" alt="原始的 Non-local"></p><p><img src="lfb-nonlocal.jpg" alt="lfb 中的 Non-local"></p><p><img src="alphaction-nonlocal.jpg" alt="AlphAction 中的 Non-local"></p><p>从 AlphAction 的 Non-local 可以看出，<br><code>Q</code> 的尺寸是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">N\times{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span></span>, <code>K</code> 的尺寸是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>×</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">N^{&#x27;}\times{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0258099999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span></span>, <code>Q</code> 与 <code>K转置</code>进行矩阵乘法，对应的就是第三步 <strong>计算 score</strong> 的过程(<code>Q</code>的每一行与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">K^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>的每一列点乘)。<br>接下来的 <code>Scale</code> 操作对应第四步 <strong>score 归一化</strong> 的过程。<br>再接下来，Softmax 的输出结果（尺寸 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">N\times{N^{&#x27;}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>）与 <code>V</code> 进行矩阵乘法，得到最后尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">N\times{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span></span> 的矩阵。这里，可以看作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">N\times{N^{&#x27;}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 矩阵的每一行分别与 <code>V</code> 相乘，即 <code>V</code> 的每一行的加权和。<br>其实，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mo>×</mo><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">Q\times{K^{T}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></span> 结果的每一行，来自于 <code>Q</code> 的每一行与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">K^{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span> 进行矩阵相乘，即 <code>Q</code> 的一个向量与 <code>K</code> 所有向量的点积。而<strong>最后计算 <code>V</code> 矩阵每一行的加权和时的权重就来自这里</strong>。</p><p>所以，整个 Non-local 的流程，整体感觉就是通过对 <code>Q</code>, <code>K</code> 的处理，得到了 <code>N</code> 组长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">N^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 的权重，并对 <code>V</code> 的每一行进行加权和。</p><p><strong>补充解释</strong>: Self-Attention 真实的意图是，通过 <code>Q</code> 与 <code>K</code> 进行 <code>score</code> 的计算，并以 <code>score</code> 作为 <code>V</code> 被 <code>Q</code> 所激活的程度的度量，并因此选择出激活程度最高的 <code>V</code> 中的特征向量，计算加权和。最后，将加权和与原始的 <code>Q</code> 进行相加，得到更新后的 <code>Q</code>。而这个更新后的 <code>Q</code>，就是获得了 attention 的 <code>Q</code>。在视频理解领域，目的就是通过 Self-attention 将来自其他人和物体的上下文信息加到 <code>Q</code> 所代表的人身上，以辅助后续分类。</p><p>AlphAction 中 3.2 节的解释如下</p><blockquote><p>Through the dot-product attention, which is the output of the softmax layer in Figure 3 a, the block is able to select value features that are highly activated to the query features and merge them to enhance the query features.</p></blockquote><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://zhuanlan.zhihu.com/p/48508221" target="_blank" rel="noopener">详解Transformer （Attention Is All You Need）</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Non-local </tag>
            
            <tag> attention </tag>
            
            <tag> Transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打包 Python 工程</title>
      <link href="/2019/10/29/Packaging-Python/"/>
      <url>/2019/10/29/Packaging-Python/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍了两个用来将 Python 工程的依赖进行打包以便于部署的 Python 库。</p><a id="more"></a><ol><li>PEX <a href="https://github.com/pantsbuild/pex" target="_blank" rel="noopener">github</a> <a href="https://pex.readthedocs.io/" target="_blank" rel="noopener">文档</a> <a href="https://medium.com/ovni/pex-python-executables-c0ea39cee7f1" target="_blank" rel="noopener">博客</a></li><li>shiv <a href="https://github.com/linkedin/shiv" target="_blank" rel="noopener">github</a> <a href="https://shiv.readthedocs.io/en/latest/" target="_blank" rel="noopener">文档</a></li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> PEX </tag>
            
            <tag> shiv </tag>
            
            <tag> dependencies </tag>
            
            <tag> 依赖 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将 Tensorflow 模型移植到 Caffe 上</title>
      <link href="/2019/10/22/Convert-Tensorflow-Model-to-Caffe/"/>
      <url>/2019/10/22/Convert-Tensorflow-Model-to-Caffe/</url>
      
        <content type="html"><![CDATA[<p>本文主要以 cosine metric learning 工程为例，记录了如何将一个 Tensorflow 模型 (包含 ckpt 文件) 移植到 Caffe 框架下。</p><a id="more"></a><h1 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h1><blockquote><ol><li>根据 Tensorflow 的网络定义源码，手动编写 Caffe 的网络定义文件 *.prototxt.</li><li>将训练好的 ckpt 文件中的参数 dump 到磁盘，存为 npy 文件。</li><li>使用 pycaffe API, 加载 prototxt 文件，生成 Net 对象。</li><li>根据 npy 文件与 Net 对象中网络层的对应关系，将 npy 文件中的值赋给 Net 对象中的参数。</li><li>将 Net 对象保存为 caffemodel 文件到磁盘。</li></ol></blockquote><br><h1 id="一些应该注意的点"><a class="markdownIt-Anchor" href="#一些应该注意的点"></a> 一些应该注意的点</h1><blockquote><p><strong>1</strong>. Tensorflow 中的 BN 层对应 Caffe 中的两个层，BatchNorm + Scale. 这是因为 Batch Normalization 算法最后有一个 缩放+偏置 的操作，这就对应 Caffe 中的 Scale 层。通常 Scale 层的缩放参数记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>, 偏置参数记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>. 有时候，从 ckpt 模型中 dump 出的 npy 文件没有 BN 层对应的 gamma 值，这可能是因为其在训练时没有使用缩放（batch_norm 函数的 scale 参数设为了 None ），也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\gamma=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。因此在流程第 4 步时，将相应 shape 的值全为 1 的 ndarray 赋给 Net 对象中 Scale 层对应的 gamma 即可，即 <code>net.params[conv1_scale][0].data[...] = np.ones(bn_beta)</code>. 此外，若 npy 文件中有 BN 层对应的 beta 值，则在 prototxt 文件中对应的 Scale 层应设置 <code>bias_term: true</code>，因为这里的 beta 值就是 bias term. <a href="https://blog.csdn.net/zziahgf/article/details/78843350" target="_blank" rel="noopener">参考1</a> <a href="https://www.cnblogs.com/LaplaceAkuir/p/7811383.html" target="_blank" rel="noopener">参考2</a></p></blockquote><hr><blockquote><p><strong>2</strong>. ckpt 中 dump 出的 npy 文件中可能没有某些 Convolution 层的 bias 权重。因此，在 prototxt 文件中，为此 Convolution 层设置 <code>bias_term: false</code>.</p></blockquote><hr><blockquote><p><strong>3</strong>. 在从 ckpt 中 dump 出来的参数里，有些可能名如 <code>*/Adam</code>, <code>*/Adam_1</code>，这个是因为模型使用了 Adam 优化器，这两个是对某个参数更新的时候使用的，如果只是在测试阶段进行前向推导，则不需要这两个参数。<a href="https://www.jianshu.com/p/75d8df8511bc" target="_blank" rel="noopener">参考</a><br>但是如果是需要对模型进行 Finetune, 出现大量 Adam 变量丢失的错误，则有可能是 <strong>要恢复的变量的位置</strong> 和 <strong>Adam 优化器的位置</strong> 出错造成的。<a href="https://blog.csdn.net/shwan_ma/article/details/82868751" target="_blank" rel="noopener">【tensorflow】加载pretrained model出现的大量adam变量丢失</a></p></blockquote><hr><blockquote><p><strong>4</strong>. 一些 Tensorflow 的项目使用 <code>tf.image.decode_jpeg()</code> 函数来读取 jpg 图像，要注意的是，如果直接使用此函数的默认 <code>dct_method</code> 的话，此函数读取到的值将会跟 <code>cv2.imread()</code> 读取的值不一致。这是因为 <code>tf.image.decode_jpeg()</code> 函数默认会为了解码速度而牺牲一些解码精度。如果想要获得跟 <code>cv2.imread()</code> 相同的结果的话，设置参数 <code>dct_method='INTEGER_ACCURATE'</code>。<a href="https://github.com/tensorflow/tensorflow/issues/24893#issuecomment-454911098" target="_blank" rel="noopener">参考1</a> <a href="https://stackoverflow.com/a/45520846/8149027" target="_blank" rel="noopener">参考2</a><br>此外，<code>tf.image.decode_jpeg()</code> 函数返回的图像是 <code>RGB</code> 通道的，<code>cv2.imread()</code> 是 <code>BGR</code> 通道。</p></blockquote><hr><blockquote><p><strong>5</strong>. <strong>Tensorflow 和 Caffe 在某些操作上的区别</strong><br>  <strong>5-1</strong>. <strong>Feature map 以及 卷积核 维度顺序的区别</strong><br>在 Tensorflow 中，feature map 的默认索引顺序是 <code>NHWC</code>, 卷积核是 <code>HWIO</code>，而 Caffe 中两者的索引顺序是 <code>NCHW</code> 和 <code>OIHW</code>.<br>需要说明的是，如果输入是完全一样的图片，在将图像以及卷积核按各自索引顺序 transpose 好后，后续生成的 feature map 在理论上来说应是完全一样的，它们只是索引的顺序不一样而已(feature map 内部各元素之间的相对顺序是一致的)。</p></blockquote><blockquote><p>  <strong>5-2</strong>. <strong>Flatten 操作的区别</strong><br>据上文所述，同样的输入以及卷积核在不同框架中计算得到的 feature map 是一致的。但是如果要对 feature map (4D) 进行 flatten 操作的话，则此结论可能不成立。因为 flatten 是将 3D 的 feature map 拉伸成 1D, 那么不同的顺序可能就会产生不同的 1D 向量 (内部元素的相对位置可能发生了改变).<br>对同一个 feature map, 若其 shape 为 <code>NHWC</code> （这里的 NHWC 与上文所说的 NHWC 意义不一样，针对某个特定的 feature map, 其 NHWC 的值是固定的）, Tensorflow 的顺序是沿着 <code>C -&gt; W -&gt; H</code>，而 Caffe 的顺序是沿着 <code>W -&gt; H -&gt; C</code>。两者 flatten 的顺序在其各自的输入 feature map 索引顺序中都是 <code>3 -&gt; 2 -&gt; 1</code><br>例如，一个 <code>1x3x3x2</code> 的 feature map.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data =  [[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],   | H</span><br><span class="line">          [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],   |</span><br><span class="line">          [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],  |</span><br><span class="line">      W  -------------</span><br><span class="line">         [[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],</span><br><span class="line">          [<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>],</span><br><span class="line">          [<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>]]]</span><br><span class="line"></span><br><span class="line">Tensorflow: [<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, ... ]</span><br><span class="line">Caffe: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, ...]</span><br></pre></td></tr></table></figure><blockquote><p>由于 两者 flatten 的顺序在其各自的输入 feature map 索引顺序中都是 <code>3 -&gt; 2 -&gt; 1</code>，因此若这两个 flatten 的输入是一样的话，则它们的输出也是一样的。由于 Caffe 中没有类似 Transpose 这样的层，因此我采取使用 pycaffe 将前向 inference 后 Flatten 层的输入取出，用 numpy 进行 transpose 后，再重新赋给 Flatten 层当输入，然后再次调用 pycaffe 的接口 <code>net.forward(start='', end='')</code> 指定从某个层开始前向传播，这里就指定 start 参数为 Flatten 层的 name. 这样，即可在 Caffe 中得到与 Tensorflow 中同样的 Flatten 层输出。<a href="https://github.com/BVLC/caffe/issues/2725#issue-93930312" target="_blank" rel="noopener">net.forward 指定起点</a><br>Caffe 的 Flatten 层有 <code>axis</code>, <code>end_axis</code> 两个参数，但是我无论如何设置都无法在不对输入进行 transpose 的情况下得到与 Tensorflow 一样的结果。也许是我没理解对这两个参数的意义。<a href="https://caffe.berkeleyvision.org/tutorial/layers/flatten.html" target="_blank" rel="noopener">参考1</a> <a href="https://stackoverflow.com/a/40401460/8149027" target="_blank" rel="noopener">参考2</a></p></blockquote><blockquote><p>  <strong>5-3</strong>. <strong>Padding 操作的区别</strong><br>Caffe 中的所有 padding 操作都是对称的，也就是说如果设置 <code>pad_w=1</code> 则会在 feature map 的左右两边都 pad 一个像素。但是 Tensorflow 不是如此，有可能出现左边 pad 1, 右边 pad 2，或者上边 pad 1,下边 pad 2 的情况。因此，在移植时，要保持在 Tensorflow 和 Caffe 中的 padding 方式都一样，这样才能得到相同的结果。<br>下面讨论 Caffe 的 padding 与 Tensorflow 中 <code>SAME</code> padding 方式的差异。<br>正常情况下，如果 <code>kernel_size=3, stride=1</code> 那么 <code>SAME</code> padding 模式会保持输入输出的尺寸相同，因此，需要在输入的上下左右各 pad 1 个像素。这时，在 Caffe 里只要设置 <code>pad: 1</code> 就行，这样两者 pad 的结果就是一样的了。<br>但是，如果遇到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">≠</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">stride\neq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的情况，情况就变得复杂。有可能两个框架某个 Convolution 或者 Pooling 操作的输入输出尺寸都一样，但是数值却不同。如下图所示 <a href="https://github.com/Microsoft/MMdnn/wiki/Error-in-mobilenet-conversion-from-Tensorflow-to-Caffe-Different-way-of-padding#the-reason-of-the-inconsistent-shapes-is-due-to-symmetric-padding-in-caffe" target="_blank" rel="noopener">来源</a><br><img src="padding_1.png" alt=""><br><img src="padding_2.png" alt=""><br>在 Tensorflow 中, <code>SAME</code> padding 模式的策略是: <a href="https://stackoverflow.com/a/53820765/8149027" target="_blank" rel="noopener">来源</a></p><blockquote><p>First, consider the <code>SAME</code> padding scheme. A detailed explanation of the reasoning behind it is given in these notes. Here, we summarize the mechanics of this padding scheme. When using ‘SAME’, the output height and width are computed as:</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out_height = ceil(float(in_height) / float(strides[<span class="number">1</span>]))</span><br><span class="line">out_width  = ceil(float(in_width) / float(strides[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>The total padding applied along the height and width is computed as:</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SAME padding 长度计算</span></span><br><span class="line"><span class="keyword">if</span> (in_height % strides[<span class="number">1</span>] == <span class="number">0</span>):</span><br><span class="line">  pad_along_height = max(filter_height - strides[<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  pad_along_height = max(filter_height - (in_height % strides[<span class="number">1</span>]), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_width % strides[<span class="number">2</span>] == <span class="number">0</span>):</span><br><span class="line">  pad_along_width = max(filter_width - strides[<span class="number">2</span>], <span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  pad_along_width = max(filter_width - (in_width % strides[<span class="number">2</span>]), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>Finally, the padding on the top, bottom, left and right are:</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pad_top = pad_along_height // <span class="number">2</span></span><br><span class="line">pad_bottom = pad_along_height - pad_top</span><br><span class="line">pad_left = pad_along_width // <span class="number">2</span></span><br><span class="line">pad_right = pad_along_width - pad_left</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>Note that the division by 2 means that there might be cases when the padding on both sides (top vs bottom, right vs left) are off by one. In this case, the bottom and right sides always get the one additional padded pixel. For example, when pad_along_height is 5, we pad 2 pixels at the top and 3 pixels at the bottom. Note that this is different from existing libraries such as cuDNN and Caffe, which explicitly specify the number of padded pixels and always pad the same number of pixels on both sides.</p></blockquote></blockquote><blockquote><blockquote><p>For the <code>VALID</code> scheme, the output height and width are computed as:</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out_height = ceil(float(in_height - filter_height + <span class="number">1</span>) / float(strides[<span class="number">1</span>]))</span><br><span class="line">out_width  = ceil(float(in_width - filter_width + <span class="number">1</span>) / float(strides[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>and no padding is used.</p></blockquote></blockquote><blockquote><p>在我的实例中，由于最后进入 Flatten 层的 feature map 需要是 <code>13x13</code> 的，而输入图像此前一共经过了 3 次下采样，一次 MAX Pool, 两次 Convolution, 都是 <code>kernel_size=3, stride=2</code>。因此，如何使这三次操作的 padding 操作在两个框架中一致就成了关键问题。由于在 SAME padding 中，<br>                           <code>out_height = ceil(float(in_height) / float(strides[1])),</code><br>                           <code>out_width = ceil(float(in_width) / float(strides[2]))</code><br>因此，这三次下采样操作的输入尺寸存在这些可能性</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">              13                      &lt;-  经过第二次 Conv, stride=2</span><br><span class="line">          /         \</span><br><span class="line">         /           \</span><br><span class="line">       25            26               &lt;-  经过第一次 Conv, stride=2</span><br><span class="line">    /     \       /     \</span><br><span class="line">   49     50     51      52           &lt;-   经过 MAX Pooling</span><br><span class="line">  /  \   /  \   /   \   /   \</span><br><span class="line">97   98 99 100 101 102 103 104        &lt;-      输入图像</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>由于 Caffe 只能进行对称 padding，因此要选择一个合适的输入图像尺寸，使得在这三次操作时 Tensorflow 不会出现 padding 不对称的情况 (因为这在 Caffe 中无法实现)。<br>根据上段 <code>SAME padding 长度计算部分的公式</code>，我们要使得 <code>pad_along_width，pad_along_height</code> 的数值为 <strong>偶数</strong>，这样才能对称。因此，要使得 <strong><code>in_height % strides[1] != 0, in_width % strides[2] != 0</code></strong>。由于 <code>strides[1]=2</code>，因此，<code>in_height, in_width</code> 必须是 <strong>奇数</strong>。这样，就可以得到每次操作前的输入尺寸分别是 <code>97 -&gt; 49 -&gt; 25 -&gt; 13</code>。这样，在每次操作时，SAME padding 都会为 feature map 在空间维度上四周各 pad 一个像素。而在 Caffe 的对应层的定义里，只要设置 <code>pad: 1</code> 即可。</p></blockquote><hr><blockquote><p><strong>6</strong>. 关于 Tensorflow 中获取 Graph 中所有节点名称以及 ckpt 文件中的变量。<br>  <strong>6.1</strong>.<strong>读取 ckpt 中的变量</strong> <a href="https://www.jianshu.com/p/75d8df8511bc" target="_blank" rel="noopener">参考</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf;</span><br><span class="line"></span><br><span class="line"> reader = tf.train.NewCheckpointReader(<span class="string">"/path/to/model.ckpt"</span>)</span><br><span class="line"> variables = reader.get_variable_to_shape_map()</span><br><span class="line"> <span class="keyword">for</span> key <span class="keyword">in</span> variables:</span><br><span class="line">      w = reader.get_tensor(key)</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>6.2</strong>. <strong>获取 Graph 中的所有结点名称，并计算得到某节点的值</strong> <a href="https://www.jianshu.com/p/3cee7ca5ebd8" target="_blank" rel="noopener">参考</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all_op_names = [n.name <span class="keyword">for</span> n <span class="keyword">in</span> tf.get_default_graph().as_graph_def().node]</span><br><span class="line">conv1_op = tf.get_default_graph.get_tensor_by_name(<span class="string">'a_tensor_name_from_above_line:0'</span>)  <span class="comment"># 注意要在名称后面加 :0</span></span><br><span class="line">conv1_value = sess.run(conv1_op, feed_dict=&#123;...&#125;)</span><br></pre></td></tr></table></figure><br><h2 id="dump-ckpt-中的参数以及生成-caffemodel-的两个脚本"><a class="markdownIt-Anchor" href="#dump-ckpt-中的参数以及生成-caffemodel-的两个脚本"></a> dump ckpt 中的参数以及生成 caffemodel 的两个脚本</h2><p><a href="dump.py">dump ckpt</a><br><a href="tf2caffe.py">生成 caffemodel</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Caffe </tag>
            
            <tag> Tensorflow </tag>
            
            <tag> Porting </tag>
            
            <tag> 移植 </tag>
            
            <tag> padding </tag>
            
            <tag> flatten </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波</title>
      <link href="/2019/07/04/Kalman-Filter/"/>
      <url>/2019/07/04/Kalman-Filter/</url>
      
        <content type="html"><![CDATA[<p>本文主要关注卡尔曼滤波的流程和 5 个公式。</p><a id="more"></a><p><strong>卡尔曼滤波的主要思想</strong>：首先，根据时间步 <code>t-1</code> 的状态空间，通过<strong>状态转移矩阵</strong>和<strong>控制矩阵</strong>(控制量)，预测 <code>t</code> 时间步时的状态空间。由于 <code>t-1</code> 时间步的状态空间本身就不是准确的，含有噪声，且状态转移的过程也引入噪声，因此预测得到的 <code>t</code> 时间步的状态空间是不准确的。这时，我们在 <code>t</code> 时间步进行实际的测量，使用得到的<strong>测量结果</strong>去修正预测得到的状态空间。其实就是对 <strong>预测的结果</strong> 和 <strong>测量的结果</strong> 根据其不准确度(用协方差矩阵表示)来计算权重(即卡尔曼增益)，对两个结果进行<font color="purple" size="4"> <strong>加权平均</strong></font>，并依此得到 <code>t</code> 时间步最优的结果。</p><blockquote><p>虽然叫 kalman 滤波器，但个人觉得也可以叫状态观测器，因为就是根据<strong>测量值的协方差矩阵</strong>和<strong>预测值的协方差矩阵</strong>权衡出一个更为准确的系统当前状态嘛。(<font color="blue">TAO: 就是根据这两个协方差矩阵算出卡尔曼增益，充当加权的权重。</font>)如果从噪声的角度上理解，最终也确实起到了一个降噪的效果，叫滤波器也合适。</p></blockquote><br><h1 id="卡尔曼滤波的五个公式"><a class="markdownIt-Anchor" href="#卡尔曼滤波的五个公式"></a> 卡尔曼滤波的五个公式</h1><p><img src="format.jpg" alt="卡尔曼公式"></p><br><h1 id="卡尔曼滤波模型"><a class="markdownIt-Anchor" href="#卡尔曼滤波模型"></a> 卡尔曼滤波模型</h1><p><img src="Kalman_filter_model.png" alt="卡尔曼滤波模型"></p><h1 id="博客"><a class="markdownIt-Anchor" href="#博客"></a> 博客</h1><h2 id="第一篇"><a class="markdownIt-Anchor" href="#第一篇"></a> 第一篇</h2><p>在网上看了一些有关卡尔曼滤波的博客，其中有一篇英文的博客讲得很好。知乎上也有很多翻译版本。<br><a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/" target="_blank" rel="noopener"><font color="purple">英文原版</font></a><br><a href="https://zhuanlan.zhihu.com/p/39912633?utm_source=zhihu&amp;utm_medium=social&amp;utm_oi=846674040629395456" target="_blank" rel="noopener"><font color="purple">中文翻译版</font></a></p><blockquote><p>这个翻译版有很多错误，我结合原文和其他翻译版对有些段落进行了修正。</p></blockquote><p><img src="1.jpeg" alt=""><br><img src="2.jpeg" alt=""><br><img src="3.jpeg" alt=""><br><img src="4.jpeg" alt=""><br><img src="5.1.jpeg" alt=""><br><img src="5.2.png" alt=""><br><img src="5.3.png" alt=""><br><img src="6.jpeg" alt=""><br><img src="7.jpeg" alt=""></p><br><h2 id="第二篇"><a class="markdownIt-Anchor" href="#第二篇"></a> 第二篇</h2><p>还有一篇 CSDN 上的博客，<a href="https://blog.csdn.net/weixin_39632524/article/details/111362311" target="_blank" rel="noopener"><font color="purple">卡尔曼滤波五个公式_仔细看完你就懂卡尔曼滤波（Kalman Filter）</font></a><br><img src="1-2.jpeg" alt=""><br><img src="3-4.jpeg" alt=""></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Kalman </tag>
            
            <tag> tracking </tag>
            
            <tag> 卡尔曼 </tag>
            
            <tag> 卡尔曼滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】 浅谈多节点 CPU+GPU 协同计算负载均衡性设计</title>
      <link href="/2019/06/26/Heterogeneous-Computing/"/>
      <url>/2019/06/26/Heterogeneous-Computing/</url>
      
        <content type="html"><![CDATA[<p>本文转载自<a href="https://blog.csdn.net/zhang0311/article/details/8224093" target="_blank" rel="noopener">这里</a>，主要讲述了关于基于 CPU+GPU 的混合异构计算系统的内容。</p><a id="more"></a><p>近年来，基于 CPU+GPU 的混合异构计算系统开始逐渐成为国内外高性能计算领域的热点研究方向。在实际应用中，许多基于 CPU+GPU 的混合异构计算机系统表现出了良好的性能。但是，由于各种历史和现实原因的制约，异构计算仍然面临着诸多方面的问题，其中最突出的问题是程序开发困难，尤其是扩展到集群规模级别时这个问题更为突出。主要表现在扩展性、负载均衡、自适应性、通信、内存等方面。</p><h1 id="一-cpugpu协同计算模式"><a class="markdownIt-Anchor" href="#一-cpugpu协同计算模式"></a> 一、 CPU+GPU协同计算模式</h1><p>CPU+GPU异构协同计算集群如图1所示，CPU+GPU 异构集群可以划分成三个并行层次：节点间并行、节点内 CPU 与 GPU 异构并行、设备（CPU 或 GPU）内并行。根据这三个层次我们可以得到 CPU+GPU 异构协同计算模式为：<font color="orange">节点间分布式+节点内异构式+设备内共享式</font>。</p><p><strong>1 节点间分布式</strong><br>CPU+GPU 异构协同计算集群中，各个节点之间的连接与传统 CPU 集群一样，采用网络连接，因此，节点间采用了分布式的计算方式，可以采用 MPI 消息通信的并行编程语言。</p><p><strong>2 节点内异构式</strong><br>CPU+GPU 异构协同计算集群中，每个节点上包含多核 CPU 和一块或多块 GPU 卡，节点内采用了异构的架构，采用主从式的编程模型，即每个 GPU 卡需要由 CPU 进程/线程调用。</p><p>由于每个节点上，CPU 核数也比较多，计算能力也很大，因此，在多数情况下，CPU 也会参与部分并行计算，根据 CPU 是否参与并行计算，我们可以把 CPU+GPU 异构协同计算划分成两种计算模式：</p><p> 1) CPU/GPU 协同计算：CPU 只负责复杂逻辑和事务处理等串行计算，GPU 进行大规模并行计算；<br> 2) CPU+GPU 共同计算：由一个 CPU 进程/线程负责复杂逻辑和事务处理等串行计算，其它 CPU 进程/线程负责小部分并行计算，GPU 负责大部分并行计算。</p><p>由于 CPU/GPU 协同计算模式比 CPU+GPU 共同计算模式简单，下面的介绍中，我们以 CPU+GPU 共同计算模式为例进行展开介绍各种编程模式。</p><p>在 CPU+GPU 共同计算模式下，我们把所有的 CPU 统称为一个设备（device），如双路 8 核 CPU 共有 16 个核，我们把这 16 个核统称成一个设备；每个 GPU 卡成为一个设备。根据这种划分方式，我们可以采用 MPI 进程或 OpenMP 线程控制节点内的各设备之间的通信和数据划分。</p><p><strong>3 设备内共享式</strong><br> 1) CPU 设备：每个节点内的所有多核 CPU 采用了共享存储模型，因此，把节点内的所有多核 CPU 看作一个设备， 可以采用 MPI 进程或 OpenMP 线程、pThread 线程控制这些 CPU 核的并行计算。</p><p> 2) GPU 设备：GPU 设备内有自己独立的 DRAM 存储，GPU 设备也是共享存储模型，在 GPU 上采用 CUDA 或 OpenCL 编程控制 GPU 众核的并行计算。CUDA 编程模式只在 NVIDIA GPU 上支持，OpenCL 编程模式在 NVIDIA GP U和 AMD GPU 都支持。</p><p>根据前面对 CPU+GPU 异构协同计算模式的描述，我们可以得到 CPU+GPU 异构协同计算的编程模型（以 MPI 和 OpenMP 为例）如表1所示。</p><p><img src="pic_1.jpg" alt="图1 CPU+GPU异构协同计算架构"></p><p><img src="pic_2.png" alt="表1 CPU+GPU异构协同计算编程模型"></p><h1 id="二-cpugpu协同计算负载均衡性设计"><a class="markdownIt-Anchor" href="#二-cpugpu协同计算负载均衡性设计"></a> 二、CPU+GPU协同计算负载均衡性设计</h1><p>下面以 模式2 为例简单介绍多节点 CPU+GPU 协同计算任务划分和负载均衡，模式2 的进程和线程与 CPU 核和 GPU 设备对应关系如 图2 所示。若采用主从式 MPI 通信机制，我们在节点 0 上多起一个进程（0号进程）作为主进程，控制其它所有进程。每个节点上启动3个计算进程，其中两个控制 GPU 设备，一个控制其余所有 CPU 核的并行，在 GPU 内采用 CUDA/OpenCL 并行，在 CPU 设备内采用 OpenMP 多线程并行。</p><p>由于 CPU+GPU 协同计算模式分为 3个层次，那么负载均衡性也需要在这 3个层次 上分别设计。在 模式2 的编程方式下，节点内和节点间均采用 MPI 进程，合二为一，设计负载均衡时，只需要做到进程间（设备之间）的负载均衡和 CPU 设备内 OpenMP 线程负载均衡、GPU 设备内 CUDA 线程负载均衡即可。</p><p>对于设备内，采用的是共享存储器模型，CPU 设备上的 OpenMP 线程可以采用 schedule(static / dynamic / guided )方式；GPU 设备上只要保证同一 warp 内的线程负载均衡即可。</p><p>对于 CPU+GPU 协同计算，由于 CPU 和 GPU 计算能力相差很大，因此，在对任务和数据划分时不能给 CPU 设备和 GPU 设备划分相同的任务/数据量，这就增加了 CPU 与 GPU 设备间负载均衡的难度。CPU 与 GPU 之间的负载均衡最好的方式是采用动态负载均衡的方法，然而有些应用无法用动态划分而只能采用静态划分的方式。下面我们分别介绍动态划分和静态划分。</p><p> 1) 动态划分：对于一些高性能计算应用程序，在 CPU 与 GPU 之间的负载均衡可以采用动态负载均衡的优化方法，例如有 N 个任务/数据，一个节点内有 2 个 GPU 卡，即三个设备（CPU 和 2个 GPU），动态负载均衡的方法是每个设备先获取一个任务/数据进行计算，计算之后立即获取下一个任务，不需要等待其他设备，直到 N 个任务/数据计算完成。这种方式只需要在集群上设定一个主进程，负责给各个计算进程分配任务/数据。</p><p> 2) 静态划分：在一些应用中，无法采用动态划分的方式，需要静态划分方法，然而静态划分方法使异构设备间的负载均衡变得困难，有时甚至无法实现。对于一些迭代应用程序，我们可以采用学习型的数据划分方法，如先让 CPU 和 GPU 分别做一次相同计算量的计算，然后通过各自的运行时间计算出 CPU 与 GPU 的计算能力比例，然后再对数据进行划分。</p><p><img src="pic_3.jpg" alt="图2 CPU+GPU协同计算示意图（以每个节点2个GPU为例）"></p><h1 id="三-cpugpu协同计算数据划分示例"><a class="markdownIt-Anchor" href="#三-cpugpu协同计算数据划分示例"></a> 三、CPU+GPU协同计算数据划分示例</h1><p>假设某一应用的数据特点如 图3 所示，从输出看，结果中的每个值的计算需要所有输入数据的信息，所有输出值的计算之间没有任何数据依赖性，可以表示成 outj=；从输入看，每个输入值对所有的输出值都产生影响，所有输入数据之间也没有任何数据依赖性。从数据特点可以看出，该应用既可以对输入进行并行数据划分也可以对输出进行数据划分。下面我们分析 CPU+GPU 协同计算时的数据划分方式。<br><img src="pic_4.jpg" alt="图3 并行数据示例"></p><p><strong>1 按输入数据划分</strong></p><p>假设按输入数据划分，我们可以采用动态的方式给每个 CPU 或 GPU 设备分配数据，做到动态负载均衡，然而这种划分方式，使所有的线程向同一个输出位置保存结果，为了正确性，需要使所有的线程对每个结果进行原子操作，这样将会严重影响性能，极端情况下，所有线程还是按顺序执行的。因此，这种方式效果很差。</p><p><strong>2 按输出数据划分</strong></p><p>按输出数据划分的话可以让每个线程做不同位置的结果计算，计算完全独立，没有依赖性。如果采用静态划分的方式，由于 CPU 和 GPU 计算能力不同，因此，很难做到负载均衡。采用动态的方式可以做到负载均衡，即把结果每次给 CPU 或 GPU 设备一块，当设备计算完本次之后，立即向主进程申请下一个分块，这样可以做到完全负载均衡。按输出数据划分，无论采用静态划分还是动态划分，都会带来另外一个问题，由于每个结果的计算都需要所有输入信息，那么所有进程（设备）都需要读取一遍所有输入数据，动态划分时还不只一次，尤其对于输入数据很大时，这将会对输入数据的IO产生很大的影响，很有可能使 IO 程序性能瓶颈。</p><p><strong>3 按输入和输出同时划分</strong></p><p>由于按输入或按输出划分都存在不同的缺点，我们可以采用输入和输出同时划分的方式进行数据划分，如 图4 所示。</p><p>从输出角度，让所有的计算进程（设备）都有一份计算结果，设备内的线程对结果进行并行计算，每个设备都有一份局部的计算结果，所有设备都计算完毕之后，利用MPI进程对所有设备的计算结果进行规约，规约最后的结果即是最终的结果。</p><p>从输入角度，按输入数据动态划分给不同的计算进程（设备），这样可以满足所有的计算进程负载均衡。<br><img src="pic_5.jpg" alt="图4 CPU+GPU协同计算数据划分示例"></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> CPU </tag>
            
            <tag> GPU </tag>
            
            <tag> 负载均衡 </tag>
            
            <tag> 异构 </tag>
            
            <tag> 协同计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些 C++ 相关的概念和操作</title>
      <link href="/2019/06/26/Cxx-Related/"/>
      <url>/2019/06/26/Cxx-Related/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了一些常用的 C++ 相关的概念和操作。</p><a id="more"></a><br><h3 id="string-与-char-互转"><a class="markdownIt-Anchor" href="#string-与-char-互转"></a> string 与 char* 互转</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string to char*</span></span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"name"</span>;</span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*)name.data();</span><br><span class="line"></span><br><span class="line"><span class="comment">// char* to string</span></span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">"name"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="built_in">string</span>(name);</span><br></pre></td></tr></table></figure><br><h3 id="释放-stdvector-所占用的内存"><a class="markdownIt-Anchor" href="#释放-stdvector-所占用的内存"></a> 释放 std::vector 所占用的内存</h3><blockquote><p>在容器 vector 中，其内存占用的空间是只增不减的，比如说首先分配了 10,000 个字节，然后 erase 掉后面 9999个，则虽然有效元素只有一个，但是内存占用仍为 10,000 个。所有内存空间在 vector 析构时回收。<br>一般，我们都会通过 vector 中成员函数 clear 进行一些清除操作，但它清除的是所有的元素，使 vector 的大小减少至 0，却不能减小 vector 占用的内存。要避免 vector 持有它不再需要的内存，这就需要一种方法来使得它从曾经的容量减少至它现在需要的容量，这样减少容量的方法被称为 “<strong>收缩到合适（shrink to fit）</strong>”。</p></blockquote><p>使用以下代码可以实现此功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt;().swap(X)  <span class="comment">// X 的类型为 std::vector&lt;T&gt;;</span></span><br><span class="line"><span class="comment">//其相当于</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;  temp(X);</span><br><span class="line">temp.swap(X);</span><br></pre></td></tr></table></figure><blockquote><p>其背后原理为:<strong><code>vector()</code> 使用 <code>vector</code> 的默认构造函数建立临时 <code>vector</code> 对象，再在该临时对象上调用 <code>swap</code> 成员，<code>swap</code> 调用之后对象 <code>X</code> 占用的空间就等于一个默认构造的对象的大小，临时对象就具有原来对象 <code>X</code> 的大小，而该临时对象随即就会被析构，从而其占用的空间也被释放。</strong></p></blockquote><p><a href="https://www.cnblogs.com/zhoug2020/p/4058487.html" target="_blank" rel="noopener">参考</a></p><br><h3 id="二维数组和双重指针在内存中的差别"><a class="markdownIt-Anchor" href="#二维数组和双重指针在内存中的差别"></a> 二维数组和双重指针在内存中的差别</h3><p>首先，下例是不可行的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myputs</span><span class="params">(<span class="keyword">char</span> **pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> **p;</span><br><span class="line">    <span class="keyword">char</span> a[ROW][COL]=&#123;<span class="string">"abc"</span>, <span class="string">"def"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    p = a;</span><br><span class="line">    myputs(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myputs</span><span class="params">(<span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ROW; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, p[i][j]); <span class="comment">// 试图用双重指针的方式访问二维数组，不可行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>myputs(char **p)</code> 接受双重指针作为参数，<code>main()</code> 函数将二维数组的头指针赋给双重指针，并作为 <code>myputs(char **p)</code> 的参数传入，再使用 <code>p[i][j]</code> 的方式访问某个元素。这是不行的，而这与两者的内存分布有关。</p><hr><p><strong>二维数组的内存分布</strong></p><blockquote><p>定义了二维数组后，就会在内存中分配一块逻辑上连续的内存块。<code>char c[10][10]</code>，系统就会分配一块 100 字节的连续内存。也就是说这样的二维数组跟一维数组 <code>char c[100]</code> 具有相似的内存分布。<br>二维数组的内存分布如下：<br><img src="2d_array.png" alt="二维数组的内存分布"></p></blockquote><p><strong>双重指针的内存分布</strong></p><blockquote><p>双重指针的内存分配一般采取动态方式<br><img src="2d_pointer.png" alt="双重指针的内存分布"></p></blockquote><p>可以看出，当将二维数组的头指针赋值给双重指针后，再使用 <code>p[i][j]</code> 的方式访问里面的元素，就会出现错误。这是因为，二维数组的内存是以连续的方式分配的，但是在访问时，却使用了双重指针的方式进行访问，这就会导致段错误。</p><hr><p><strong>总结</strong></p><blockquote><p><code>char **p</code> 和 <code>char p[2][3]</code> 之间不能相互传递参数，因为它们具体的内存分布不一样，这样在运行时就会出现段错误。<br>此外还需注意的一点：<br>二维数组中的 <code>a[i][j]</code> 和双重指针中的 <code>a[i][j]</code> 的意思是不一样的。<br>二维数组 <code>int a[10][10]</code> 中，<code>a[i][j]</code> 指的是第 <code>i</code> 行第 <code>j</code> 列数元素。<br>双重指针中 <code>int **a</code> 中， <code>a[i][j]</code> 指的是第 <code>i</code> 个存放 <code>int *</code> 指针所指向地址中的第 <code>j</code> 个元素。也就是 <code>*(*(a+i)+j)</code>。</p></blockquote><p><a href="https://blog.csdn.net/u013684730/article/details/46565577" target="_blank" rel="noopener">原文</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程及相关概念</title>
      <link href="/2019/06/14/Process-and-Thread/"/>
      <url>/2019/06/14/Process-and-Thread/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了进程，线程等相关内容。</p><a id="more"></a><blockquote><p>抛开各种技术细节，从应用程序角度讲：<br>1、在单核计算机里，有一个资源是无法被多个程序并行使用的：CPU。<br>没有操作系统的情况下，一个程序一直独占着全部 CPU。<br>如果要有两个任务来共享同一个 CPU，程序员就需要仔细地为程序安排好运行计划–某时刻 CPU 和由程序 A 来独享，下一时刻 CPU 由程序 B 来独享,而这种安排计划后来成为 OS 的核心组件，被单独名命为 “<strong>scheduler</strong>”，即“<strong>调度器</strong>”，它关心的只是怎样把单个 CPU 的运行拆分成一段一段的“运行片”，轮流分给不同的程序去使用，而在宏观上，因为分配切换的速度极快，就制造出多程序并行在一个 CPU 上的假象。</p></blockquote><blockquote><p>2、在单核计算机里，有一个资源可以被多个程序共用，然而会引出麻烦：<strong>内存</strong>。<br>在一个只有调度器，没有内存管理组件的操作系统上，程序员需要手工为每个程序安排运行的空间 – 程序A使用物理地址 <code>0x00-0xff</code>, 程序B使用物理地址<code>0x100-0x1ff</code>，等等。<br>然而这样做有个很大的问题：每个程序都要协调商量好怎样使用同一个内存上的不同空间，软件系统和硬件系统千差万别，使这种定制的方案没有可行性。<br>为了解决这个麻烦，计算机系统引入了“<strong>虚拟地址</strong>”的概念，从三方面入手来做：<br>2.1、硬件上，CPU 增加了一个专门的模块叫 MMU，负责转换虚拟地址和物理地址。<br>2.2、操作系统上，操作系统增加了另一个核心组件：<strong>memory management</strong>，即内存管理模块，它管理物理内存、虚拟内存相关的一系列事务。<br>2.3、应用程序上，发明了一个叫做【进程】的模型，（注意）每个进程都用【<strong>完全一样的</strong>】虚拟地址空间，然而经由操作系统和硬件MMU协作，映射到不同的物理地址空间上。不同的【进程】，都有各自独立的物理内存空间，不用一些特殊手段，是无法访问别的进程的物理内存的。</p></blockquote><blockquote><p>3、现在，不同的应用程序，可以不关心底层的物理内存分配，也不关心 CPU 的协调共享了。然而还有一个问题存在：有一些程序，想要共享 CPU，【并且还要共享同样的物理内存】，这时候，一个叫【线程】的模型就出现了，它们被包裹在进程里面，在调度器的管理下共享 CPU，拥有同样的虚拟地址空间，同时也共享同一个物理地址空间，然而，它们无法越过包裹自己的进程，去访问别一个进程的物理地址空间。</p></blockquote><blockquote><p>4、进程之间怎样共享同一个物理地址空间呢？不同的系统方法各异，符合 posix 规范的操作系统都提供了一个接口，叫 mmap，可以把一个物理地址空间映射到不同的进程中，由不同的进程来共享。</p></blockquote><blockquote><p>5、PS：在有的操作系统里，进程不是调度单位（即不能被调度器使用），线程是最基本的调度单位，调度器只调度线程，不调度进程，比如 VxWorks<br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html#comment-270980" target="_blank" rel="noopener">来源</a></p></blockquote><br>>CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是 CPU 和相关寄存器以及 RAM 之间的事情。**一个最最基础的事实**：CPU 太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM 和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在 CPU 看来就是轮流着来。**一个必须知道的事实**：执行一段程序代码，实现一个功能的过程介绍 ，当得到 CPU 的时候，相关的资源必须也已经就位，就是显卡啊，GPS 啊什么的必须就位，然后 CPU 开始执行。这里除了 CPU 以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的 CPU 执行时间用完了，那它就要被切换出去，等待下一次 CPU 的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被 CPU 临幸的运行环境，必须保存。**串联起来的事实**：前面讲过在 CPU 看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行 A，保存程序 A 的上下文，调入下一个要执行的程序 B 的程序上下文，然后开始执行 B,保存程序 B 的上下文。。。。<p>========= 重要的东西出现了========<br>进程和线程就是这样的背景出来的，<strong>两个名词不过是对应的CPU时间段的描述，名词就是这样的功能</strong>。<br>进程就是包换上下文切换的程序执行时间总和 = CPU 加载上下文 + CPU 执行 + CPU 保存上下文<br>**线程是什么呢？**进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序 A，实际分成 a，b，c 等多个块组合而成。那么这里具体的执行就可能变成：程序 A 得到 CPU =&gt; CPU 加载上下文，开始执行程序 A 的 a 小段，然后执行 A 的 b 小段，然后再执行 A 的 c 小段，最后 CPU 保存  A 的上下文。这里 a，b，c 的执行是共享了 A 的上下文，CPU 在执行的时候没有进行上下文切换的。这里的 a，b，c 就是线程，也就是说线程是共享了进程的上下文环境的更为细小的 CPU 时间段。到此全文结束，再一个总结：<strong>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。</strong><br><a href="https://www.zhihu.com/question/25532384/answer/81152571" target="_blank" rel="noopener">来源</a></p><blockquote><p>一、 cpu个数、核数、线程数的关系<br>cpu个数：是指物理上，也及硬件上的核心数；<br>核数：是逻辑上的，简单理解为逻辑上模拟出的核心数；<br>线程数：是同一时刻设备能并行执行的程序个数，线程数=cpu个数 * 核数【如果有超线程，再乘以超线程数】</p></blockquote><blockquote><p>二、 cpu线程数和Java多线程<br>首先明白几个概念：<br>(1) 单个cpu线程在同一时刻只能执行单一Java程序，也就是一个线程<br>(2) 单个线程同时只能在单个cpu线程中执行<br>(3) 线程是操作系统最小的调度单位，进程是资源（比如：内存）分配的最小单位<br>(4)Java中的所有线程在JVM进程中,CPU调度的是进程中的线程<br>(5)Java多线程并不是由于cpu线程数为多个才称为多线程，当Java线程数大于cpu线程数，操作系统使用时间片机制，采用线程调度算法，频繁的进行线程切换。</p></blockquote><blockquote><p>a 那么java多进程，每个进程又多线程，cpu是如何调度的呢？<br>个人理解：操作系统并不是单纯均匀的分配cpu执行不同的进程，因为线程是调度的最小单位，所以会根据不同进程中的线程个数进行时间分片，均匀的执行每个线程，也就是说A进程中有10个线程，而B进程中有2个线程，那么cpu分给进程的执行时间理论上应该是5:1才合理。</p></blockquote><blockquote><p>b cpu线程数和java线程数有直接关系吗？<br>个人理解：没有直接关系，正如上面所说，cpu采用分片机制执行线程，给每个线程划分很小的时间颗粒去执行，但是真正的项目中，一个程序要做很多的的操作，读写磁盘、数据逻辑处理、出于业务需求必要的休眠等等操作，当程序在进行I/O操作的时候，线程是阻塞的，线程由运行状态切换到等待状态，此时cpu会做上下文切换，以便处理其他的程序；当I/O操作完成后，cpu 会收到一个来自硬盘的中断信号，并进入中断处理例程，手头正在执行的线程因此被打断，回到 ready 队列。而先前因 I/O 而waiting 的线程随着 I/O 的完成也再次回到 就绪 队列，这时 cpu 可能会选择它来执行。</p></blockquote><blockquote><p>c 如何确定程序线程数？<br>个人理解：如果所有的任务都是计算密集型的，则创建的多线程数 = 处理器核心数就可以了<br>如果io操作比较耗时，则根据具体情况调整线程数，此时 多线程数 = n*处理器核心数<br>一般情况程序线程数等于cpu线程数的两到三倍就能很好的利用cpu了，过多的程序线程数不但不会提高性能，反而还会因为线程间的频繁切换而受影响，具体需要根据线程处理的业务考略，不断调整线程数个数，确定当前系统最优的线程数。<br><a href="https://blog.csdn.net/wutongyuWxc/article/details/78732287" target="_blank" rel="noopener">原文</a></p></blockquote><br><h2 id="一篇非常好的文章"><a class="markdownIt-Anchor" href="#一篇非常好的文章"></a> 一篇非常好的文章</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/1352974" target="_blank" rel="noopener">进程与线程，单核与多核</a></p></blockquote><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
            <tag> CPU </tag>
            
            <tag> Process </tag>
            
            <tag> Thread </tag>
            
            <tag> 阻塞 </tag>
            
            <tag> 非阻塞 </tag>
            
            <tag> 单核 </tag>
            
            <tag> 多核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轻量卷积神经网络的一些操作</title>
      <link href="/2019/06/03/light-weight-CNN-operations/"/>
      <url>/2019/06/03/light-weight-CNN-operations/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录一些在卷积神经网络轻量化的研究中出现的一些操作，其主要是针对卷积进行的。</p><a id="more"></a><h1 id="depthwise-convolution-and-pointwise-convolution"><a class="markdownIt-Anchor" href="#depthwise-convolution-and-pointwise-convolution"></a> Depthwise Convolution and Pointwise Convolution</h1><p><font color="orange">深度卷积</font> 分解一个标准的卷积为一个 depthwise convolution 和一个 pointwise convolution, 是对输入的每一个 channel 独立进行卷积，输入 feature map 的每个 channel 会输出 <strong>channel_multiplier</strong> (通常为 1) 个通道，最后的 feature map 就会有 in_channels * channel_multiplier 个通道了。</p><hr><p><img src="convs.jpg" alt="传统卷积和深度卷积以及逐点卷积的对比_1"></p><hr><p><img src="convs_2.jpg" alt="传统卷积和深度卷积以及逐点卷积的对比_2"></p><br><h1 id="group-convolution-and-channel-shuffle"><a class="markdownIt-Anchor" href="#group-convolution-and-channel-shuffle"></a> Group Convolution and channel shuffle</h1><p><img src="GConv.png" alt="分组卷积"></p><p><font color="orange"><strong>Group Convolution</strong></font> 顾名思义，是对输入 feature map 进行分组，然后每组分别卷积。假设输入 feature map 的尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi mathvariant="normal">∗</mi><mi>H</mi><mi mathvariant="normal">∗</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">C∗H∗W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>，输出 feature map 的数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，如果设定要分成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 个 groups，则每组的输入 feature map 数量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>C</mi><mi>G</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{C}{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，每组的输出 feature map 数量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>N</mi><mi>G</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，每个卷积核的尺寸为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>C</mi><mi>G</mi></mfrac><mo>×</mo><mi>K</mi><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\frac{C}{G}\times K\times K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>，卷积核的总数仍为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个，每组的卷积核数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>N</mi><mi>G</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，卷积核只与其同组的输入 map 进行卷积，卷积核的总参数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><mfrac><mi>C</mi><mi>G</mi></mfrac><mo>×</mo><mi>K</mi><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">N\times \frac{C}{G}\times K\times K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>，可见，总参数量减少为原来的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>G</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{G}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，其连接方式如上图右所示，group 1 的输出 map 数为 2，有 2 个卷积核，每个卷积核的 channel 数为 4，与 group1 的输入 map 的 channel 数相同，卷积核只与同组的输入 map 卷积，而不与其他组的输入 map 卷积。</p><p><font color="orange"><strong>Channel shuffle</strong></font>: 因为在<strong>同一组中不同的通道蕴含的信息可能是相同的</strong>，如果不进行通道交换的话，<strong>学出来的特征会非常局限</strong>。如果在不同的组之后交换一些通道，那么就能<strong>交换信息，使得各个组的信息更丰富</strong>，能提取到的特征自然就更多，这样是有利于得到更好的结果。</p><hr><p><img src="channel_shuffle.jpg" alt="Channel Shuffle"></p><p>ShuffleNet主要拥有两个创新点：</p><blockquote><ol><li>pointwise group convolution <font color="orange"><strong>逐点组卷积，就是带分组的卷积核为1×1的卷积，也就是说逐点组卷积是卷积核为 1×1 的分组卷积</strong></font>。</li><li>channel shuffle</li></ol></blockquote><p>原因：</p><blockquote><ol><li>逐点卷积占了很大的计算量 ———&gt; 逐点分组卷积</li><li>不同组之间特征通信问题   ———&gt; channel shuffle</li></ol></blockquote><hr><p><font color="orange"><strong>GDC :</strong></font> 更进一步，如果分组数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mi>N</mi><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">G=N=C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>，同时卷积核的尺寸与输入 map 的尺寸相同，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>=</mo><mi>H</mi><mo>=</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">K=H=W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>，则输出 map 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi mathvariant="normal">∗</mi><mn>1</mn><mi mathvariant="normal">∗</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">C∗1∗1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">∗</span><span class="mord">1</span><span class="mord">∗</span><span class="mord">1</span></span></span></span> 即长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 的向量，此时称之为 <strong>Global Depthwise Convolution（GDC）</strong>，见 MobileFaceNet，可以看成是全局加权池化，与 Global Average Pooling（GAP） 的不同之处在于，GDC 给每个位置赋予了可学习的权重（对于已对齐的图像这很有效，比如人脸，中心位置和边界位置的权重自然应该不同），而 GAP 每个位置的权重相同，全局取个平均，如下图所示：</p><hr><p><img src="GDC.png" alt="Global Depthwise Convolution"></p><br><h1 id="squeeze-and-excitation-module"><a class="markdownIt-Anchor" href="#squeeze-and-excitation-module"></a> Squeeze-and-Excitation module</h1><p><font color="orange"><strong>SE module</strong></font> 通过学习的方式来自动获取到每个特征通道的重要程度，然后依照计算出来的重要程度去提升有用的特征并抑制对当前任务用处不大的特征。<br><img src="SE.jpg" alt="SE module"></p><hr><blockquote><ol><li>首先做普通的卷积，得到了一个 output feature map，它的 shape 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>C</mi><mi mathvariant="normal">，</mi><mi>H</mi><mi mathvariant="normal">，</mi><mi>W</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[C，H，W]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mclose">]</span></span></span></span>，根据论文观点，这个 feature map 的特征很混乱。为了获得重要性的评价指标，直接对这个 feature map 做一个 Global Average Pooling，然后我们就得到了长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 的向量。（这里还涉及到一个额外的东西，如果你了解卷积，你就会发现一旦某一特征经常被激活，那么 Global Average Pooling 计算出来的值会比较大，说明它对结果的影响也比较大，反之越小的值，对结果的影响就越小）</li><li>然后我们对这个向量加两个 FC 层，做非线性映射，这两个 FC 层的参数，也就是网络需要额外学习的参数。</li><li>最后输出的向量，我们可以看做特征的重要性程度，然后与 feature map 对应 channel 相乘就得到特征有序的 feature map 了。</li></ol></blockquote><hr>]]></content>
      
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> Convolution </tag>
            
            <tag> FLOPs </tag>
            
            <tag> mobile </tag>
            
            <tag> shuffle </tag>
            
            <tag> SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的使用流程</title>
      <link href="/2019/05/31/Git-Usage/"/>
      <url>/2019/05/31/Git-Usage/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录一些使用 Git 进行版本管理的流程和命令。</p><a id="more"></a><h1 id="概念建立"><a class="markdownIt-Anchor" href="#概念建立"></a> 概念建立</h1><p>1 工作区: 代码所在的文件路径<br>2 暂存区: 使用 <code>git add &lt;filename&gt;</code>，将文件 <filename> 添加进 暂存区，待后续操作。<br>3 本地仓库: 使用  <code>git commit -m &quot;comments here&quot;</code> 将 暂存区的所有文件 commit 到本地仓库，本地仓库位于本机。<br>4 远程仓库: 在服务器端运行，可将本地仓库内容通过 <code>git push</code> 推送到远程仓库。</filename></p><br><h1 id="本地仓库和远程仓库的创建"><a class="markdownIt-Anchor" href="#本地仓库和远程仓库的创建"></a> 本地仓库和远程仓库的创建</h1><h2 id="1-添加远程库"><a class="markdownIt-Anchor" href="#1-添加远程库"></a> 1. 添加远程库</h2><p>为了方便管理，创建 git 用户.<br>在远程服务器上安装好 git 后，使用以下命令创建远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir example.git</span><br><span class="line"><span class="built_in">cd</span> example.git</span><br><span class="line">git --bare init</span><br></pre></td></tr></table></figure><p>用 <code>chown -R git:git example.git</code> 将 <code>example.git</code> 的所有者和群组改为 git.</p><h2 id="2-添加本地仓库"><a class="markdownIt-Anchor" href="#2-添加本地仓库"></a> 2. 添加本地仓库</h2><p>若已经拥有了远程仓库，可以通过 <code>git clone &lt;example.git&gt;</code> 的命令将远程仓库 clone 到本地。<br>若是对已存在的工程添加 git 管理，则在工程目录下，使用 <code>git init</code> 命令将其变成 git 管理的仓库。</p><br><h1 id="常用的-git-流程"><a class="markdownIt-Anchor" href="#常用的-git-流程"></a> 常用的 git 流程</h1><p>创建好本地仓库和远程仓库后，就可以使用 git 进行版本控制了。<br>若是对已存在的工程进行操作，则流程如下:</p><blockquote><p>1  使用 git add <filename> 的方式将文件添加到暂存区。若某工程第一次使用 git，用 <code>git add .</code> 将工程目录下的所有文件添加到暂存区。此操作可以在 <code>Git bash</code> 中通过命令行操作，或者在 <code>Git GUI</code> 通过图形界面操作。</filename></p></blockquote><blockquote><hr><p>2  若已在暂存区中添加了一些文件，可以通过 <code>git commit -m &quot;comments here&quot;</code> 将暂存区中所有文件 commit 到本地仓库的当前分支。</p></blockquote><blockquote><hr><p>3  若要将本地的当前分支，如 master 分支推送到远程仓库的 master 分支，则使用 <code>git push</code> 命令。</p><blockquote><p>注意: 应先将本地仓库与远程仓库关联，在本地 <code>example</code> 工程下，使用语句 <code>git remote add origin git@10.167.93.74:/path/to/example.git</code>. 这样，就将 <code>10.167.93.74:/path/to/example.git</code> 与本地 <code>example</code> 仓库关联上了。添加后，远程库的名字就是 <code>origin</code>，这是 Git 默认的叫法，也可以改成别的，但是 <code>origin</code> 这个名字一看就知道是远程库。</p></blockquote></blockquote><blockquote><blockquote><hr><p>关联后，使用命令 <code>git push -u origin master</code> 第一次推送 <code>master</code> 分支的所有内容；</p></blockquote></blockquote><blockquote><blockquote><hr><p>此后，每次本地提交后，只要有必要，就可以使用命令 <code>git push origin master</code> 推送最新修改；</p></blockquote></blockquote><blockquote><p>注意: 若不想将工程路径下的所有文件添加版本管理，则可以只将部分文件进行 add, 对从未进行过 add 操作的文件，将被视作 <code>untracked</code>.</p></blockquote><blockquote><hr><p>4  若对已经被 Git 管理的多个文件在某次 commit 后进行了修改，想将这些文件一次性进行 add，可以使用命令 <code>git add -u</code>. 这样，就不会将那些 <code>untracked</code> 的文件添加进暂存区 (git 术语为进行 stage). 若使用 <code>git add .</code> 命令，将会提交 <strong>新文件</strong> (new) 和 <strong>被修改</strong> (modified) 文件，这时，那些 <code>untracked</code> 的文件会被看作 <code>新文件</code>。</p><blockquote><p><code>Git add</code> 命令的 3 种用法:</p></blockquote></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .  : 监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改 (modified) 以及新文件 (new)，但不包括被删除的文件。</span><br><span class="line">git add -u : 仅监控已经被 add 的文件（即 tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add --update 的缩写）</span><br><span class="line">git add -A : 上面两个功能的合集（git add --all 的缩写）</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>示例</p></blockquote></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line"><span class="built_in">echo</span> Change me &gt; change-me</span><br><span class="line"><span class="built_in">echo</span> Delete me &gt; delete-me</span><br><span class="line">git add change-me delete-me</span><br><span class="line">git commit -m initial</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> OK &gt;&gt; change-me</span><br><span class="line">rm delete-me</span><br><span class="line"><span class="built_in">echo</span> Add me &gt; add-me</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># Changed but not updated:</span></span><br><span class="line"><span class="comment">#   modified:   change-me</span></span><br><span class="line"><span class="comment">#   deleted:    delete-me</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   add-me</span></span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   new file:   add-me</span></span><br><span class="line"><span class="comment">#   modified:   change-me</span></span><br><span class="line"><span class="comment"># Changed but not updated:</span></span><br><span class="line"><span class="comment">#   deleted:    delete-me</span></span><br><span class="line"></span><br><span class="line">git reset</span><br><span class="line"></span><br><span class="line">git add -u</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   modified:   change-me</span></span><br><span class="line"><span class="comment">#   deleted:    delete-me</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   add-me</span></span><br><span class="line"></span><br><span class="line">git reset</span><br><span class="line"></span><br><span class="line">git add -A</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   new file:   add-me</span></span><br><span class="line"><span class="comment">#   modified:   change-me</span></span><br><span class="line"><span class="comment">#   deleted:    delete-me</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><p><a href="https://www.cnblogs.com/skura23/p/5859243.html" target="_blank" rel="noopener">参考</a></p></blockquote></blockquote><br><h1 id="常用-git-命令"><a class="markdownIt-Anchor" href="#常用-git-命令"></a> 常用 Git 命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git status</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">git push &lt;remote&gt; &lt;<span class="built_in">local</span> branch name&gt;:&lt;remote branch to push into&gt;</span><br><span class="line">git <span class="built_in">log</span> --graph <span class="comment">#查看树状图</span></span><br></pre></td></tr></table></figure><br><h1 id="常用-git-工具"><a class="markdownIt-Anchor" href="#常用-git-工具"></a> 常用 Git 工具</h1><p>· Git Bash<br>· Git GUI<br>· Pycharm 上的 Git</p><br><h1 id="教程"><a class="markdownIt-Anchor" href="#教程"></a> 教程</h1><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程-廖雪峰</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> version control </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AlexeyAB/Darknet 的使用经验总结</title>
      <link href="/2019/05/31/AlexyAB-Darknet/"/>
      <url>/2019/05/31/AlexyAB-Darknet/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了 GitHub 上的热门 Repo <a href="https://github.com/AlexeyAB/darknet" target="_blank" rel="noopener">AlexeyAB/Darknet</a> 的一些使用要点。</p><a id="more"></a><h1 id="与-opencv-的速度比较"><a class="markdownIt-Anchor" href="#与-opencv-的速度比较"></a> 与 OpenCV 的速度比较</h1><blockquote><p> 使用 GPU 时此 Repo 速度比 OpenCV 快<br> 使用 CPU 时此 Repo 速度比 OpenCV 慢<br><a href="https://github.com/AlexeyAB/darknet/issues/3273#issuecomment-497096110" target="_blank" rel="noopener">来源</a></p></blockquote><br><h1 id="finetune-相关"><a class="markdownIt-Anchor" href="#finetune-相关"></a> Finetune 相关</h1><p>记在 base 数据集上训练得到的模型为 yolov3-old.weights, 当有新增数据集时，</p><blockquote><p> 若新增数据集和 base 数据<br>集类别一致，则在 yolov3-old.weights 的基础上，用 base+新增数据 进行训练。</p></blockquote><hr><blockquote><p> 若新增数据集包含其他类别，则先用 <code>darknet.exe partial cfg/yolov3.cfg yolov3.weights yolov3.conv.81 81</code> 得到 <code>yolov3.conv.81</code> 模型，再在此模型上用新数据集进行训练。<a href="https://github.com/AlexeyAB/darknet/issues/3264#issuecomment-496725772" target="_blank" rel="noopener">来源</a> <a href="https://github.com/AlexeyAB/darknet/blob/55dcd1bcb8d83f27c9118a9a4684ad73190e2ca3/build/darknet/x64/partial.cmd#L27" target="_blank" rel="noopener">partial命令</a></p></blockquote><br><h1 id="处理逻辑"><a class="markdownIt-Anchor" href="#处理逻辑"></a> 处理逻辑</h1><p>以使用单个 GPU 进行处理为例:</p><h2 id="训练"><a class="markdownIt-Anchor" href="#训练"></a> 训练</h2><p>假设 cfg 文件中定义的 <code>batch=64</code>, <code>subdivisions=16</code></p><hr><blockquote><p>&lt;1&gt; 解析各种配置文件，如 <code>coco.data</code>, <code>coco.names</code> 等，获取各种参数。<br>&lt;2&gt; 解析 <code>cfg</code> 文件并将其实例化为 <code>network net</code> 对象. (注意，此过程中 net.batch 参数不是 cfg 文件中的 batch 值，而是 cfg 文件中 batch/subdivisions 得到的值。<code>net.batch</code> 的值为真正进行前向传播时的 batch size)<br>&lt;3&gt; 加载预训练模型 - <code>weights</code> 文件到 <code>net</code> 对象中。<br>&lt;4&gt; 获取所有训练图像的路径。<br>&lt;5&gt; 创建一个线程用来从磁盘中 load 数据，每次从磁盘中 load cfg 文件中的 batch 张图像到内存。<br>&lt;6&gt; 迭代训练。<br>  &lt;6.1&gt; 将一次从磁盘中读取的 batch (cfg 文件中) 张图像分成 <code>subdivisions</code> 份，即每份为 <code>net.batch</code>。使用 <code>net.batch</code> 张图像进行一次迭代，同时返回一个 <code>batch</code> 的 <code>loss</code>，最后，对 <code>subdivisions</code> 个 batch 的 loss 进行加和平均，得到一次从磁盘读取的所有图像 (cfg 中 batch 张) 的平均 loss.<br>  &lt;6.2&gt; 不断重复步骤 6.1，在某些迭代次数时生成模型以及计算 mAP.</p></blockquote><hr><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p>由于 AlexeyAB 没有提供 批量测试 函数 (Batch Inference), 因此我自己实现了此功能。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// network.c 中添加以下函数</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> **<span class="title">network_predict_image_batch_gpu</span><span class="params">(<span class="keyword">float</span> *imgBatch, network* net, <span class="keyword">float</span> thresh, <span class="keyword">float</span> hier_thresh, <span class="keyword">float</span> nms, metadata meta, <span class="keyword">int</span>* box_nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> w = network_width(net);</span><br><span class="line"><span class="keyword">int</span> h = network_height(net);</span><br><span class="line"><span class="keyword">int</span> batch = net-&gt;batch;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// predict batch images</span></span><br><span class="line">network_predict(*net, imgBatch);</span><br><span class="line"><span class="built_in">free</span>(imgBatch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> **results = (<span class="keyword">float</span>**)<span class="built_in">calloc</span>(batch, <span class="keyword">sizeof</span>(<span class="keyword">float</span>*));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batch; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nboxes = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> letterbox = <span class="number">0</span>;</span><br><span class="line">detection * dets = get_network_boxes(net, w, h, thresh, hier_thresh, <span class="number">0</span>, <span class="number">1</span>, &amp;nboxes, letterbox);</span><br><span class="line">do_nms_sort(dets, nboxes, meta.classes, nms);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> real_box_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nboxes; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; meta.classes; s++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dets[j].prob[s] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">real_box_num += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(box_nums + i, &amp;real_box_num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">float</span> *res = (<span class="keyword">float</span>*)<span class="built_in">calloc</span>(real_box_num * <span class="number">6</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>)); <span class="comment">// 6 is &#123;x, y, w, h, prob, class&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nboxes; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; meta.classes; s++) &#123;</span><br><span class="line"><span class="keyword">float</span> now_prob = dets[j].prob[s];</span><br><span class="line"><span class="keyword">if</span> (now_prob &gt; <span class="number">0</span>) &#123;</span><br><span class="line">box b = dets[j].bbox;</span><br><span class="line"><span class="keyword">char</span> * nameTag = meta.names[s];</span><br><span class="line"><span class="keyword">float</span> x_ctr = b.x;</span><br><span class="line"><span class="keyword">float</span> y_ctr = b.y;</span><br><span class="line"><span class="keyword">float</span> width = b.w;</span><br><span class="line"><span class="keyword">float</span> height = b.h;</span><br><span class="line"><span class="keyword">float</span> cls_idx = (<span class="keyword">float</span>)s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(res, &amp;x_ctr, <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">res += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res, &amp;y_ctr, <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">res += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res, &amp;width, <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">res += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res, &amp;height, <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">res += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res, &amp;now_prob, <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">res += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res, &amp;cls_idx, <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">res += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res -= real_box_num * <span class="number">6</span>;</span><br><span class="line">results[i] = res;</span><br><span class="line"></span><br><span class="line">free_detections(dets, nboxes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; net-&gt;n; k++) &#123;</span><br><span class="line">layer temp_layer = net-&gt;layers[k];</span><br><span class="line"><span class="keyword">if</span> (temp_layer.type == YOLO || temp_layer.type == REGION || temp_layer.type == DETECTION) &#123;</span><br><span class="line">net-&gt;layers[k].output = net-&gt;layers[k].output + net-&gt;layers[k].outputs;</span><br><span class="line"><span class="comment">//temp_layer.output = temp_layer.output + temp_layer.outputs; 原来的版本</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要将 darknet 编译成 dll 供其他程序使用，则在 darknet.h 里 network_predict_image 附近 加上</span></span><br><span class="line">LIB_API float **network_predict_image_batch_gpu(float *imgBatch, network* net, float thresh, float hier_thresh, float nms, metadata meta, int* box_nums)；</span><br></pre></td></tr></table></figure><p>调用此函数的示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* configPath = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/cfg/yolov3-mlit-SD.cfg"</span>;</span><br><span class="line"><span class="keyword">char</span>* weightPath = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/backup/yolov3-mlit-SD_50000.weights"</span>;</span><br><span class="line"><span class="keyword">char</span>* metaPath = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/cfg/mlit.data"</span>;</span><br><span class="line"><span class="built_in">string</span> result_dir = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/result/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* img_path_1 = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/test_images/test_1.jpg"</span>;</span><br><span class="line"><span class="keyword">char</span>* img_path_2 = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/test_images/test_2.jpg"</span>;</span><br><span class="line"><span class="keyword">char</span>* img_path_3 = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/test_images/test_3.jpg"</span>;</span><br><span class="line"><span class="keyword">char</span>* img_path_4 = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/test_images/test_4.jpg"</span>;</span><br><span class="line"><span class="keyword">char</span>* img_path_5 = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/test_images/test_5.jpg"</span>;</span><br><span class="line"><span class="keyword">char</span>* img_path_6 = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/mlit_yolo/mlit_yolo/test_images/test_6.jpg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> batchSize = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **img_paths = (<span class="keyword">char</span>**)<span class="built_in">calloc</span>(batchSize, <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">img_paths[<span class="number">0</span>] = img_path_1;</span><br><span class="line">img_paths[<span class="number">1</span>] = img_path_2;</span><br><span class="line">img_paths[<span class="number">2</span>] = img_path_3;</span><br><span class="line">img_paths[<span class="number">3</span>] = img_path_4;</span><br><span class="line">img_paths[<span class="number">4</span>] = img_path_5;</span><br><span class="line">img_paths[<span class="number">5</span>] = img_path_6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> conf_thresh = <span class="number">0.6</span>;</span><br><span class="line"><span class="keyword">float</span> hier_thresh = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">float</span> nms = <span class="number">0.45</span>;</span><br><span class="line"></span><br><span class="line">cuda_set_device(<span class="number">0</span>);</span><br><span class="line">network* netMain = load_network_custom(configPath, weightPath, <span class="number">0</span>, batchSize);</span><br><span class="line">metadata metaMain = get_metadata(metaPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> input_w = network_width(netMain);</span><br><span class="line"><span class="keyword">int</span> input_h = network_height(netMain);</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//int num_calsses = metaMain.classes;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里得到的 batch 就是上面手动设置的 batchSize</span></span><br><span class="line"><span class="keyword">int</span> batch = netMain-&gt;batch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 char** 中读取图像数据，并合并成 float *</span></span><br><span class="line"><span class="keyword">float</span> *imgBatch = (<span class="keyword">float</span>*)<span class="built_in">calloc</span>(batch * input_w * input_h * c, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//No OpenCV</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batch; i++) &#123;</span><br><span class="line">image dark_image = load_image_color(img_paths[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">image resized = resize_image(dark_image, input_w, input_h);</span><br><span class="line"><span class="built_in">memcpy</span>(imgBatch + i*input_w*input_h*c, resized.data, input_w*input_h*c * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *box_num_batch = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(batch, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">float</span> **results = network_predict_image_batch_gpu(imgBatch, netMain, conf_thresh, hier_thresh, nms, metaMain, box_num_batch);</span><br><span class="line"><span class="keyword">float</span> *res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 results</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batch; i++) &#123;</span><br><span class="line">cv::Mat image2show = cv::imread(img_paths[i]);</span><br><span class="line"><span class="keyword">int</span> ori_w = image2show.cols;</span><br><span class="line"><span class="keyword">int</span> ori_h = image2show.rows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nbox = *(box_num_batch + i);</span><br><span class="line">res = results[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; nbox &lt;&lt; <span class="string">" boxes detected"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nbox; j++) &#123;</span><br><span class="line"><span class="keyword">float</span> x_ctr = res[<span class="number">0</span> + <span class="number">6</span> * j];</span><br><span class="line"><span class="keyword">float</span> y_ctr = res[<span class="number">1</span> + <span class="number">6</span> * j];</span><br><span class="line"><span class="keyword">float</span> width = res[<span class="number">2</span> + <span class="number">6</span> * j];</span><br><span class="line"><span class="keyword">float</span> height = res[<span class="number">3</span> + <span class="number">6</span> * j];</span><br><span class="line"><span class="keyword">float</span> prob = res[<span class="number">4</span> + <span class="number">6</span> * j];</span><br><span class="line"><span class="keyword">float</span> cls_idx = res[<span class="number">5</span> + <span class="number">6</span> * j];</span><br><span class="line"><span class="keyword">char</span> * nameTag = metaMain.names[(<span class="keyword">int</span>)(cls_idx)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w_on_ori = (<span class="keyword">int</span>)(width * ori_w);</span><br><span class="line"><span class="keyword">int</span> h_on_ori = (<span class="keyword">int</span>)(height * ori_h);</span><br><span class="line"><span class="keyword">int</span> lft = (<span class="keyword">int</span>)(x_ctr * ori_w - w_on_ori / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> rgt = (<span class="keyword">int</span>)(x_ctr * ori_w + w_on_ori / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> top = (<span class="keyword">int</span>)(y_ctr * ori_h - h_on_ori / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> bot = (<span class="keyword">int</span>)(y_ctr * ori_h + h_on_ori / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">cv::<span class="function">Point <span class="title">pt1</span><span class="params">(lft, top)</span></span>;</span><br><span class="line">cv::<span class="function">Point <span class="title">pt2</span><span class="params">(rgt, bot)</span></span>;</span><br><span class="line">cv::rectangle(image2show, pt1, pt2, Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> text = <span class="built_in">std</span>::<span class="built_in">string</span>(nameTag) + <span class="string">" ["</span> + to_string(<span class="keyword">int</span>(round(prob * <span class="number">100</span>))) + <span class="string">"]"</span>;</span><br><span class="line">cv::putText(image2show, text, Point(pt1.x, pt1.y - <span class="number">5</span>), cv::FONT_HERSHEY_COMPLEX, <span class="number">0.5</span>, Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt; %d %d %d %d %f &lt;&lt;&lt; "</span>, (<span class="keyword">int</span>)(x_ctr * ori_w), (<span class="keyword">int</span>)(y_ctr * ori_h), (<span class="keyword">int</span>)(width * ori_w), (<span class="keyword">int</span>)(height * ori_h), prob);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; nameTag &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv::imshow(<span class="string">"detected"</span>, image2show);</span><br><span class="line">cv::waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//free(res);</span></span><br><span class="line"><span class="comment">//free_detections(res, nbox);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(box_num_batch);</span><br><span class="line"><span class="built_in">free</span>(results);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="主存与显存"><a class="markdownIt-Anchor" href="#主存与显存"></a> 主存与显存</h1><p>在此 repo 的实现中，数据是先从磁盘读取到主存中，然后在使用 GPU 进行训练前，将主存中的数据拷贝至显存对象中，然后使用 GPU 进行运算。<br>参考 <code>network_kernels.cu</code> 中的 <code>float *network_predict_gpu(network net, float *input)</code> 函数。</p><p>在 Traffic counter 项目中，将来可能使用 GPU 版本的解码器，此解码器解码后的图像数据是在显存中的。因此，设想在将来的处理中，将略过从主存往显存拷贝数据这一步骤，直接传递显存中的对象，并进行处理。具体实现时，可重点参考 <code>float *network_predict_gpu(network net, float *input)</code> 函数。</p><h2 id="confidence-threshold"><a class="markdownIt-Anchor" href="#confidence-threshold"></a> Confidence threshold</h2><h2 id="nms-threshold"><a class="markdownIt-Anchor" href="#nms-threshold"></a> NMS threshold</h2><hr>]]></content>
      
      
      
        <tags>
            
            <tag> gpu </tag>
            
            <tag> yolo </tag>
            
            <tag> yolov3 </tag>
            
            <tag> darknet </tag>
            
            <tag> cpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV 4.0.1 + CUDA 8.0 + Visual Studio 2015 + Win10</title>
      <link href="/2019/05/20/Build-opencv-with-GPU/"/>
      <url>/2019/05/20/Build-opencv-with-GPU/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了使用 CUDA 8.0，Visual Studio 2015，Win10 来编译 OpenCV 4.0.1 的步骤。</p><a id="more"></a><h1 id="安装流程"><a class="markdownIt-Anchor" href="#安装流程"></a> 安装流程</h1><blockquote><p>[1].   安装好 CUDA 8.0. 各种路径添加到环境变量。</p></blockquote><hr><blockquote><p>[2]. 下载 Opencv 源码到 <code>&lt;OpenCV_DIR&gt;</code> 及 对应版本的 opencv_contrib 到 <code>&lt;OpenCV_CONTRIB_DIR&gt;</code>.</p></blockquote><hr><blockquote><p>[3]. Cmake 生成 VS solution。<br>  3.1 打开 cmake. 在 <code>where is the source code</code> 中填入 <code>&lt;OpenCV_DIR&gt;</code>, 在 <code>Where to build the binaries</code> 中 填入 <code>&lt;OpenCV_DIR/build&gt;</code>。<br>  3.2 点击 configure, 选择 <code>Visual Studio 14 2015 Win64</code>. (一定要选带有 Win 64 字样的，否则会出错)<br>  3.3 点击 Finish。会进行 Configure。中途可能会跳出红色错误，这是由于下载 ffmpeg, ippicv, data, xfeatures2d 相关的文件失败造成的。报错信息里会提示查看 log 文件，打开 log 文件后，根据信息，手动到网址下去下载 dll, zip, cmake 等文件，下载好后，以 <code>&lt;MD码&gt;-&lt;name&gt;.&lt;ext&gt;</code> 的方式命名，放在 <code>&lt;OpenCV_DIR/.cache&gt;</code> 下的相关路径中。重新点击 configure.<br>  3.4 勾选中复选框 <code>BUILD_opencv_world</code>, <code>WITH_CUDA</code>, <code>OPENCV_ENABLE_NONFREE</code>. 将 <code>&lt;OpenCV_CONTRIB_DIR/modules&gt;</code> 路径添加到 <code>OPENCV_EXTRA_MODULES_PATH</code> 中，再次点击 Configure.<br>  3.5 勾选 <code>CUDA_FAST_MATH</code>, 点击 Configure. 屏幕上应该一片白，没有红色信息.<br>  3.5 点击 Generate 以生成 sln. 此过程不应报错。</p></blockquote><hr><blockquote><p>[4]. VS 编译 Opencv.sln<br>  4.1 <code>&lt;OpenCV_DIR/build&gt;</code> 下打开 OpenCV.sln, 点击 生成 -&gt; 配置管理器，选择 <code>Release</code>, <code>x64</code>.<br>  4.2 将 <code>color_detail.hpp</code> 的 <code>96-127</code> 行的 <strong><code>const</code></strong> 替换为 <strong><code>constexpr</code></strong>. 否则会出现 <code>error : dynamic initialization is not supported for a __constant__ variable</code> 的错误. <a href="https://github.com/opencv/opencv/issues/13491#issuecomment-450754826" target="_blank" rel="noopener">来源1</a>  <a href="https://answers.opencv.org/question/205673/building-opencv-with-cuda-win10-vs-2017/" target="_blank" rel="noopener">来源2</a><br>  4.3 生成 <code>ALL_BUILD</code>. (主要关注 opencv_world 工程，此工程生成成功即可，实际过程中出现了 opencv_perf_gapi 和 opencv_test_gapi 工程报错的问题，貌似对我们的项目没有影响。)<br>  4.4 成功生成 <code>ALL_BUILD</code> 后 (生成了 opencv_world401.lib 和 opencv_world401.dll)，右键 <code>INSTALL</code> -&gt; <code>仅用于项目</code> -&gt; <code>仅生成INSTALL</code>.<br>  4.5 在 <code>&lt;OpenCV_DIR/install&gt;</code> 下是最后得到的 lib, dll，头文件等。</p></blockquote><h1 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h1><p><a href="https://blog.csdn.net/Gordon_Wei/article/details/85775328" target="_blank" rel="noopener">【OpenCV】opencv4.0.1+opencv_contrib4.0.1+VS2015的编译</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> vs </tag>
            
            <tag> cuda </tag>
            
            <tag> gpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyinstaller with Scipy</title>
      <link href="/2019/04/02/Pyinstaller-with-Scipy/"/>
      <url>/2019/04/02/Pyinstaller-with-Scipy/</url>
      
        <content type="html"><![CDATA[<p>在将 python 工程用 pyinstaller 打包成 exe 时，由于 import 了 scipy 的一些功能，因此生成的 exe 一直报错，经过努力终于解决。</p><a id="more"></a><h1 id="问题来源"><a class="markdownIt-Anchor" href="#问题来源"></a> 问题来源</h1><p>在 MLIT 的项目中，有使用到 scipy 库中的一个函数。因此，有 <code>from scipy.spatial.distance import cdist</code> 这句，但是突然不知道哪里发生了改动 (推测是某些库的版本在安装其他库时发生了变化)，打包好的 exe 在执行上述 import 语句时总是报错。</p><h1 id="trail-and-error"><a class="markdownIt-Anchor" href="#trail-and-error"></a> Trail and Error</h1><ol><li>由于 scipy 的版本在上次发版之后发生了改变（不知为啥），现在的版本为 1.2.0. 根据 <code>lib/site-packages/</code> 的痕迹推测之前的版本为 1.0.0. 但将 scipy 重装为 1.0.0 后仍然不成功。</li><li>按步骤 1 的方式操作后，<code>scipy/spatial/_spherical_voronoi.py</code> 中的 第 18 行 <code>from . import _voronoi</code> 仍然报错，大意为 <code>cannot import name _voronoi</code>. 其中，<code>_voronoi</code> 为 <code>scipy/spatial/</code>文件夹下的一个 pyd 文件，为 <code>_voronoi.pyd</code>. 可是事实上，我在 convert 的 bat 脚本中明明有通过 <code>hidden-import</code> 将此文件导入进去，生成的文件夹中也确实存在这个文件，但是程序总是无法成功导入。</li><li>后来经过搜索与分析，在 convert 脚本中添加了一行 <code>--paths=&quot;H:\Develop\Anaconda2\setup\Lib\site-packages\scipy\extra-dll&quot;</code>，就成功了。</li></ol><h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h1><p>上述方法成功后，分析成功原因。在执行 convert 脚本时，有一系列跟 scipy 有关的 warning. 大致都是说 hidden-import 的 pyd 文件的依赖 dll 找不到，而这些 warning 在我印象中以前并未出现过。在添加了 <code>--paths=&quot;H:\Develop\Anaconda2\setup\Lib\site-packages\scipy\extra-dll</code> 这一参数后，不再有这些 warning, exe 也可以成功执行。</p><h1 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h1><p><a href="convert_server.bat">完整的 convert 脚本</a><br><a href="mlit_pkg_version_20190402.txt">python库版本</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> pyinstaller </tag>
            
            <tag> scipy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光流法</title>
      <link href="/2019/02/25/optical-flow/"/>
      <url>/2019/02/25/optical-flow/</url>
      
        <content type="html"><![CDATA[<p>对光流法进行了一个大致的了解，并了解了在高速情况下通过图像金字塔进行光流计算的方法。</p><a id="more"></a><h1 id="光流的定义"><a class="markdownIt-Anchor" href="#光流的定义"></a> 光流的定义</h1><p><strong>光流</strong> 是空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中像素在时间域上的变化以及相邻帧之间的相关性来找到上一帧跟当前帧之间存在的对应关系，从而计算出相邻帧之间物体的运动信息的一种方法。一般而言，光流是由于场景中前景目标本身的移动、相机的运动，或者两者的共同运动所产生的。</p><h1 id="光流法的原理"><a class="markdownIt-Anchor" href="#光流法的原理"></a> 光流法的原理</h1><h2 id="光流法的基本假设"><a class="markdownIt-Anchor" href="#光流法的基本假设"></a> 光流法的基本假设</h2><ol><li><font color="orange">亮度恒定不变，</font>即同一目标在不同帧间运动时，其亮度不会发生改变。这是基本光流法的假定（所有光流法变种都必须满足），用于得到光流法基本方程</li><li><font color="orange">时间连续或运动是“小运动”，</font>即时间的变化不会引起目标位置的剧烈变化，相邻帧之间位移要比较小。同样也是光流法不可或缺的假定。</li></ol><h2 id="基本约束方程"><a class="markdownIt-Anchor" href="#基本约束方程"></a> 基本约束方程</h2><p>根据光流法的基本假设，可以推导得出光流法的基本约束方程。<br>  考虑一个三维的矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>  其三个维度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 为图像的两个维度，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 为时间维度。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I(x,y,t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 时刻的图像在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 坐标上的灰度值。<br>  根据两个基本假设，可得到方程</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>I</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>d</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mi>d</mi><mi>y</mi><mo separator="true">,</mo><mi>t</mi><mo>+</mo><mi>d</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I(x,y,t) = I(x+dx, y+dy, t+dt)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></span></p><p>由于是小运动，因此可对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>d</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mi>d</mi><mi>y</mi><mo separator="true">,</mo><mi>t</mi><mo>+</mo><mi>d</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I(x+dx, y+dy, t+dt)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span> 进行泰勒展开，即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>d</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mi>d</mi><mi>y</mi><mo separator="true">,</mo><mi>t</mi><mo>+</mo><mi>d</mi><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>I</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac><mi>d</mi><mi>x</mi><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow></mfrac><mi>d</mi><mi>y</mi><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>t</mi></mrow></mfrac><mi>d</mi><mi>t</mi><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">I(x+dx, y+dy, t+dt) = I(x,y,t) + \frac{\partial I}{\partial x}dx + \frac{\partial I}{\partial y}dy + \frac{\partial I}{\partial t}dt+\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></span></p><p>结合上式，得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac><mi>d</mi><mi>x</mi><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow></mfrac><mi>d</mi><mi>y</mi><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>t</mi></mrow></mfrac><mi>d</mi><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\frac{\partial I}{\partial x}dx + \frac{\partial I}{\partial y}dy + \frac{\partial I}{\partial t}dt=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">u=\frac{dx}{dt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">v=\frac{dy}{dt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, 得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>I</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\frac{\partial I}{\partial x}\frac{dx}{dt} + \frac{\partial I}{\partial y}\frac{dy}{dt} + \frac{\partial I}{\partial t}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>x</mi></msub><mi>u</mi><mo>+</mo><msub><mi>I</mi><mi>y</mi></msub><mi>v</mi><mo>=</mo><mo>−</mo><msub><mi>I</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">I_x u+I_y v=-I_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>这就是光流的基本约束方程。</p><h2 id="lucas-kanade-光流算法"><a class="markdownIt-Anchor" href="#lucas-kanade-光流算法"></a> Lucas-Kanade 光流算法</h2><p>  由于光流的基本约束方程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>x</mi></msub><mi>u</mi><mo>+</mo><msub><mi>I</mi><mi>y</mi></msub><mi>v</mi><mo>=</mo><mo>−</mo><msub><mi>I</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">I_x u+I_y v=-I_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 只有一个约束，但是却有两个未知数，因此无法求解。为了能够求解出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>, 需要引入新的约束。<br>  Lucas-Kanade 光流算法引入了 <font color="orange"><strong>空间一致</strong></font> 假设，即所有的相邻像素有相似的行动。也即在目标像素周围 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的区域内，每个像素均拥有相同的光流矢量。以此假设解决式</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>x</mi></msub><mi>u</mi><mo>+</mo><msub><mi>I</mi><mi>y</mi></msub><mi>v</mi><mo>=</mo><mo>−</mo><msub><mi>I</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">I_x u+I_y v=-I_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>无法求解的问题。</p><p><img src="LK.png" alt="LK光流法"><br>具体推导过程，参考 <a href="https://blog.csdn.net/sgfmby1994/article/details/68489944" target="_blank" rel="noopener">总结：光流–LK光流–基于金字塔分层的LK光流–中值流</a></p><br><h1 id="基于金字塔分层的-lk-光流法"><a class="markdownIt-Anchor" href="#基于金字塔分层的-lk-光流法"></a> 基于金字塔分层的 LK 光流法</h1><p>  根据光流的基本假设 2，光流适用于 <strong>小运动</strong> 场景，即相邻帧之间运动较小。因此，光流法无法直接处理运动较大的情况。因此，在处理运动较大的情况时，需要通过图像金字塔的方式。<br>具体细节，同样参考 <a href="https://blog.csdn.net/sgfmby1994/article/details/68489944" target="_blank" rel="noopener">总结：光流–LK光流–基于金字塔分层的LK光流–中值流</a></p><br><h1 id="基于光流的运动目标检测前景检测算法"><a class="markdownIt-Anchor" href="#基于光流的运动目标检测前景检测算法"></a> 基于光流的运动目标检测（前景检测）算法</h1><p><img src="fg.png" alt="基于光流的运动目标检测（前景检测）算法流程图"><br>参考这篇文章 <a href="https://blog.csdn.net/qq_41368247/article/details/82562165" target="_blank" rel="noopener">计算机视觉–光流法(optical flow)简介</a></p><br><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><p><a href="https://blog.csdn.net/sgfmby1994/article/details/68489944" target="_blank" rel="noopener">总结：光流–LK光流–基于金字塔分层的LK光流–中值流</a><br><a href="https://blog.csdn.net/qq_41368247/article/details/82562165" target="_blank" rel="noopener">计算机视觉–光流法(optical flow)简介</a><br><a href="https://blog.csdn.net/jobbofhe/article/details/80448961" target="_blank" rel="noopener">【计算机视觉】光流法简单介绍</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> optical flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协方差及协方差矩阵</title>
      <link href="/2019/01/25/covariance-and-covariance-matrix/"/>
      <url>/2019/01/25/covariance-and-covariance-matrix/</url>
      
        <content type="html"><![CDATA[<p>本文主要关注了协方差的定义、含义，协方差矩阵的性质以及 PCA 与协方差矩阵的关系</p><a id="more"></a><p>关于协方差的定义，这篇文章解释得很好<br><a href="https://blog.csdn.net/northeastsqure/article/details/50163031" target="_blank" rel="noopener">终于明白协方差的意义了</a></p><p>关于协方差矩阵的特征值特征向量和 PCA 的关系。这篇文章解释得很好。<br><a href="https://www.cnblogs.com/dengdan890730/p/5495078.html" target="_blank" rel="noopener">PCA算法是怎么跟协方差矩阵/特征值/特征向量勾搭起来的?</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 协方差 </tag>
            
            <tag> 协方差矩阵 </tag>
            
            <tag> PCA </tag>
            
            <tag> 主成分分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos 系统下深度学习环境配置及 tensorflow 安装</title>
      <link href="/2018/12/07/linux-install-setting-process/"/>
      <url>/2018/12/07/linux-install-setting-process/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了在新安装完 Centos 系统后的 NVIDIA 显卡驱动、cuda、cudnn、以及 TensorFlow 等 python 库的安装及配置。</p><a id="more"></a><p>更改启动设置</p><blockquote><p>(1) 查看系统默认启动环境。<code>systemctl get-default</code> -&gt; <code>graphical.target</code><br>(2) 将默认启动环境设置为命令行。<code>systemctl set-default multi-user.target</code><br>(3) <code>reboot</code></p></blockquote><p>禁用系统自带的 nouveau 显卡驱动。</p><blockquote><p>(4) run the NVIDIA driver file, it will create two <code>.conf</code> file to disable the nouveau driver for you under <code>/etc/modeprobe.d</code> and <code>/usr/...</code></p></blockquote><p>重做内核镜像</p><blockquote><p>(5) <code>mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r)-nouveau.img</code>  # Backup image<br>(6) <code>dracut /boot/initramfs-$(uname -r).img $(uname -r)</code> # Create a new image<br>(7) <code>reboot</code></p></blockquote><p>安装 NVIDIA 显卡驱动</p><blockquote><p>(8) run the NVIDIA driver file again, finish the installation of NVIDIA driver.</p></blockquote><p>安装 Cuda</p><blockquote><p>(9) Install cuda 8.0, do not install the driver provided by cuda since we already installed the NVIDIA driver before.<br>(10) add <code>export PATH=/usr/local/cuda-8.0/bin:$PATH</code> and <code>export LD_LIBRARY_PATH=/usr/local/cuda-8/lib64:$LD_LIBRARY_PATH</code> to <code>~/.bashrc</code><br>(11) <code>source ~/.bashrc</code></p></blockquote><p>解压 cudnn</p><blockquote><p>(12) <code>tar zxvf cudnn.tgz</code> # extract cudnn files<br>copy extracted files to the corresponding folders under cuda installation directory</p></blockquote><p>安装 Anaconda/python</p><blockquote><p>(13) Install Ananconda. Do not add the Ananconda path to <code>/root/.bashrc</code>, add it to <code>~/.bashrc</code>.<br>(14) <code>source ~/.bashrc</code></p></blockquote><p>安装 tensorflow 或其他 python 库</p><blockquote><p>(15) <code>pip install tensorflow-gpu==1.0.0</code>. # Install GPU version tensorflow 1.0.0</p></blockquote><p>注意，安装 <code>1.0.0</code> 的 tensorflow 时，<code>numpy==1.16.2</code> 貌似会报错。因此，需要 check 一下 Anaconda 中 numpy 的版本。如果需要安装，则安装 <code>pip install numpy==1.14.2</code>。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下利用共享内存实现进程间通信</title>
      <link href="/2018/12/03/Inter-Process-Communication-by-Shared-Memory-on-Windows/"/>
      <url>/2018/12/03/Inter-Process-Communication-by-Shared-Memory-on-Windows/</url>
      
        <content type="html"><![CDATA[<p>本文主要记载了在 Windows 下如何通过调用 WinApi ，利用 <code>共享内存</code> 实现 进程间通信 (Inter Process Communication, IPC).</p><a id="more"></a><p><strong>本文主要是通过 FileMapping 的方式实现进程间通信。目前已实现进程间共享字符串以及 opencv 的 Mat 对象 （以 <code>uchar *</code> 方式）。</strong></p><br><h1 id="两个-c-进程之间的通信"><a class="markdownIt-Anchor" href="#两个-c-进程之间的通信"></a> 两个 C++ 进程之间的通信</h1><p>参考文章 <a href="https://blog.csdn.net/u012234115/article/details/82114631" target="_blank" rel="noopener">C++共享内存实现（windows和linux）</a></p><p>上面的文章只实现了字符串的进程间通信，根据实际需要，需要进程间传递图像对象，此处使用 opencv 的 <code>Mat</code> 对象来表示。由于 <code>Mat</code> 对象有一个 <code>uchar* data</code> 属性，指向 Mat 的实际数据。因此，这里通过传输 <code>uchar* data</code> 到共享内存，并在 Reader 中重建 <code>Mat</code> 对象 (C++)。<br>参考文章 <a href="https://www.cnblogs.com/Lalafengchui/p/4223584.html" target="_blank" rel="noopener">Windows进程间通信–共享内存映射文件（FileMapping）</a>.</p><p><strong>注意:</strong> 这里在传递时需要将图像的 长、宽、高 等参数一并传递，这样在 Reader 中可以根据读到的尺寸进行恢复。因为在 Reader 端一开始得到的是共享内存的首地址。C++ 中用三个 <code>int</code> 类型来表示 <code>width</code>, <code>height</code>, <code>channel</code>。这三个 <code>int</code> 是写到表示数据的 <code>uchar *</code> 的最前面的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code snippet in img_reader.cpp</span></span><br><span class="line"><span class="keyword">int</span> width, height;</span><br><span class="line">uchar* tmp = (uchar*) <span class="built_in">malloc</span>(buffer_size);</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, &amp;width, <span class="keyword">sizeof</span>(width)) <span class="comment">// 将 width 首地址开始的 4 个 byte 内容拷贝到 tmp 所指向的地址。</span></span><br><span class="line">tmp += <span class="keyword">sizeof</span>(width); <span class="comment">// tmp 向后移动 sizeof(width) 个 uchar 的长度。</span></span><br><span class="line"><span class="built_in">memcpy</span>(tmp, &amp;height, <span class="keyword">sizeof</span>(height))</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(height)</span><br></pre></td></tr></table></figure><br><h1 id="c-和-python-进程之间的通信"><a class="markdownIt-Anchor" href="#c-和-python-进程之间的通信"></a> C++ 和 python 进程之间的通信</h1><p><em>C++ 作 Writer， python 作 Reader</em><br>参考文章：<a href="https://mail.python.org/pipermail/python-list/2005-March/302108.html" target="_blank" rel="noopener">Shared Memory Example (Python, ctypes, VC++)</a>。<br>python 中 使用 <code>ctypes</code> 来调用 <code>win32 api</code>，方法与 C++ Reader 中的类似。区别在于获取共享内存的首地址后，python 中可以通过 slicing 的方式获取不同地址的值。最后得到 width, height, channel 以及数据，将数据转换成 ndarray 即可使用 opencv 显示。</p><br><h1 id="filemapping-原理"><a class="markdownIt-Anchor" href="#filemapping-原理"></a> FileMapping 原理</h1><p>这里使用了 FileMapping 的方式进行 IPC。<br>Writer 使用的 API 有</p><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createfilea" target="_blank" rel="noopener">CreateFile</a><br><a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-createfilemappinga" target="_blank" rel="noopener">CreateFileMapping</a><br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366761%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">MapViewOfFile</a><br><code>MapViewOfFile</code> 最后返回的是共享内存的指针。通过将数据 <code>memcpy</code> 到这里实现共享。</p></blockquote><p>Reader 使用的 API 有</p><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-openfilemappinga" target="_blank" rel="noopener">OpenFileMapping</a><br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366761%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">MapViewOfFile</a><br><code>MapViewOfFile</code> 最后返回的是共享内存的指针。可通过从这里读数据重建图像。</p></blockquote><p>关于以上提及 API 的详细解释：</p><blockquote><p><a href="https://blog.csdn.net/bxsec/article/details/76566011" target="_blank" rel="noopener">Windows核心编程-CreateFile详解</a></p></blockquote><br><h1 id="file-mapping-代码"><a class="markdownIt-Anchor" href="#file-mapping-代码"></a> File Mapping 代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// img_writer.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\core\core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\highgui\highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct MyData</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//int width;</span></span><br><span class="line"><span class="comment">//int height;</span></span><br><span class="line"><span class="comment">//int channel;</span></span><br><span class="line"><span class="comment">//MyData(int _width, int _height, int _channel) : width(_width), height(_height), channel(_channel)</span></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeMemory</span><span class="params">(<span class="keyword">char</span>* imgDir)</span> </span>&#123;</span><br><span class="line"><span class="comment">// define shared data</span></span><br><span class="line"><span class="keyword">char</span> *shared_file_name = <span class="string">"file_name_sean"</span>;</span><br><span class="line"><span class="keyword">char</span> * shared_object_name = <span class="string">"Local\\object_name_sean"</span>;</span><br><span class="line"></span><br><span class="line">Mat img = imread(imgDir, IMREAD_COLOR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> width = img.cols;</span><br><span class="line"><span class="keyword">int</span> height = img.rows;</span><br><span class="line"><span class="keyword">int</span> channel = img.channels();</span><br><span class="line">uchar* img_data = img.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> data_size = <span class="keyword">sizeof</span>(uchar) * width * height * channel;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> buffer_size = data_size + <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"share buffer "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create shared memory file</span></span><br><span class="line">HANDLE hFile = CreateFile(shared_file_name,</span><br><span class="line">GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_ALWAYS, <span class="comment">// open exist or create new, overwrite file</span></span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"create file error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">HANDLE shared_file_handler = CreateFileMapping(</span><br><span class="line">hFile, <span class="comment">// Use paging file - shared memory</span></span><br><span class="line"><span class="literal">NULL</span>,                 <span class="comment">// Default security attributes</span></span><br><span class="line">PAGE_READWRITE,       <span class="comment">// Allow read and write access</span></span><br><span class="line"><span class="number">0</span>,                    <span class="comment">// High-order DWORD of file mapping max size</span></span><br><span class="line">buffer_size,            <span class="comment">// Low-order DWORD of file mapping max size</span></span><br><span class="line">shared_object_name);    <span class="comment">// Name of the file mapping object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shared_file_handler) &#123;</span><br><span class="line"><span class="comment">// map memory file view, get pointer to the shared memory</span></span><br><span class="line">LPVOID lp_base = MapViewOfFile(</span><br><span class="line">shared_file_handler,  <span class="comment">// Handle of the map object</span></span><br><span class="line">FILE_MAP_ALL_ACCESS,  <span class="comment">// Read and write access</span></span><br><span class="line"><span class="number">0</span>,                    <span class="comment">// High-order DWORD of the file offset</span></span><br><span class="line"><span class="number">0</span>,                    <span class="comment">// Low-order DWORD of the file offset</span></span><br><span class="line">buffer_size);           <span class="comment">// The number of bytes to map to view</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// write width, height, channel to a memory</span></span><br><span class="line">uchar* tmp = (uchar*) <span class="built_in">malloc</span>(buffer_size);</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, &amp;width, <span class="keyword">sizeof</span>(width));</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(width);</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, &amp;height, <span class="keyword">sizeof</span>(height));</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(height);</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, &amp;channel, <span class="keyword">sizeof</span>(channel));</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(channel);</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, img.data, data_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">uchar val = tmp[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy data to shared memory</span></span><br><span class="line">tmp -= <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">3</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(lp_base, tmp, buffer_size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line"></span><br><span class="line">FlushViewOfFile(lp_base, buffer_size); <span class="comment">// can choose save to file or not</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// process wait here for other task to read data</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"already write to shared memory, wait ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">this_thread::sleep_for(chrono::seconds(<span class="number">6000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// close shared memory file</span></span><br><span class="line">UnmapViewOfFile(lp_base);</span><br><span class="line">CloseHandle(shared_file_handler);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"shared memory closed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"create mapping file error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* imgDir = <span class="string">"C:/Users/taoxuan.G08/Documents/Visual Studio 2015/Projects/cnpy-solution/cv/vehicle.jpeg"</span>;</span><br><span class="line">writeMemory(imgDir);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// img_reader.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\core\core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\highgui\highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *shared_object_name = <span class="string">"Local\\object_name_sean"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// open shared memory file</span></span><br><span class="line">HANDLE shared_file_handler = OpenFileMapping(</span><br><span class="line">FILE_MAP_ALL_ACCESS,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">shared_object_name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shared_file_handler) &#123;</span><br><span class="line"></span><br><span class="line">LPVOID lp_base = MapViewOfFile(</span><br><span class="line">shared_file_handler,</span><br><span class="line">FILE_MAP_ALL_ACCESS,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy shared data from memory</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"read shared data: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">uchar* tmp = (uchar*)lp_base;</span><br><span class="line"><span class="keyword">int</span> width;</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">int</span> channel;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;width, tmp, <span class="keyword">sizeof</span>(width));</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;height, tmp, <span class="keyword">sizeof</span>(height));</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;channel, tmp, <span class="keyword">sizeof</span>(channel));</span><br><span class="line">tmp += <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">Mat img = Mat(height, width, CV_8UC3);</span><br><span class="line"><span class="built_in">memcpy</span>(img.data, tmp, height * width * channel);</span><br><span class="line"></span><br><span class="line">namedWindow(<span class="string">"test"</span>);</span><br><span class="line">imshow(<span class="string">"test"</span>, img);</span><br><span class="line">waitKey(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// close share memory file</span></span><br><span class="line">UnmapViewOfFile(lp_base);</span><br><span class="line">CloseHandle(shared_file_handler);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"open mapping file error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">readMemory();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># img_reader.py</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FILE_MAP_ALL_ACCESS = <span class="number">0xF001F</span></span><br><span class="line">szName = c_char_p(<span class="string">'Local\object_name_sean'</span>)</span><br><span class="line"></span><br><span class="line">hMapObject = windll.kernel32.OpenFileMappingA(FILE_MAP_ALL_ACCESS, <span class="keyword">False</span>, szName)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Error after OpenFileMappingA -&gt;"</span>, GetLastError()  <span class="comment"># If everything runs smoothly, GetLastError should return 0</span></span><br><span class="line"><span class="keyword">if</span> hMapObject == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Could not open file mapping object'</span></span><br><span class="line">    <span class="keyword">raise</span> windll.WindowsError()</span><br><span class="line"></span><br><span class="line">pBuf = windll.kernel32.MapViewOfFile(hMapObject, FILE_MAP_ALL_ACCESS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Error after MapViewOfFile -&gt;"</span>, GetLastError()  <span class="comment"># If everything runs smoothly, GetLastError should return 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pBuf == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Could not map view of file'</span></span><br><span class="line">    windll.kernel32.GetLastError()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    pBuf_int = cast(pBuf, POINTER(c_int))</span><br><span class="line">    width, height, channel = pBuf_int[:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    data_len = width * height * channel</span><br><span class="line">    pBuf_ubyte = cast(pBuf, POINTER(c_ubyte))</span><br><span class="line">    data_ubyte = pBuf_ubyte[: data_len]  <span class="comment"># The pointer is already incremented by 12 bytes, not sure why.</span></span><br><span class="line"></span><br><span class="line">    image = np.asarray(data_ubyte, dtype=np.uint8)</span><br><span class="line">    image = image.reshape((height, width, channel))</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'python image'</span>, image)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line"></span><br><span class="line">windll.kernel32.UnmapViewOfFile(pBuf)</span><br><span class="line">windll.kernel32.CloseHandle(hMapObject)</span><br></pre></td></tr></table></figure><p><a href="img_writer.cpp">img_writer in C++</a> <a href="img_reader.cpp">img_reader in C++</a> <a href="img_reader.py">img_reader in python</a></p><p><em><font color="orange">不知为什么，python 版的 reader 用脚本执行正常，但是用 pyinstaller 打包成 exe 后就无法获取共享内存的指针，<code>MapViewOfFile</code> 始终返回 0，正在解决这个问题。</font></em></p><p><em><font color="green">除此之外，发现 python 版中在执行完 <code>OpenFileMappingA</code> 和 <code>MapViewOfFile</code> 后，分别调用 <code>GetLastError</code> 都应该返回 0 (0 表示没有错误)。C++ 版本的 reader 就是如此。但是 <code>img_reader.py</code> 用脚本方式执行却都返回 2，按理说返回 2 了就表示有错，应该无法正确读取共享内存数据，但是用脚本方式执行却可以读取图像数据。这一点很奇怪。而将 <code>img_reader.py</code> 转换成 exe 后，在 <code>OpenFileMappingA</code> 后调用 <code>GetLastError</code> 返回 2，<code>MapViewOfFile</code> 后返回 6，也无法正确读取图像数据。</font></em></p><p>由于现有的方法无法在转成 exe 后成功运行，考虑使用新的方法来读取共享内存。这里使用了 <code>mmap</code> 库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shm = mmap.mmap(<span class="number">0</span>, <span class="number">720</span>*<span class="number">480</span>*<span class="number">3</span>+<span class="number">12</span>, <span class="string">"object_name_sean"</span>, mmap.ACCESS_READ)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> shm</span><br><span class="line"><span class="keyword">if</span> shm:</span><br><span class="line">    header = shm.read(<span class="number">12</span>)</span><br><span class="line">    width_str = header[:<span class="number">4</span>]</span><br><span class="line">    height_str = header[<span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line">    channel_str = header[<span class="number">8</span>:<span class="number">12</span>]</span><br><span class="line"></span><br><span class="line">    width = struct.unpack(<span class="string">'&lt;i'</span>, width_str)[<span class="number">0</span>]</span><br><span class="line">    height = struct.unpack(<span class="string">'&lt;i'</span>, height_str)[<span class="number">0</span>]</span><br><span class="line">    channel = struct.unpack(<span class="string">'&lt;i'</span>, channel_str)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> width, height, channel</span><br><span class="line"></span><br><span class="line">    data = shm.read(width * height * channel)</span><br><span class="line"></span><br><span class="line">    img_data = [ord(x) <span class="keyword">for</span> x <span class="keyword">in</span> data]</span><br><span class="line">    <span class="keyword">print</span> img_data[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">    image = np.asarray(img_data, dtype=np.uint8)</span><br><span class="line">    image = image.reshape((height, width, channel))</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'python image'</span>, image)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line"></span><br><span class="line">shm.close()</span><br></pre></td></tr></table></figure><p><a href="reader_mmap.py">img reader in python mmap</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Windows </tag>
            
            <tag> IPC </tag>
            
            <tag> Python </tag>
            
            <tag> WinAPI </tag>
            
            <tag> file mapping </tag>
            
            <tag> 进程通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio 环境变量配置</title>
      <link href="/2018/11/26/Visual-Studio-Configuration/"/>
      <url>/2018/11/26/Visual-Studio-Configuration/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了一些关于 Visual Studio 的环境变量的配置，本文使用的版本是 VS 2015.</p><a id="more"></a><h1 id="vs-的项目结构"><a class="markdownIt-Anchor" href="#vs-的项目结构"></a> VS 的项目结构</h1><p>  Visual Studio 主要由两层结构，最大的一层是 <code>解决方案 (Solution)</code>，一个 <code>解决方案</code> 可以包含多个 <code>项目 (Project)</code>。可以在一个已有的 <code>Solution</code> 里添加 <code>Project</code>.</p><br><h1 id="vs-平台选项"><a class="markdownIt-Anchor" href="#vs-平台选项"></a> VS 平台选项</h1><p>  VS 由 <code>Debug</code> 和 <code>Release</code> 两种模式，一般在开发阶段都使用 Debug，而在最后的发布阶段使用 Release。在目标平台选项主要有 <code>x64</code> 和 <code>x86</code> 两种。模式和平台相互组合就会产生 4 种方式。可根据需要进行环境变量的配置。</p><br><h1 id="项目属性配置"><a class="markdownIt-Anchor" href="#项目属性配置"></a> 项目属性配置</h1><p>  在某个项目上(是项目，非解决方案)<code>右键</code>，<code>属性</code>，选中左侧 <code>VC++目录</code>，右侧会出现一些路径的配置。主要有 <code>可执行文件目录</code>，<code>包含目录</code>，<code>引用目录</code>，<code>库目录</code>等等。在安装 VS 的时候，VS 已经将一些依赖的目录命名到一些宏了（就是类似于系统的环境变量之类的变量，与 C++ 的宏不一样），因此上面这些 <code>可执行文件目录</code> 等都包含了一些宏，作为默认的查找路径，如果自己的项目需要额外引入其他的依赖，则需要在对应的目录里添加自己的路径。比如，C++ 中调用 Python 的项目需要 <code>Python.h</code> 和 <code>python27.lib</code>，因此就将这两个文件所在的路径分别添加进 <code>包含目录</code> 和 <code>库目录</code>。上面的每一个目录都是和环境变量的某个变量对应的。比如，<code>包含目录</code> 与 环境变量 <code>INCLUDE</code> 对应，<code>库目录</code> 与 环境变量 <code>LIB</code> 对应。<br><strong>Note:</strong> 当选用 <code>Debug</code> 模式时，编译的时候会报找不到 <code>python27_d.lib</code> 的错，这是因为我们下载的 python 都是 Release 版本的。因此只有 <code>python27.lib</code> 没有 <code>python27_d.lib</code>。<a href="https://blog.csdn.net/Chris_zhangrx/article/details/78947526" target="_blank" rel="noopener">解决方法</a></p><br><h1 id="包含目录-附加包含目录以及库目录和附加库目录的区别"><a class="markdownIt-Anchor" href="#包含目录-附加包含目录以及库目录和附加库目录的区别"></a> 包含目录、附加包含目录以及库目录和附加库目录的区别</h1><p>在 VS 中，右键一个 Project，可以发现有两个地方设置 <code>Include</code> 的相关目录：</p><blockquote><p>VC++ Directories -&gt; Include Directories<br>C/C++ -&gt; General -&gt; Additional Include Directories</p></blockquote><p>同理，设置 Lib 也有两个地方</p><blockquote><p>VC++ Directories -&gt; LibraryDirectories<br>Linker -&gt; General -&gt; Additional Library Directories</p></blockquote><p>应该如何设置呢？<br>MSDN 对这两个条目的解释如下</p><blockquote><p>“VC++ Directories -&gt; Include Directories” : Directory settings displayed in the window are the directories that Visual Studio will search for include files referred to in your source code files. Corresponds to environment variable INCLUDE.<br>“C/C+±&gt; General -&gt; Additional Include Directories”: The directory to be added to the list of directories searched for include files.</p></blockquote><p>编译器在编译过程中查找包含目录（<strong>Include</strong> 文件）的顺序：</p><blockquote><p>The compiler searches for directories in the following order:<br>1. Directories containing the source file.<br>2. Directories specified with the <strong>/I</strong> option, in the order that CL encounters them.<br>3. Directories specified in the <strong>INCLUDE</strong> environment variable.</p></blockquote><p>其中 step2 中的 <code>/I</code> 是由 <code>C/C++ -&gt; General -&gt; Additional Include Directories</code> 设置的。<br>而 step3 中的 <code>INCLUDE</code> 是由 <code>VC++ Directories -&gt; Include Directories</code> 设置的。<br>所以从这里看出，不同的设置有不同的编译链接顺序。</p><p>因此，总结出两种设置方法：</p><blockquote><p>VC++ Directories -&gt; Include Directories 配合 VC++ Directories -&gt; LibraryDirectories<br>C/C++ -&gt; General -&gt; Additional Include Directories 配合 Linker -&gt; General -&gt; Additional Library Directories</p></blockquote><p>但是要注意，由于编译顺序，这种用法情况下需要确保在 <code>VC++ Directories -&gt; Include Directories</code> 中填入 <code>$(IncludePath)</code> (继承其他 Include 路径).</p><p>Lib 的设置与 Include 同理。</p><br><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://blog.csdn.net/u012234115/article/details/54233095" target="_blank" rel="noopener">visual studio配置中包含目录和附加包含目录的区别以及auto-linking</a><br><a href="https://blog.csdn.net/zcedar/article/details/51444343" target="_blank" rel="noopener">VS属性配置和auto-linking</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> visual studio </tag>
            
            <tag> 环境变量 </tag>
            
            <tag> Debug </tag>
            
            <tag> Release </tag>
            
            <tag> 调试 </tag>
            
            <tag> 发行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机成像原理和参数标定</title>
      <link href="/2018/11/15/camera-calibration/"/>
      <url>/2018/11/15/camera-calibration/</url>
      
        <content type="html"><![CDATA[<p>最近学习了相机的成像原理和参数标定，将参考文献记录如下。</p><a id="more"></a><h1 id="成像原理"><a class="markdownIt-Anchor" href="#成像原理"></a> 成像原理</h1><p>简化后的相机模型和针孔相机的成像原理很相似，因此我们把简化后的相机模型称为针孔相机模型。<br>具体内容参考<a href="https://zhuanlan.zhihu.com/p/30813733" target="_blank" rel="noopener">相机成像过程的简化与建模</a><br><br></p><h1 id="世界坐标到相机坐标变换"><a class="markdownIt-Anchor" href="#世界坐标到相机坐标变换"></a> 世界坐标到相机坐标变换</h1><p><a href="https://zhuanlan.zhihu.com/p/23090593" target="_blank" rel="noopener">刚体变换</a><br><a href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula" target="_blank" rel="noopener">罗德里格斯旋转公式</a><br><a href="https://www.matongxue.com/madocs/244.html" target="_blank" rel="noopener">仿射变换</a></p><h1 id="相机坐标到数字图像坐标畸变矫正"><a class="markdownIt-Anchor" href="#相机坐标到数字图像坐标畸变矫正"></a> 相机坐标到数字图像坐标，畸变矫正</h1><p><a href="https://zhuanlan.zhihu.com/p/30813733" target="_blank" rel="noopener">相机标定究竟在标定什么？</a></p><h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1><ol><li>由于针孔相机模型的特性（射线），CCD 上的某个点可能对应了一个射线上的所有点，因此无法只通过相机内参将像素坐标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 映射为相机坐标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>c</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>c</mi></msub><mo separator="true">,</mo><msub><mi>z</mi><mi>c</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_c, y_c, z_c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。因而无法计算出两个像素点之间的实际物理距离。（远处的大物体移动大距离和近处的小物体移动小距离可能成像结果完全一样）</li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> camera </tag>
            
            <tag> calibration </tag>
            
            <tag> imaging </tag>
            
            <tag> 相机 </tag>
            
            <tag> 成像原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow-1.x-cookbook 读书笔记</title>
      <link href="/2018/11/14/tensorflow-1-x-cookbook/"/>
      <url>/2018/11/14/tensorflow-1-x-cookbook/</url>
      
        <content type="html"><![CDATA[<p>本文是关于 《TensorFlow 1.x Deep Learning Cookbook》 的读书笔记。</p><a id="more"></a><br><h1 id="hello-world-in-tensorflow"><a class="markdownIt-Anchor" href="#hello-world-in-tensorflow"></a> Hello world in TensorFlow</h1><h2 id="1-设置-tensorflow-输出日志等级"><a class="markdownIt-Anchor" href="#1-设置-tensorflow-输出日志等级"></a> 1. 设置 tensorflow 输出日志等级</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>]=<span class="string">'2'</span></span><br></pre></td></tr></table></figure><h2 id="2-tensorflow-与设备"><a class="markdownIt-Anchor" href="#2-tensorflow-与设备"></a> 2. TensorFlow 与设备</h2><blockquote><p>TensorFlow allows you to use specific devices (CPU/GPU) with different objects of the computation graph using with <code>tf.device()</code>.</p></blockquote><br><h1 id="working-with-constants-variables-and-placeholders"><a class="markdownIt-Anchor" href="#working-with-constants-variables-and-placeholders"></a> Working with constants, variables, and placeholders</h1><h2 id="3-constants-和-variables-的存储方式"><a class="markdownIt-Anchor" href="#3-constants-和-variables-的存储方式"></a> 3. Constants 和 Variables 的存储方式</h2><blockquote><p>Constants are stored in the computation graph definition; they are loaded every time the graph is loaded. In other words, they are memory expensive. Variables, on the other hand, are stored separately; they can exist on the parameter server.</p></blockquote><h2 id="4-设置全局-seed"><a class="markdownIt-Anchor" href="#4-设置全局-seed"></a> 4. 设置全局 seed</h2><blockquote><p>When there are large numbers of random tensors in use, we can set the seed for all randomly generated tensors using tf.set_random_seed(); the following command sets the seed for random tensors for all sessions as 54: <code>tf.set_random_seed(54)</code></p></blockquote><h2 id="5-以某种分布初始化-variable"><a class="markdownIt-Anchor" href="#5-以某种分布初始化-variable"></a> 5. 以某种分布初始化 Variable</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rand_t = tf.random_uniform([<span class="number">50</span>,<span class="number">50</span>], <span class="number">0</span>, <span class="number">10</span>, seed=<span class="number">0</span>)</span><br><span class="line">t_a = tf.Variable(rand_t)</span><br><span class="line">t_b = tf.Variable(rand_t)</span><br></pre></td></tr></table></figure><h2 id="6-将-variable-作常量使用以优化内存-constant-存储在-graph-中variable-不是"><a class="markdownIt-Anchor" href="#6-将-variable-作常量使用以优化内存-constant-存储在-graph-中variable-不是"></a> 6. 将 Variable 作常量使用以优化内存 (Constant 存储在 graph 中，Variable 不是)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_large = tf.Variable(large_array, trainable = <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><br><h1 id="performing-matrix-manipulations-using-tensorflow"><a class="markdownIt-Anchor" href="#performing-matrix-manipulations-using-tensorflow"></a> Performing matrix manipulations using TensorFlow</h1><h2 id="7-elementwise-operations"><a class="markdownIt-Anchor" href="#7-elementwise-operations"></a> 7. elementwise operations</h2><blockquote><p>All arithmetic operations of matrices like add, sub, div, multiply (elementwise multiplication), mod, and cross require that the two tensor matrices should be of the same data type.<br><br></p></blockquote><h1 id="invoking-cpugpu-devices"><a class="markdownIt-Anchor" href="#invoking-cpugpu-devices"></a> Invoking CPU/GPU devices</h1><h2 id="8-tensorflow-naming-cpu-and-gpu-devices"><a class="markdownIt-Anchor" href="#8-tensorflow-naming-cpu-and-gpu-devices"></a> 8. TensorFlow naming CPU and GPU devices</h2><blockquote><p>TensorFlow names the supported devices as “<code>/device:CPU:0</code>” (or “<code>/cpu:0</code>”) for the CPU devices and “<code>/device:GPU:I</code>” (or “<code>/gpu:I</code>”) for the ith GPU device.</p></blockquote><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ORB 特征提取</title>
      <link href="/2018/11/13/ORB-Feature/"/>
      <url>/2018/11/13/ORB-Feature/</url>
      
        <content type="html"><![CDATA[<p>ORB 特征的提取过程</p><a id="more"></a><p>以下两篇博客讲解得不错，结合起来看更易理解。<br><a href="https://blog.csdn.net/zouzoupaopao229/article/details/52625678" target="_blank" rel="noopener">ORB特征提取详解</a><br><a href="https://blog.csdn.net/yang843061497/article/details/38553765" target="_blank" rel="noopener">见过的介绍ORB最清楚的博文</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 特征提取 </tag>
            
            <tag> 图像检索 </tag>
            
            <tag> 图像匹配 </tag>
            
            <tag> feature extraction </tag>
            
            <tag> ORB </tag>
            
            <tag> keypoint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Faster RCNN 中自定义 Python 层的作用理解</title>
      <link href="/2018/11/06/Faster-RCNN-Python-layer/"/>
      <url>/2018/11/06/Faster-RCNN-Python-layer/</url>
      
        <content type="html"><![CDATA[<p>本文主要分析了 Faster RCNN 中 <code>anchor_target_layer.py</code>, <code>proposal_target_layer.py</code> 和 <code>proposal_layer.py</code> 三个自定义 python 层的代码。</p><a id="more"></a><h1 id="训练阶段的主要网络结构"><a class="markdownIt-Anchor" href="#训练阶段的主要网络结构"></a> 训练阶段的主要网络结构</h1><p><img src="structure.PNG" alt="训练阶段的主要网络结构"></p><h1 id="测试阶段的主要网络结构"><a class="markdownIt-Anchor" href="#测试阶段的主要网络结构"></a> 测试阶段的主要网络结构</h1><p><img src="structure_test.PNG" alt="测试阶段的主要网络结构"></p><br><h1 id="proposal_layerpy-训练测试阶段都有"><a class="markdownIt-Anchor" href="#proposal_layerpy-训练测试阶段都有"></a> proposal_layer.py （训练，测试阶段都有）</h1><p><a href="https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/rpn/proposal_layer.py" target="_blank" rel="noopener">source</a><br>输入： score, bbox_deltas, im_info</p><ol><li>生成 anchors, 利用预测得到的 bbox_deltas 作为输入，对所有的 anchors 作回归，得到 proposals. (注意，这里生成 anchors 的方式与训练时 anchor_target_layer.py 里一致)</li><li>对超出原图的 proposals 进行 clip, 筛除尺寸过小的 proposals.</li><li>根据输入的 scores 进行排序，选取前 N 个保留。（eg. 6000）</li><li>对剩下的 proposals 进行 nms，筛除一部分 proposals.</li><li>再根据 scores 排序，选取前一部分 proposals. (eg. 300)</li><li>输出 proposals</li></ol><br><h1 id="anchor_target_layerpy-仅在训练阶段"><a class="markdownIt-Anchor" href="#anchor_target_layerpy-仅在训练阶段"></a> anchor_target_layer.py (仅在训练阶段)</h1><p><a href="https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/rpn/anchor_target_layer.py" target="_blank" rel="noopener">source</a><br>输入: ‘rpn_cls_score’,‘gt_boxes’,‘im_info’, ‘data’<br>(1) 生成 所有的 anchors，记为 <code>all_anchors</code>，选出在图像内部的 anchor，记为 <code>anchors</code>.<br>(2) 生成与 1 步中 <code>anchors</code> 同尺寸的 <code>labels</code>，初始化为 <code>-1</code>.<br>(3) 计算 <code>anchors</code> 与 <code>gt_boxes</code> 的 IoU，得到 <code>overlaps</code>，得到每个 anchor 对应的 gt_box (IoU 最大).<br>(4) 根据 RPN 正负样本选取规则 1，将每个 gt_box 的 IoU 最大 anchor 的 label 置为 <code>1</code>.<br>(5) 根据 RPN 正负样本选取规则 2，将与任意 gt_box 的 IoU 大于某阈值的 anchor 的 label 置为 <code>1</code>. 将与所有 gt_box 的 IoU 小于某阈值的 achor 的 label 置为 <code>0</code>. 剩下的保留为 <code>-1</code>. 这样，就为每个 anchor 分配了标签。<br>(6) 根据正负样本的数量限制，将一部分正样本（label 为 1）置为 <code>-1</code>. 负样本同样。<br>(7) 计算 <code>anchors</code> 中每个 anchor 和 其对应的 gt_box 之间的 delta 作为 <code>bbox_targets</code>.<br>这样，上面计算得到的 <code>labels</code> 和 <code>bbox_targets</code> 其实就是 RPN 网络的 loss 的真值。<br>(8) 将得到的 <code>anchors</code> 和 <code>bbox_targets</code> unmap 回原来的 <code>all_anchors</code> 中。这样，所有生成的 anchors 都有一个类别标记（-1，0，1）和 bbox_targets. (在 <code>all_anchors</code> 不在 <code>anchors</code> 中的 anchor 的 bbox_target 用 0 填充。label 用 -1 填充。这样在计算 RPN loss 时不会计算此 anchor 的 loss.(-1 被忽略))。<br>(9) 将 <code>all_anchors</code> 的 <code>labels</code> 和 <code>bbox_targets</code> 输出，与预测的结果计算 rpn_loss.</p><br><h1 id="proposal_target_layerpy-仅在训练阶段"><a class="markdownIt-Anchor" href="#proposal_target_layerpy-仅在训练阶段"></a> proposal_target_layer.py (仅在训练阶段)</h1><p><a href="https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/rpn/proposal_target_layer.py" target="_blank" rel="noopener">source</a><br>接受 proposal_layer.py 的输出(0, x1, y1, x2, y2) 和 gt_boxes (每个 GT box 的坐标和类别) (x1, y1, x2, y2, label)作为输入。</p><ol><li>将输入的 rois 和 gt_boxes 合并 (vstack)，形成总的 rois，记为 <code>all_rois</code>, 格式为(0, x1, y1, x2, y2), 共 M 个。</li><li>计算每个 roi 和每个 gt_box 的 IoU，形成一个 matrix，设 gt_boxes 共有 N 个，则尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M\times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>.</li><li>找到每个 roi 对应的 IoU 最大的 gt_box 的索引，并将此 gt_box 的类别赋给此 roi. 这样每个 roi 都有一个物体类别。</li><li>选择一些最大 IoU (最大 IoU 指 roi 与所有 gt_box 的 IoU 的最大值) 大于某阈值的 roi 作为 foreground，选择一些最大 IoU 在某区间内的 roi 作为 background。将作为 background 的 roi 的类别改为 0，用作最后 loss_cls 的计算。将 fg rois 和 bg rois 合并(vstack)，作为一个输出。记为 rois，用作 ROI Pooling.</li><li>计算这些 rois (第4步获得)与其对应的 gt_boxes 之间的 delta 作为位置预测的目标，用来计算 loss_bbox. <a href="https://github.com/rbgirshick/py-faster-rcnn/blob/781a917b378dbfdedb45b6a56189a31982da1b43/lib/fast_rcnn/bbox_transform.py#L10" target="_blank" rel="noopener">delta计算方法</a></li></ol><p><strong>2021/03/16:</strong></p><ol><li>这里，第一步将 gt_boxes 与 proposal_layer.py 输入的 rois 合并(vstack)是为了将 gt_boxes 作为 fg rois 参与后面的 loss 计算，因为每一个 gt_box 肯定会和自己本身的 IoU 为1，这样，就会被选作 fg roi, 进行后面的 loss 计算。</li><li>感觉这一步生成的 rois 作用类似于 RPN 中的 anchor。都要计算与其对应的 gt_box 之间的 delta 作为回归的真值。其类别也是由其对应的 gt_box 赋予的。</li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> Faster R-CNN </tag>
            
            <tag> RPN </tag>
            
            <tag> anchor </tag>
            
            <tag> Python layer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 中关于字符的编码方式</title>
      <link href="/2018/07/24/encoding-problem/"/>
      <url>/2018/07/24/encoding-problem/</url>
      
        <content type="html"><![CDATA[<p>在工作中遇到了有关字符编码的一个问题，在解决之后记录一下。</p><a id="more"></a><p>在一个深度学习的目标检测任务中，需要将检测出的结果输出到一个 xml 文件中，或者以 xml 的形式打印到控制台上。当向 xml 文件中传递的字符都是英文和数字时，不会有问题。但是当 xml 文件中出现中文或日文字符时，会出现一系列的编码问题。</p><h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><p>  当设置 xml 某个元素的值时，若传递进去的为中文或日文，就会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: All strings must be XML compatible: Unicode <span class="keyword">or</span> ASCII, no NULL bytes <span class="keyword">or</span> control characters [<span class="number">8444</span>] Failed to execute script runcaffe_fpn</span><br></pre></td></tr></table></figure><p>这个错是由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resource.text = image_name</span><br></pre></td></tr></table></figure><p>这句话引发的，其中 image_name 是用 glob 函数从 Windows 系统中的某个路径下读进来的文件名。</p><br><h1 id="分析和解决"><a class="markdownIt-Anchor" href="#分析和解决"></a> 分析和解决</h1><p>经过搜索发现，lxml 模块中，当对一个树的某个节点进行赋值时，其传入值必须是 Unicode 或 ASCII 码，而使用 glob 函数读进来的文件名并不是，因而造成了错误。</p><p>经过研究发现，简体中文版的 Windows 系统使用 GBK 字符集，而不是 Unicode 字符集，因而传入的文件名不能直接赋值给 lxml 的节点对象。因此，需要对其进行转换，转换成 Unicode 码，再赋值给节点对象，也就是 <code>name = image_name.decode('gbk')</code> 或 <code>name = image_name.decode('Shift-JIS')</code>。</p><p>这样之后不会报错了，但是在生成的 xml 文件中，中日字符都是以 unicode 码显示的，此时，只要将 <code>etree.tostring()</code> 函数的 <code>encoding=</code> 参数设置为 utf-8 即可。</p><p>传入的文件名除了不能直接赋给 lmxl 的节点对象，直接进行 print 也是会乱码的（当 cmd 的 code page 与此字符串编码不一致时）。这是因为，传入的文件名的编码方式是由其代表文件所在的系统决定的，简体中文版 Windows 是 GBK，日文版是 Shift-JIS。当传入的字符串为 Shift-JIS 编码，但是尝试在 GBK 的 cmd 上打印出来时，就会报错。如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\sean\Pictures\01.嶥杫巗彫栰杫.png</span><br><span class="line">C:\Users\sean\Pictures\fc_barcelona___wallpaper_by_ccrt.png</span><br><span class="line">C:\Users\sean\Pictures\vs添加lib文件.PNG</span><br><span class="line">C:\Users\sean\Pictures\户口簿首页.png</span><br><span class="line">C:\Users\sean\Pictures\捕获.PNG</span><br></pre></td></tr></table></figure><p>可以看出，第一个文件的文件名是乱码，这是因为它是 Shift-JIS 编码的，但是却尝试在 GBK 的 cmd 上打印出来，因此会报错。</p><p>总结: python2 中，如果在文件开头声明了某种文件编码格式，那么此文件中<font color="orange"><strong>定义</strong></font>的字符串就是跟文件同样的编码格式。如果想要将此字符串打印到控制台上，则其编码必须跟控制台的编码一致。否则就需要手动进行 decode 成 unicode 进行打印。对于从系统中读进来的文件名，其编码格式是根据所在系统的编码格式决定的，与源码文件头部声明的编码格式无关。例如，以下代码中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"></span><br><span class="line">names = glob.glob(osp.join(<span class="string">'C:\Users\sean\Pictures'</span>, <span class="string">'*.png'</span>))</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    <span class="keyword">print</span> name</span><br><span class="line"></span><br><span class="line">s = <span class="string">'路飞学院'</span></span><br><span class="line"><span class="keyword">print</span> s</span><br></pre></td></tr></table></figure><p><code>s</code> 变量的编码就是头部声明的 utf-8，而 <code>names</code> 中每个元素的编码则是根据路径下每个文件的编码格式而异的。</p><p>值得注意的时，在 python2 中，字符串一共有两种类型，str 或 unicode。</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">s = <span class="string">'中文'</span>  <span class="comment"># 注意这里的 str 是 str 类型的，而不是 unicode</span></span><br><span class="line">s.encode(<span class="string">'gb18030'</span>)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这句代码将 s 重新编码为 gb18030 的格式，即进行 unicode -&gt; str 的转换。因为 s 本身就是 str 类型的，因此 Python 会自动的先将 s 解码为 unicode ，然后再编码成 gb18030。因为解码是 python 自动进行的，我们没有指明解码方式，python 就会使用 sys.defaultencoding 指明的方式来解码。很多情况下 sys.defaultencoding 是 ASCII，如果 s 不是这个类型就会出错。拿上面的情况来说，我的 sys.defaultencoding 是 ASCII，而 s 的编码方式和文件的编码方式一致，是 utf8 的，所以出错了:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe4 in position</span><br><span class="line">0: ordinal not in range(128)</span><br></pre></td></tr></table></figure><blockquote><p>此问题的解决方案有以下两种:<br>一是明确的指示出 s 的解码方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; # -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">s = &apos;中文&apos;</span><br><span class="line">s.decode(&apos;utf-8&apos;).encode(&apos;gb18030&apos;)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>二是更改 <code>sys.defaultencoding</code> 为文件的编码方式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">reload(sys) # Python2.5 初始化后会删除 sys.setdefaultencoding 这个方法，我们需要重新载入</span><br><span class="line">sys.setdefaultencoding(&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">str = &apos;中文&apos;</span><br><span class="line">str.encode(&apos;gb18030&apos;)</span><br></pre></td></tr></table></figure><p>注意: 在 pycharm 等 IDE 中，一般新建一个文件都是默认的 UTF-8 编码，而在文件中显式地声明一个字符串时(前面没加 u)，此字符串采用的就是与文件同样的编码方式，即 UTF-8. 也就是说，当你在一个 python 脚本里直接定义一个字符串常量的时候，此字符串的编码方式和环境编码方式相同。注意，如果一个 str 变量是从外部传过来的，如 glob 函数返回的，则此变量的编码方式可能会和源文件编码方式不一样。</p><br><h1 id="python-中的-str-和-unicode"><a class="markdownIt-Anchor" href="#python-中的-str-和-unicode"></a> python 中的 str 和 unicode</h1><p>简体中文版 Windows 系统，编码方式为 GBK</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="string">'你好'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'\xc4\xe3\xba\xc3'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="string">u'你好'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">u'\u4f60\u597d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> a</span><br><span class="line">你好</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> b</span><br><span class="line">你好</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__class__</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(a)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(b)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>由以上代码段可以看出，直接定义一个字符串常量的时候，即 str 的时候，其编码方式为 GBK，是环境的编码方式，</p><p>在一个系统编码为UTF-8的Linux环境下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'你好'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'/xe4/xbd/xa0/xe5/xa5/xbd'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">u'你好'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">u'/u4f60/u597d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> a</span><br><span class="line">你好</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> b</span><br><span class="line">你好</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__class__</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(a)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(b)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以看出，在此 Linux 中，str 的编码方式为 utf-8，也是环境的编码方式。</p><p>len(string)返回string的字节数，len(unicode)返回的是字符数</p><blockquote><p>print(string) 的时候，如果 string 是按当前环境编码方式编码的，可以正常输出，不会乱码；如果 string 不是当前环境编码的，就会乱码。而 print(unicode) 是不会乱码的。why？因为 print(unicode) 的时候，会把 unicode 先转成当前编码，然后再输出。我没看过 print 的源码，不过估计是这样的。</p></blockquote><p>关于 <code>如果 string 不是当前环境编码的，就会乱码。</code> 这句，可由一下代码证实:<br><a href="http://coding.py" target="_blank" rel="noopener">coding.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">s = <span class="string">'路飞学院'</span></span><br><span class="line"><span class="keyword">print</span> s</span><br></pre></td></tr></table></figure><p>在使用 GBK 的 terminal 中，输出为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\sean\PycharmProjects\working&gt;python coding.py</span><br><span class="line">璺瀛﹂櫌</span><br></pre></td></tr></table></figure><p>这是因为，s 使用文件编码方式 utf-8 进行编码，而 terminal 是 gbk 编码的，因此会出现乱码。若在声明中使用 gbk，则不会出现乱码(已亲测)。</p><br><h2 id="python2-还是-python3"><a class="markdownIt-Anchor" href="#python2-还是-python3"></a> python2 还是 python3</h2><p>以上所说的都是针对 python2，python3 针对编码部分进行了改进。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">s = <span class="string">'路飞学院'</span></span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>以上这段代码，在 python2 中执行结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\sean\PycharmProjects\working&gt;python coding.py</span><br><span class="line">璺瀛﹂櫌</span><br></pre></td></tr></table></figure><p>在 python3 中为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\sean\PycharmProjects\working&gt;D:\Develop\Anaconda2\setup\envs\tensorflow\python coding.py</span><br><span class="line">路飞学院</span><br></pre></td></tr></table></figure><p>原因如下：</p><blockquote><p>  utf-8 编码之所以能在 windows gbk 的终端下显示正常，是因为到了内存里 python 解释器把 utf-8 转成了 unicode, 但是这只是 python3, 并不是所有的编程语言在内存里默认编码都是 unicode。比如，万恶的 python2 就不是，它的默认编码是 ASCII，想写中文，就必须声明文件头的 coding 为 gbk 或 utf-8, 声明之后，python2 解释器仅以文件头声明的编码去解释你的代码，加载到内存后，并不会主动帮你转为 unicode，也就是说，你的文件编码是 utf-8，加载到内存里，你的变量字符串就也是 utf-8 编码的。如果需要显示在 gbk 的终端下，就只能使用 decode 或 encode 函数转换成 unicode 或者再使用 gbk 进行编码。</p></blockquote><hr><blockquote><p>PY3 除了把字符串的编码改成了 unicode, 还把str 和 bytes 做了明确区分， str 就是 unicode 格式的字符， bytes 就是单纯二进制</p></blockquote><hr><blockquote><p>python2 的字符串其实更应该称为字节串。通过存储方式就能看出来，但 python2 里还有一个类型是 bytes ，难道又叫 bytes 又叫字符串？是的，在 python2 里，bytes == str ， 其实就是一回事。除此之外，python2 里还有个单独的类型 unicode , 把字符串解码后，就会变成 unicode。</p></blockquote><hr><blockquote><p>总之，Python只要出现各种编码问题，无非是哪里的编码设置出错了<br>常见编码错误的原因有：</p></blockquote><ul><li>Python解释器的默认编码</li><li>Python源文件文件编码</li><li>Terminal使用的编码</li><li>操作系统的语言设置</li></ul><blockquote><p>掌握了编码之前的关系后，挨个排错就好了。</p></blockquote><p><a href="http://www.cnblogs.com/huxi/archive/2010/12/05/1897271.html" target="_blank" rel="noopener">这篇文章非常不错</a>，可以参考了解。<br><br></p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://blog.csdn.net/ktb2007/article/details/3876436" target="_blank" rel="noopener">https://blog.csdn.net/ktb2007/article/details/3876436</a><br><a href="https://blog.csdn.net/ktb2007/article/details/3876429" target="_blank" rel="noopener">https://blog.csdn.net/ktb2007/article/details/3876429</a><br><a href="https://www.zhihu.com/question/31833164/answer/381137073" target="_blank" rel="noopener">https://www.zhihu.com/question/31833164/answer/381137073</a><br><a href="https://blog.csdn.net/abyjun/article/details/50190243" target="_blank" rel="noopener">https://blog.csdn.net/abyjun/article/details/50190243</a><br><a href="https://medium.com/@jackyu/windows-cmd-ae8d4f84f8bf" target="_blank" rel="noopener">永久修改 cmd 代码页方法</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编码 </tag>
            
            <tag> unicode </tag>
            
            <tag> utf-8 </tag>
            
            <tag> 中文 </tag>
            
            <tag> 日文 </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将包含 caffe 的 python 工程打包成一个 exe 文件</title>
      <link href="/2018/07/09/Convert-python-project-to-exe/"/>
      <url>/2018/07/09/Convert-python-project-to-exe/</url>
      
        <content type="html"><![CDATA[<p>由于工作原因，需要将一个基于 caffe 的深度学习检测工程转换成 exe 文件，在此过程中遇到了许多问题，现将其记录下来，以供参考。</p><a id="more"></a><h1 id="fpn_ported-改动"><a class="markdownIt-Anchor" href="#fpn_ported-改动"></a> fpn_ported 改动</h1><h2 id="caffe-related"><a class="markdownIt-Anchor" href="#caffe-related"></a> Caffe related</h2><p>1 caffe/pycaffe.py L13 <code>from ._caffe</code> 改成了 <code>from caffe._caffe</code>。因为最后 <code>dist\runcaffe_fpn\</code> 里有一个  <code>caffe._caffe.pyd</code> 文件，因此需要 import 此文件。（个人解释见下文）<br>2 caffe/_<em>init_</em>.py L2 <code>from._caffe</code> 改成了 <code>from caffe._caffe</code><br>caffe/_<em>init_</em>.py L3 <code>from._caffe</code> 改成了 <code>from caffe._caffe</code><br>3 caffe 中关于图像读入的部分都是用的 skimage 进行实现，但是似乎 pyinstaller 对 skimage 的支持并不好，因此需要对 caffe 中的相关部分用 cv2 进行替代。</p><blockquote><p>My Python project includes A Caffe module which run a simple image classification process. One basic function is Caffe calling <a href="http://skimage.io" target="_blank" rel="noopener">skimage.io</a> to load image:<br><a href="https://github.com/BVLC/caffe/blob/master/python/caffe/io.py" target="_blank" rel="noopener">https://github.com/BVLC/caffe/blob/master/python/caffe/io.py</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_image</span><span class="params">(filename, color=True)</span>:</span></span><br><span class="line">    img = skimage.img_as_float(skimage.io.imread(filename, as_grey=<span class="keyword">not</span> color)).astype(np.float32)</span><br><span class="line">    <span class="keyword">if</span> img.ndim == <span class="number">2</span>:</span><br><span class="line">        img = img[:, :, np.newaxis]</span><br><span class="line">        <span class="keyword">if</span> color:</span><br><span class="line">            img = np.tile(img, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">elif</span> img.shape[<span class="number">2</span>] == <span class="number">4</span>:</span><br><span class="line">        img = img[:, :, :<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure><blockquote><p>I wonder if PyInstaller currently has a good support for Python package skimage. But from what I know by now, it doesn’t.</p></blockquote><blockquote><p>Run from Python source code files, it works fine. But when I packed all things into one single binary file, it can not load image at all. And after debugging and googleing for a long time – I always thought maybe I did something wrong – I get rid of this. PyInstaller hates skimage! So at last I use cv2 instead. And it works smoothly.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv2_load_image</span><span class="params">(filename, color=True)</span>:</span></span><br><span class="line">    img = cv2.imread(filename).astype(np.float32) / <span class="number">255</span></span><br><span class="line">    <span class="keyword">if</span> img.ndim == <span class="number">3</span>:</span><br><span class="line">        img[:,:,:] = img[:,:,<span class="number">2</span>::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> img.ndim == <span class="number">2</span>:</span><br><span class="line">        img = img[:, :, np.newaxis]</span><br><span class="line">        <span class="keyword">if</span> color:</span><br><span class="line">            img = np.tile(img, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">elif</span> img.shape[<span class="number">2</span>] == <span class="number">4</span>:</span><br><span class="line">        img = img[:, :, :<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure><blockquote><p>For all above details, please do check out PyInstaller Documentation: <a href="https://media.readthedocs.org/pdf/pyinstaller/latest/pyinstaller.pdf" target="_blank" rel="noopener">https://media.readthedocs.org/pdf/pyinstaller/latest/pyinstaller.pdf</a></p></blockquote><p>具体参考<a href="https://handong1587.github.io/programming_study/2016/12/24/pyinstaller-and-others.html#continue-tackling-weird-stuffs" target="_blank" rel="noopener">这篇文章</a></p><br><h2 id="numpy-related"><a class="markdownIt-Anchor" href="#numpy-related"></a> Numpy related</h2><p>1 numpy.core._<em>init_</em>.py 中 <code>from .info import __doc__</code> 改成 <code>from numpy.core.info import __doc__</code><br>2 <code>from . import multiarray</code> 改成 <code>from numpy.core import multiarray</code><br>3 将 numpy.core._<em>init_</em>.py 中其他的代表当前目录的 <code>.</code> 都替换成 <code>numpy.core</code><br>4 将 <a href="http://numpy.fft.fftpack.py" target="_blank" rel="noopener">numpy.fft.fftpack.py</a> 中的 <code>from . fft import fftpack_lite as fftpack</code> 改成 <code>from numpy.fft import fftpack_lite as fftpack</code><br>5.将 numpy.random._<em>init_</em>.py 中的 <code>from .mtrand import *</code> 改成 <code>from numpy.random.mtrand import *</code><br><strong>个人观点：</strong> 似乎无需像第3步一样将所有的 . 都改成绝对路径，貌似只有使用 <code>.</code> 导入 pyd 文件的导入语句会报找不到的错误。因此只需将导入 pyd 文件的语句更改即可。</p><br><h2 id="os-ospath-related"><a class="markdownIt-Anchor" href="#os-ospath-related"></a> os, os.path related</h2><h3 id="problem"><a class="markdownIt-Anchor" href="#problem"></a> Problem</h3><p>  打包后运行时，在最外层的 runcaffe_fpn.py 中 import os 可以成功，但是在  <code>models/rpn/proposal_layer.py</code> 和 <code>lib/config.py</code> 中 <code>import os</code> 就会报错 <code>no module named path</code>。</p><br><h3 id="analysis"><a class="markdownIt-Anchor" href="#analysis"></a> Analysis</h3><p>  由于 os 和 os.path 的特殊性，即 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 中根据平台不同，import 不同的文件作为 path 模块，例如，在 Windows 中，使用 <code>import ntpath as path</code> 并将其命名为 os.path 模块。此外，<a href="http://os.py" target="_blank" rel="noopener">os.py</a> 和 <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 文件存在相互 import 的情况，不知为什么，工程中一些文件中，如 <a href="http://config.py" target="_blank" rel="noopener">config.py</a> 中，import os 语句会报错 no module namded path。</p><br><h3 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h3><p>  <s>由于 <a href="http://config.py" target="_blank" rel="noopener">config.py</a> 等文件中调用了 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 中的 makedirs 等函数以及 <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 中的一些函数。因此，尝试将 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 与 <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 文件解耦（其实是无法解耦的，因为 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 需要导入 <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 中的属性并供其函数使用），因此将 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 中 <code>import ntpath as path</code>  句注释，将 <code>sys.modules['os.path'] = path</code> 和 <code>from os.path import (curdir, pardir, sep, pathsep, defpath, extsep, altsep, devnull)</code> 注释掉，换成 <code>from _ntpath import (curdir, pardir, sep, pathsep, defpath, extsep, altsep, devnull)</code> （<code>from _ntpath</code> 是因为如果直接使用 <code>from ntpath</code> 的话，它会自动调用 anaconda 下的 <code>ntpath.py</code> 文件，会导致前面的错误，因此，将 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 和 <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 文件拷贝至一个包下，并都在前面加上下划线进行重命名）。实际操作中，我是创建了一个名为 os_modified 的包，并将重命名后的 _os.py 和 _ntpath.py 文件放进去作为模块。在工程文件中调用 os 和 os.path 的地方，将 <code>import os</code> 和 <code>import os.path as osp</code> 改成 <code>import modified_os._os as os</code> 和 <code>import modified_os._ntpath as osp</code>。工程文件中导入的其他一些包，如 genericpath，也会 import os，我也将这些文件拷贝进 modified_os 中重命名， 如 _genericpath，并将其中的 import os 改成 import _os as os。在工程文件中有 <code>import genericpath</code> 的地方改成 <code>import modified_path._genericpath as genericpath</code>。其他有类似情况的也按此方法处理。总之，os_modified 模块下，都是在工程文件中使用到，且其有 <code>import os</code> 或 <code>import os.path</code> 的，我将所有这些文件集中到一个名为 modified_os 的模块下，当工程文件中调用到这些时，就调用此模块下的版本，而不是 anaconda 的原始版本。这样就解决了 <code>no module named path</code> 的错误。</s></p><br><h3 id="comment"><a class="markdownIt-Anchor" href="#comment"></a> Comment</h3><p>  上面所述的关于 os, os.path 的部分全部不需要，只需要将 <a href="http://os.py" target="_blank" rel="noopener">os.py</a>, <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 两个文件通过 <code>--add-binary=&quot;/path/to/os.py;.&quot; --add-binary=&quot;/path/to/ntpath.py;.&quot;</code> 添加进去即可。这样，在 <code>dist/runcaffe_fpn/</code> 下就会有 <code>os.py</code> 和 <code>ntpath.py</code> 两个文件。当一个 <code>.py</code> 文件是从 exe 文件中开始执行，即是 boundled 的时候，pyinstaller 的 bootloader 将 <code>frozen</code> 属性添加进 sys 模块中。因此，可以通过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> getattr(sys, <span class="string">'frozen'</span>, <span class="keyword">False</span>):</span><br><span class="line">    <span class="comment"># running in a bundle</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># running live</span></span><br></pre></td></tr></table></figure><p>来在工程文件中进行判断此工程文件是用 python 脚本调用执行的还是用 exe 文件调用执行的。如果是用 python 脚本调用，则根据其导入模块的结构进行 import。比如 <code>fast_rcnn/nms_wrapper.py</code> 需要导入 <code>nms/gpu_nms.pyd</code> 和 <code>fast_rcnn/config.py</code>。在脚本模式下，需使用 <code>from nms.gpu_nms import gpu_nms</code> 和 <code>from fast_rcnn.config import cfg</code> 进行调用。而在 boundle 模式下，使用 <code>from gpu_nms import gpu_nms</code> 和 <code>from config import cfg</code> 进行调用即可。需要注意的是，在 boundle 模式下，还需使用 <code>--add-binary</code> 选项将 <code>gpu_nms.pyd</code> 和 <code>config.py</code> 两个文件添加进去，这样它的 import 语句才会生效。</p><p>上述做法有效的<font color="orange"><strong>原因</strong></font>是：pyinstaller 似乎将工程中不同层次的脚本（即存在调用关系）所需的依赖都展开放在最后打包的依赖项所在的文件夹下，即 <code>sys._MEIPASS</code> 所指向路径下，是没有目录层次的。因此，当处于 boundle 模式下时，<code>from gpu_nms import gpu_nms</code> 语句会直接对 <code>sys.__MEIPASS</code> 目录下的 <code>gpu_nms.pyd</code> 文件进行 import。在解决 os, os.path 问题时，将 <a href="http://os.py" target="_blank" rel="noopener">os.py</a> 和 <a href="http://ntpath.py" target="_blank" rel="noopener">ntpath.py</a> 文件都添加进去，就不会有找不到的问题。并且按照理论，import os 所导入的文件应该是 <code>sys._MEIPASS</code> 路径下的 <a href="http://os.py" target="_blank" rel="noopener">os.py</a>。（已验证）</p><p>工程文件中的示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> getattr(sys, <span class="string">'frozen'</span>, <span class="keyword">False</span>): <span class="comment"># boundle 模式</span></span><br><span class="line">    <span class="keyword">from</span> gpu_nms <span class="keyword">import</span> gpu_nms</span><br><span class="line">    <span class="keyword">from</span> config <span class="keyword">import</span> cfg</span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 脚本模式</span></span><br><span class="line">    <span class="keyword">from</span> nms.gpu_nms <span class="keyword">import</span> gpu_nms</span><br><span class="line">    <span class="keyword">from</span> fast_rcnn.config <span class="keyword">import</span> cfg</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;解决了 os 和 pyd 文件导入的问题后，exe 可以成功运行了。但是美中不足的是，运行 exe 除了需要作为参数的那些文件外，还一直需要 `proposal_layer.py` 文件，这是不好的，因为不能向客户透露源码。因此，尝试将 `proposal_layer.py` 文件也用 `--add-binary` 选项添加进去。但是这样并没有用。究其原因是，`proposal_layer.py` 是在 `.prototxt` 文件中指定的（即 python 层中的 module 参数），原来为 `module: rpn.proposal_layer`。这是因为 prototxt 文件同级目录下有一个 rpn 文件夹，其下有一个 `proposal_layer.py` 文件。由于将 `proposal_layer.py` 文件添加进 `sys._MEIPASS` 后其名称仍为 `proposal_layer.py`，而 prototxt 中指定为 `rpn.proposal_layer`，不统一。因此，将 rpn 文件夹下的两个文件，`proposal_layer.py` 和 `generate_anchors.py`，放置到与 prototxt 文件同级目录下，并将 prototxt 中的 `rpn.proposal_layer` 改成 `proposal_layer`. 再将 `proposal_layer.py` 用 `--add-binary` 添加进去，就可以在 `sys._MEIPASS` 中调用 `proposal_layer.py` 了，这样再运行单个的 exe 文件时就不需带着 `proposal_layer.py` 文件了，因为它会调用 `sys._MEIPASS` 下的 `proposal_layer.py`。<p>Pyinstaller 打包命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F --add-binary=&quot;models/nms/gpu_nms.pyd;.&quot; ^</span><br><span class="line">               --add-binary=&quot;models/fast_rcnn/bbox_transform.py;.&quot; ^</span><br><span class="line">               --add-binary=&quot;models/fast_rcnn/config.py;.&quot; ^</span><br><span class="line">               --add-binary=&quot;models/fast_rcnn/nms_wrapper.py;.&quot; ^</span><br><span class="line">               --add-binary=&quot;models/proposal_layer.py;.&quot; ^</span><br><span class="line">               --add-binary=&quot;models/generate_anchors.py;.&quot; ^</span><br><span class="line">               --add-binary=&quot;H:/Develop/Anaconda2/setup/Lib/os.py;.&quot; ^</span><br><span class="line">               --add-binary=&quot;H:/Develop/Anaconda2/setup/Lib/ntpath.py;.&quot; ^</span><br><span class="line">               runcaffe_fpn.py</span><br></pre></td></tr></table></figure><p>最后，如上面的代码所示，我是将所有的除 caffe 模块外的额外 python 脚本都添加进了 <code>sys._MEIPASS</code> 中，保证可以有效调用。</p><h1 id="pyinstaller-使用方法记录"><a class="markdownIt-Anchor" href="#pyinstaller-使用方法记录"></a> Pyinstaller 使用方法记录</h1><h2 id="pyinstaller-运行时路径问题"><a class="markdownIt-Anchor" href="#pyinstaller-运行时路径问题"></a> Pyinstaller 运行时路径问题</h2><p>  pyinstaller 在打包后，会将 <code>frozen</code> 属性添加进 sys 变量。因此，可以使用 <code>getattr(sys, 'frozen', False)</code> 来判断当前执行的脚本是否是用 python 脚本执行的还是 exe 文件执行的。</p><p>  pyinstaller 有两种打包模式，一种是 onefile 模式，即将所有的依赖文件都打包成一个单独的 exe 文件，在运行此 exe 文件时，将其所包含的依赖文件临时解压到某个目录下，并在此目录下进行执行。另一种是 one-folder 模式，将生成的 exe 文件和依赖文件都放在 dist 文件夹下与被打包的 script 同名的文件夹中。在运行 exe 文件时，不需要将依赖文件解压，因此速度更快一些。很显然，one-file 模式的 exe 文件会比较大。当运行 exe 文件时，pyinstaller 的 bootloader 将 bundle folder 的绝对路径添加进 sys._MEIPASS 中。其实，这就是 exe 文件执行时，依赖文件所在的位置。需要注意的是，one-folder 模式下的 exe 文件必须和依赖文件在同一路径下，否则会找不到依赖。</p><br><h2 id="hidden-import"><a class="markdownIt-Anchor" href="#hidden-import"></a> hidden-import</h2><p>在一次测试中，我用 <code>R.py</code> 导入了 <code>libs/rpn/proposal_layer.py</code>，在<code>proposal_layer.py</code> 中 <code>from ..fast_rcnn.nms_wrapper import nms</code>，在 <code>libs/fast_rcnn.nms_wrapper.py</code> 中 <code>from ..nms.gpu_nms import gpu_nms</code>，在 <code>libs/nms/</code> 下有一个 <code>gpu_nms.pyd</code> 文件。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pyinstaller </tag>
            
            <tag> 打包 </tag>
            
            <tag> caffe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下 Caffe 的路径设置问题</title>
      <link href="/2018/07/04/Linux-caffe-path-setting/"/>
      <url>/2018/07/04/Linux-caffe-path-setting/</url>
      
        <content type="html"><![CDATA[<p>在 FRDC 的 8 GPU 服务器上，在 <code>import caffe</code> 后，在 ipython 中一直无法补全 caffe 的函数。研究了一下，终于解决了这个问题。</p><a id="more"></a><h1 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h1><ul><li>Centos 7</li><li>Caffe</li></ul><h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><ol><li>个人用户目录下有一 caffe 库，将其添加进 <code>PYTHONPATH</code> 后，无法有效调用。</li><li>尝试将其他用户下的 caffe 路径添加进 <code>PYTHONPATH</code>，依然无法有效调用。</li><li>在 <code>PYTHONPATH</code> 中删除所有 caffe 有关的路径，依然可以 <code>import caffe</code>，但无法有效调用。</li></ol><br><h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h1><ol><li>针对问题 3，使用 <code>caffe.__file__</code> 可以查看所调用 caffe 的文件地址，发现调用的是 caffe2 库下的一个 caffe 文件夹。这显然是不对的。由于 python 在其 <code>PYTHONPATH</code> 中依次向后查找调用库，当查找到第一个后，就使用第一个路径中的库，因此如果后面的 <code>PYTHONPATH</code> 中也包含某个库的话，后面的库就不会被调用。因此，我们需要将 caffe 的路径放在 caffe2 路径的前面。</li><li>针对问题 1，由于我在 <code>/home/taoxuan/</code> 路径下有一个 caffe 库，因此将其添加进 <code>PYTHONPATH</code>，但无法有效调用。将其从 <code>PYTHONPATH</code> 中删除后，使用 <code>caffe.__file__</code> 却依然指向此 caffe 库，遂将此库改名。</li><li>针对问题 2，将其他用户的 caffe 路径添加进 <code>PYTHONPATH</code> 后，依然正确调用，个人猜测是由于权限的问题。</li></ol><br><h1 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h1><p>将其他用户下的有效 caffe 库拷贝至个人目录下，更改所有者及组，<code>sudo chown -R taoxuan:taoxuan /path/to/caffe</code>。然后将此库的路径添加进 <code>PYTHONPATH</code>，这样就可以有效调用。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Caffe </tag>
            
            <tag> 权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下 Caffe 安装及测试</title>
      <link href="/2018/06/27/Caffe-install/"/>
      <url>/2018/06/27/Caffe-install/</url>
      
        <content type="html"><![CDATA[<p>由于工作需求，需在 Windows 平台安装 Caffe, 并在此基础上添加新的层，对 Caffe 进行重新编译。</p><a id="more"></a><br><h1 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h1><ul><li>Windows 10</li><li>Visual Studio 2015 Community Edition</li><li>Cuda 8.0</li><li>Cudnn 5.1</li><li>Anaconda2 虚拟环境中的 python 3.5</li><li>Cmake 3.11.1</li><li>BVLC/Caffe</li><li>Git</li></ul><br><h1 id="step-1"><a class="markdownIt-Anchor" href="#step-1"></a> STEP 1</h1><p>默认已经安装好 Cuda 8.0，并已经将 Cuda 的安装路径中的某些文件夹添加进环境变量。<br>默认已经将 Cudnn 中的文件放置到 Cuda 安装路径的对应文件夹中。<br>将 Cmake 命令所在路径添加进环境变量<br>将 python 环境中 python.exe 以及 lib 文件夹所在路径添加进环境变量。<br>将 Git 命令添加进环境变量。</p><br><h1 id="step-2"><a class="markdownIt-Anchor" href="#step-2"></a> STEP 2</h1><p>从 BVLC 的 Caffe Repo 上下载 Caffe 工程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/BVLC/caffe.git</span><br><span class="line"><span class="built_in">cd</span> caffe</span><br><span class="line">git checkout windows</span><br></pre></td></tr></table></figure><br><h1 id="step-3"><a class="markdownIt-Anchor" href="#step-3"></a> STEP 3</h1><p>修改 BVLC/Caffe windows 分支下 <code>scripts\build_win.cmd</code> 文件<br>因为我们没有定义 <code>APPVEYOR</code>，所以直接拉到 <code>else</code>（大约 69 行）以后。在 <code>else</code> 代码块中，设置相应参数：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WITH_NINJA=<span class="number">0</span> // 不使用 ninja 这个 generator，因为会报错。查看 cmake 拥有的 generator, 在 <span class="built_in">cmd</span> 中输入 cmake --<span class="built_in">help</span></span><br><span class="line">CPU_ONLY=<span class="number">0</span></span><br><span class="line">PYTHON_VERSION=<span class="number">3</span> // 根据自己的 python 版本来</span><br><span class="line">BUILD_PYTHON=<span class="number">1</span> // 安装 pycaffe</span><br><span class="line">BUILD_PYTHON_LAYER=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">// 在 cake -G ... 这一段中，添加一个选项.(其实这一段可以不加我感觉，因为已经将 cudnn 文件放到 cuda 的安装路径中了，不过加了也没啥)</span><br><span class="line">-DCUDNN_ROOT=H:/Develop/cudnn/cudnn5.<span class="number">1</span>/cuda ^</span><br></pre></td></tr></table></figure><br><h1 id="step-4"><a class="markdownIt-Anchor" href="#step-4"></a> STEP 4</h1><p>运行 <code>scripts/build_win.cmd</code> 文件，等其完成。它会先编译 <code>.cu</code> 文件，再编译 <code>.cpp</code> 文件。最后会生成 <code>caffe.exe</code> 等可执行文件以及 caffe 的 python 接口。<br>注意：在编译过程中，脚本可能会下载一个依赖包到 <code>C:\\Users\username\.caffe\dependencies</code> 文件夹下，可手动下载，将其解压到此文件夹即可。<br>Note：此脚本执行完毕后，不用再打开 <code>Caffe.sln</code> 工程进行 build，因为这些工作在脚本里都完成了。<br>最后得到的可执行程序在 <code>caffe/build/tools/Release</code> 中，python 接口在 <code>caffe/python/caffe</code> 中，将 <code>caffe/python/caffe</code> 路径添加进 python 的环境变量中或者将此文件夹拷贝进 python 的 <code>site-packages</code> 中均可在 python 中调用 caffe 的 python 接口。</p><br><h1 id="step-5"><a class="markdownIt-Anchor" href="#step-5"></a> STEP 5</h1><p>对编译结果进行测试。参考 <a href="https://software.intel.com/zh-cn/articles/installation-and-configuration-of-bvlc-caffe-under-windows-the-caffe-learning-notes-part1" target="_blank" rel="noopener">这篇文章</a></p><br><h1 id="添加自定义层"><a class="markdownIt-Anchor" href="#添加自定义层"></a> 添加自定义层</h1><p>由于任务需求，因此需要在 Caffe 中添加新的层，这只要涉及 caffe 中的 <code>/include</code> 和 <code>/src</code> 文件夹，将需要添加的文件拷贝进原生的 BVLC/Caffe 中，（注意：不可整体替换这两个文件夹中的所有源码文件，因为相同文件名文件的代码可能是有区别的，因此，只将新增的源码添加进 Caffe 工程中即可），并根据改变，修改 <code>src/proto/caffe.proto</code> 文件，具体方法看 <a href="https://blog.csdn.net/bvl10101111/article/details/74837156" target="_blank" rel="noopener">这篇文章</a>。<br>最后，按上述步骤重新编译即可。</p><br><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ol><li><a href="https://software.intel.com/zh-cn/articles/installation-and-configuration-of-bvlc-caffe-under-windows-the-caffe-learning-notes-part1" target="_blank" rel="noopener">https://software.intel.com/zh-cn/articles/installation-and-configuration-of-bvlc-caffe-under-windows-the-caffe-learning-notes-part1</a></li><li><a href="https://blog.csdn.net/bvl10101111/article/details/74837156" target="_blank" rel="noopener">https://blog.csdn.net/bvl10101111/article/details/74837156</a></li></ol><br><h1 id="trouble-shooting"><a class="markdownIt-Anchor" href="#trouble-shooting"></a> Trouble Shooting</h1><h2 id="trouble-on-windows"><a class="markdownIt-Anchor" href="#trouble-on-windows"></a> Trouble on Windows</h2><p>1.在按上面的步骤成功编译后，再使用命令 <code>/path/to/caffe.exe test -model /path/to/my.prototxt -weights /path/to/my.caffemodel</code> 进行测试，会报错如下图。 <img src="1.png" alt="报错信息"><br>可以看出，新添加的五个层里有三个已经存在，分别是 <code>DeformableROIPooling</code>, <code>ROIPooling</code> 和 <code>SmoothL1Loss</code>, 不存在的两个层为 <code>DeformableConvolution</code> 和 <code>ResizeBilinear</code>. 通过查看 <code>src/caffe/layers/deformabe_conv_layer.cpp</code> 和 <code>src/caffe/layers/resize_bilinear_layer.cpp</code> 文件，发现这两个文件都在最后一行差了 <code>REGISTER_LAYER_CLASS(DeformableConvolution);</code> 或 <code>REGISTER_LAYER_CLASS(ResizeBilinear);</code>。在这两个文件后分别添加对应的代码，重新编译。<br>通过比较，发现原版 BVLC-Caffe 的 <code>src/caffe/layer_factory.cpp</code> 和 添加过新层的 cafe-fast-rcnn 这个 Caffe 的 <code>src/caffe/layer_factory.cpp</code> 文件有所不同，更改过的文件中有关于 <code>DeformableConvolution</code> 和 <code>ResizeBilinear</code> 的内容，（可通过文档比较工具查看）。个人猜测这个就是上面 <code>src/caffe/layers/deformabe_conv_layer.cpp</code> 和 <code>src/caffe/layers/resize_bilinear_layer.cpp</code> 文件没有最后一个 <code>REGISTER</code> 语句，而其在 Linux 平台能够调用 <code>DeformableConvolution</code> 层的原因。但是，我从网上找到一个博客说，新版 Caffe 不需要在 <code>layer_factory.cpp</code> 文件中添加相关内容，只需要在对应 <code>.cpp</code> 文件中写上 <code>REGISTER</code> 语句就好。</p><blockquote><p>2）配置该层：包括注册和在caffe.proto中设置相关参数。在较新版本的caffe中，用户只需要<br>在编译caffe的过程中，会根据caffe.proto文件中定义的参数接口来编译相关层的代码。一般只需要做3.1和3.2两部即可。<br>注意：不需要在layer_factory.cpp文件中添加新层的头文件。<br><a href="https://blog.csdn.net/king_lu/article/details/53812216" target="_blank" rel="noopener">来源</a></p></blockquote><p>经过验证，我发现确实只要在 <code>.cpp</code> 文件后面添加对应的 <code>REGISTER</code> 语句就好。</p><p>2.在解决了上述问题后，执行 <code>/path/to/caffe.exe test -model /path/to/my.prototxt -weights /path/to/my.caffemodel -gpu 0</code>，报错 <code>Py_Initialize fails - unable to load the file system codec</code>，找了很多资料，觉得可能是多个版本的 python 冲突问题，但是我把环境变量 <code>PATH</code> 中全部改成有关虚拟环境 <code>tensorflow</code> 下的路径都无效。个人感觉是不知道在哪里仍然默认指向 Anaconda2 的外层 python，即使在 <code>PATH</code> 中修改也无效。因此，我重新用 python2.7 编译了自定义的 caffe。完成后执行上句命令，不再报此错误，而是报 <code>ImportError: No module named site</code>，我使用<a href="https://stackoverflow.com/questions/5599872/python-windows-importerror-no-module-named-site" target="_blank" rel="noopener">此处的最高票答案</a>解决了问题。继续执行前面的命令，出现 <code>ImportError: No module named gpu_nms</code>，这是由代码 <code>from nms.gpu_nms import gpu_nms</code> 引起的，目的是从 <code>gpu_nms.so</code> 文件中导入 <code>gpu_nms</code> 函数。而 <code>gpu_nms.so</code> 是 linux 平台上的动态链接文件，不能在 windows 上使用，因此需要从源码重新编译出 windows 下的动态链接文件。使用 <a href="https://github.com/MrGF/py-faster-rcnn-windows" target="_blank" rel="noopener">此工程</a> 并运行 <code>python setup_cuda.py build</code> 可编译出 Windows 下的 <code>.pyd</code> 文件供 python 导入。（运行前需先修改 <code>include_dirs = [numpy_include, '/path/to/cuda/include']</code>，且有可能会提示需安装 VC 9.0，根据提示下载安装即可），这样，就能导入 gpu_nms 函数了。</p><p>3.解决上述问题后，执行命令，会报一个 <code>MS VC</code> 有关的错 - <code>Runtime error R6034</code>，这个是一个与 <code>msvcr90.dll</code> 有关的错。这个 <code>dll</code> 文件是由系统提供的，根据后来分析发现，Anaconda 中也会提供这两个文件，分别位于 Anaconda 根目录和 <code>Library/bin</code> 目录下。我根据<a href="https://stackoverflow.com/questions/14552348/runtime-error-r6034-in-embedded-python-application" target="_blank" rel="noopener">这个问题的最佳答案</a>解决了此问题。由于环境变量 <code>PATH</code> 较为复杂，我无法修改 <code>PATH</code>，因此我将 Anaconda 中的两个文件进行了重命名，解决了这个问题。</p><p>4.解决了上述问题后，使用上述命令执行依旧错误，主要是在 <code>Creating layer rpn_rois</code> 处，会出现 <code>Caffe.exe 已经停止运行</code> 的错误。但是没有任何错误信息，困扰了好久。后来，我尝试使用 pycaffe 进行 test，在 <code>caffe.Net()</code> 函数中传入 <code>model_path</code> 和 <code>weights_path</code> 后执行，报错 <code>AttributeError: 'ProposalLayer' object has no attribute 'param_str_'</code>，这是由于 ProposalLayer 的定义中，有一句 <code>layer_params = yaml.load(self.param_str_)</code>，这是老版的 caffe 中定义的属性。由于我的是在新版的 bvlc-caffe 的基础上添加的新的层，因此会报错。而在 Linux 中没有报错，个人觉得是由于 Linux 版本的 modified caffe 是基于老版的 caffe 得到的。解决办法：将 <code>param_str_</code> 改成 <code>param_str</code> 即可，参考<a href="https://github.com/rbgirshick/py-faster-rcnn/issues/219" target="_blank" rel="noopener">这里</a>。</p><br><h2 id="trouble-on-linux"><a class="markdownIt-Anchor" href="#trouble-on-linux"></a> Trouble on Linux</h2><p>在 linux 中同样执行 <code>/path/to/caffe test -model /path/to/my.prototxt -weights /path/to/my.caffemodel</code> 时，会先报错<br><code>Creating layer rpn_rois ImportError: No module named rpn.proposal_layer</code><br>这是因为在执行时，<code>my.prototxt</code> 需要调用 <code>rpn/proposal_layer.py</code> 文件，因此，需要将 <code>rpn</code> 所在路径加入 <code>PYTHONPATH</code> 或者在此路径下执行。<br>上一步解决后，再次执行命令，会报错 <code>Check failed: registry.count(type) == 0 (1 vs. 0) Solver type Nesterov already registered.</code>. 这是因为 <code>.bashrc</code> 文件中将一个原生的 caffe 的 python 接口添加进了 <code>PYTHONPATH</code>, 而真正使用的是自己更改过的 caffe. 因此，将 <code>.bashrc</code> 中 <code>PYTHONPATH</code> 关于原生 caffe 的部分去掉。<br>后来，又报 <code>rpn/proposal_layer.py</code> 文件中 <code>calss ProposalLayer(caffe.Layer):</code> <code>AttributeError:'module' object has no attribute 'Layer'</code>。此时，将自己更改过的 caffe 的 python 接口添加进 <code>PYTHONPATH</code> 中即可。<br>总之，解决上面 2 个错误的关键就是将自己所使用的版本的 caffe 添加进 <code>PYTHONPATH</code>，并确保其他版本的 caffe 不在其中。<br>接着，继续运行同样的命令，会报错 <code>Check failed: status == CUDNN_STATUS_SUCCESS (8 vs. 0) CUDNN_STATUS_EXECUTION_FAILED</code>. 个人感觉这是一个跟 gpu 有关的错，由于 <code>.prototxt</code> 文件中在 <code>rpn_rois</code> 层设置了 <code>gpu_id</code> 参数，因此，需将此参数与 <code>caffe test</code> 命令执行时使用的 gpu id 相同。若文件内设置为 1，则命令应为 <code>/path/to/caffe test -model /path/to/my.prototxt -weights /path/to/my.caffemodel -gpu 1</code></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Caffe </tag>
            
            <tag> 安装 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 多线程模块 threading 及 多进程模块 multiprocessing</title>
      <link href="/2018/05/22/python-thread/"/>
      <url>/2018/05/22/python-thread/</url>
      
        <content type="html"><![CDATA[<p>关于 python 多线程模块 threading 以及 多进程模块 multiprocessing 的使用。</p><p><em><font color="orange">注意：本文代码均在 python 3.5 中实现，其他版本未亲测。</font></em></p><a id="more"></a><h1 id="threading-模块"><a class="markdownIt-Anchor" href="#threading-模块"></a> threading 模块</h1><p>  关于 python 的多线程模块 threading 的使用方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread 1 start'</span>, time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(<span class="string">'thread 1 end'</span>, time.time())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread 2 start'</span>, time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(<span class="string">'thread 2 end'</span>, time.time())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread 3 start'</span>, time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(<span class="string">'thread 3 end'</span>, time.time())</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=fun1)</span><br><span class="line">t2 = threading.Thread(target=fun2)</span><br><span class="line">t3 = threading.Thread(target=fun3)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br><span class="line">print(<span class="string">'主线程中间'</span>, time.time())</span><br><span class="line">t3.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(<span class="string">'主线程结束'</span>, time.time())</span><br></pre></td></tr></table></figure><p>输出为：</p><blockquote><p>thread 1 start 1526973092.5235336<br>thread 1 end 1526973097.535105<br>thread 2 start 1526973097.5354195<br>thread 3 start主线程中间 1526973097.5474474<br>1526973097.5414264<br>thread 2 end 1526973107.548385<br>thread 3 end 1526973112.5574799<br>主线程结束 1526973112.5574799</p></blockquote><p>  可以看出，thread 1 执行完毕了后，同时开始执行（几乎） thread2, thread3 和 print 语句，（print 语句是主线程中的），这是因为，在 thread1, thread2 调用之前，t1.join() 已经阻塞了别的线程。由于 thread3 用时较长，因此 thread2 先结束，然后 thread3 结束。在 thread3 结束后，主线程才执行最后的 print 语句。</p><p>  由于 python GIL (Global Interpreter Lock) 的限制，python 的多线程并没有达到真正的多线程的效果，不能充分地利用 CPU。但是多进程可以充分地利用 CPU，因此使用 multiprocessing 模块来使用多进程。</p><h1 id="multiprocessing-模块"><a class="markdownIt-Anchor" href="#multiprocessing-模块"></a> multiprocessing 模块</h1><p>  此处采用线程池的方式进行多线程操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(l, name, sur)</span>:</span></span><br><span class="line">    print(l + <span class="string">' '</span> + name + <span class="string">' '</span> + sur)</span><br><span class="line"></span><br><span class="line">arg_1 = [<span class="string">'adf'</span>, <span class="string">'freg'</span>, <span class="string">'gr3q'</span>, <span class="string">'saf'</span>, <span class="string">'qrg'</span>]</span><br><span class="line">arg_2 = [<span class="string">'sean'</span>]</span><br><span class="line">arg_3 = [<span class="string">'tao'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = Pool(processes=<span class="number">8</span>)</span><br><span class="line">    pool.starmap(func=fun, iterable=product(arg_1, arg_2, arg_3))</span><br><span class="line">    print(<span class="string">'all done'</span>)</span><br></pre></td></tr></table></figure><p>输出为:<br><img src="pic_1.png" alt="multiprocessing 输出"></p><p>以上代码为针对多参数的函数，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.starmap(func=fun, iterable=product(arg_1, arg_2, arg_3))</span><br></pre></td></tr></table></figure><p>是通过 itertools 的 product 函数，将三个参数进行笛卡儿积。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">product([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="string">'1'</span>]) <span class="comment"># 结果为 ('a','1')，('b', '1'), ('c', '1')</span></span><br></pre></td></tr></table></figure><p>关于 product 函数以及 itertools 包的使用，可点击<a href="https://docs.python.org/3/library/itertools.html#itertools.product" target="_blank" rel="noopener">这里</a>了解更多。</p><p>值得注意的是，product 函数的输入必须是 iterable 的。这样，才可以进行 笛卡儿积。</p><p>此外，多参数进程池还有别的方法，但未亲测。<br><a href="http://python.omics.wiki/multiprocessing_map/multiprocessing_partial_function_multiple_arguments" target="_blank" rel="noopener">pool.map - multiple arguments</a></p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p>1.<a href="https://stackoverflow.com/questions/5442910/python-multiprocessing-pool-map-for-multiple-arguments/24446525" target="_blank" rel="noopener">https://stackoverflow.com/questions/5442910/python-multiprocessing-pool-map-for-multiple-arguments/24446525</a><br>2.</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> thread </tag>
            
            <tag> process </tag>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 进程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jupyter notebook 增加内核</title>
      <link href="/2018/05/15/jupyter-add-kernel/"/>
      <url>/2018/05/15/jupyter-add-kernel/</url>
      
        <content type="html"><![CDATA[<p>在 jupyter notebook 中添加不同的 python 内核。</p><a id="more"></a><p>由于在 anaconda2 中安装了虚拟环境 tensorflow, 且虚拟环境中的 python 为 3.5，在虚拟环境中安装了 jupyter notebook，当在虚拟环境中的 jupyter notebook 中新建脚本时，只能选择 python3，因此想要把 anaconda2 中 2.7 的 python 内核导入进来，这样可以直接在一个 jupyter notebook 中新建不同内核的 python 脚本。</p><p>本文介绍在 python3 中添加 python2 内核。</p><p>首先确认在Python3下已安装了内核：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipython kernel install --user</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m ipykernel install --user</span><br></pre></td></tr></table></figure><p>然后确保 python2 下安装了 ipykernel</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip2 install -U ipykernel</span><br></pre></td></tr></table></figure><p>然后运行如下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 -m ipykernel install --user</span><br></pre></td></tr></table></figure><p>至此，运行 jupyter notebook 就可以添加多个内核。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vim</title>
      <link href="/2018/05/08/vim/"/>
      <url>/2018/05/08/vim/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>以下命令可以对标点内的内容进行操作。<br><code>ci'、ci&quot;、ci(、ci[、ci{、ci&lt;</code> - 分别更改这些配对标点符号中的文本内容<br><code>di'、di&quot;、di(或dib、di[、di{</code>或<code>diB、di&lt;</code> - 分别删除这些配对标点符号中的文本内容<br><code>yi'、yi&quot;、yi(、yi[、yi{、yi&lt;</code> - 分别复制这些配对标点符号中的文本内容<br><code>vi'、vi&quot;、vi(、vi[、vi{、vi&lt;</code> - 分别选中这些配对标点符号中的文本内容</p><p>另外如果把上面的 <code>i</code> 改成 <code>a</code> 则可以连带配对的标点一起操作～～</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deformable Convolutional Networks 论文理解</title>
      <link href="/2018/05/07/Deformable-Convolutional-Networks/"/>
      <url>/2018/05/07/Deformable-Convolutional-Networks/</url>
      
        <content type="html"><![CDATA[<p>关于 Deformable Convolutional Networks 的一些个人理解。</p><a id="more"></a><p>–   有效感受野 Effective Receptive Field<br><a href="">Understanding the effective receptive field in deep convolutional neural networks</a></p><blockquote><ul><li>感受野中的像素对最后的输出响应贡献不一。靠近中心的像素贡献更大。</li></ul></blockquote><ul><li>有效感受野只占理论感受野的一小部分，并且呈高斯分布。</li><li>有效感受野尺寸的增长幅度不是像理论感受野那样随卷积数目线性增长，而是与卷积数目的均方根线性相关。</li></ul><p>这个发现说明，<strong>即使是很深的 CNN 网络的顶层的单元的有效感受野也可能不够大。</strong></p><br><h1 id="deformable-convolution"><a class="markdownIt-Anchor" href="#deformable-convolution"></a> Deformable Convolution</h1><p>  对一个3*3的 deformable conv 来说，先在分支上进行卷积操作，得到的 offset field 与 input feature map 尺寸相同，通道数为 2N（对 3*3 卷积，N=9）。这样，offset field 每个位置处的 2N 维向量代表在 input feature map 上此处卷积时对应的 N 个位置的偏移。如下图所示。<br><img src="deform_conv.PNG" alt="3*3 deformable convolution"></p><h1 id="deformable-roi-pooling"><a class="markdownIt-Anchor" href="#deformable-roi-pooling"></a> Deformable ROI Pooling</h1><p>  首先通过标准的兴趣区域池化（绿色）获得兴趣区域对应的特征，该特征通过一个全连接层得到兴趣区域每个部位(每个 bin)的位移量。用该位移作用在标准的 ROI Pooling 的每个区域块上，得到 可变形兴趣区域池化（蓝色），以获得不局限于兴趣区域固定网格的特征<br>  简单地说，假如要对某个 ROI 区域进行 3*3 的 Deformable ROI Pooling，那么则先对此 ROI 进行普通的 ROI Pooling，得到 3*3*C (C 为 ROI pooling 前的 feature map 的 channel 数) 的 feature map。然后，对得到的 feature map 进行 fc，fc 层的输出个数为 k*k*2，其中 k 为 pooling 后的尺寸，此处为 3。这样，就得到 ROI 区域中每块 （共 k*k 块）的偏移了。根据这个偏移，得到每个块的新的位置，进行 ROI Pooling，就是 Deformable ROI Pooling。<br>所以，在 Deformable ROI Pooling 中，偏移是针对每个块（bin）的，某个 bin 内的所有像素的偏移都是一样的。<br><img src="deform_roi_pooling.PNG" alt="3*3 deformable ROI Pooling"></p><h1 id="position-sensitive-ps-roi-pooling-from-r-fcn"><a class="markdownIt-Anchor" href="#position-sensitive-ps-roi-pooling-from-r-fcn"></a> Position-Sensitive (PS) RoI Pooling - From R-FCN</h1><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> deformable convolution </tag>
            
            <tag> deformable RoI pooling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPN 论文理解</title>
      <link href="/2018/04/26/FPN/"/>
      <url>/2018/04/26/FPN/</url>
      
        <content type="html"><![CDATA[<p>本文给出了对 FPN 网络的理解。</p><a id="more"></a><h1 id="网络结构"><a class="markdownIt-Anchor" href="#网络结构"></a> 网络结构</h1><p>  常见的特目标测网络中特征的利用方式主要有 4 种</p><blockquote><p>*(a) 图像金字塔，即将图像做成不同的 scale，然后不同 scale 的图像生成对应的不同 scale 的特征。这种方法的缺点在于增加了时间成本。有些算法会在测试时候采用图像金字塔。<br>(b) 像 SPP net，Fast RCNN，Faster RCNN 是采用这种方式，即仅采用网络最后一层的特征。<br>© 像 SSD (Single Shot Detecto) 采用这种多尺度特征融合的方式，没有上采样过程，即从网络不同层抽取不同尺度的特征做预测，这种方式不会增加额外的计算量。作者认为 SSD 算法中没有用到足够低层的特征（在 SSD 中，最低层的特征是 VGG 网络的 conv4_3），而在作者看来足够低层的特征对于检测小物体是很有帮助的。<br>© 本文作者是采用这种方式，顶层特征通过上采样和低层特征做融合，而且每层都是独立预测的。</p></blockquote><ul><li></li></ul><p><img src="pic1.png" alt="检测网络的 4 种特征利用方式"><br>图中，线越粗表示特征的语义程度越强。</p><p>  与以往的方式不同，FPN 网络在 pyramid 的所有 level 上都进行预测。<br><img src="pic2.png" alt="FPN 网络在 pyramid 的所有 level 上进行预测"></p><p>  FPN 网络的内部结构<br><img src="pic3.png" alt="FPN 网络的内部结构"></p><blockquote><p><strong>自底向上</strong>其实就是网络的前向过程 (论文中使用的是 ResNet )。在前向过程中，feature map 的大小在经过某些层后会改变，而在经过其他一些层的时候不会改变，作者将不改变 feature map 大小的层归为一个 stage，因此每次抽取的特征都是每个 stage 的最后一个层输出，这样就能构成特征金字塔。<br><strong>自顶向下</strong>的过程采用上采样进行，而横向连接则是将上采样的结果和自底向上生成的相同大小的 feature map 进行融合。在融合之后还会再采用 3*3 的卷积核对每个融合结果进行卷积，目的是消除上采样的混叠效应。并假设生成的 feature map 结果是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>5</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P_2, P_3,P_4,P_5\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，和原来自底向上的卷积结果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>C</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>5</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{C_2,C_3,C_4,C_5\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 一一对应。</p></blockquote><br><h1 id="feature-pyramid-network-for-rpn"><a class="markdownIt-Anchor" href="#feature-pyramid-network-for-rpn"></a> Feature Pyramid Network for RPN</h1><p>  FPN 可以用在 RPN 网络中，从而提高多尺度物体的检测性能。与 Faster R-CNN 中不同的是，FPN 在不同的 level 上使用 anchor，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>5</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>6</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P_2, P_3,P_4,P_5, P_6\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 上的 anchor 尺寸分别是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mn>3</mn><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mn>6</mn><msup><mn>4</mn><mn>2</mn></msup><mo separator="true">,</mo><mn>12</mn><msup><mn>8</mn><mn>2</mn></msup><mo separator="true">,</mo><mn>25</mn><msup><mn>6</mn><mn>2</mn></msup><mo separator="true">,</mo><mn>51</mn><msup><mn>2</mn><mn>2</mn></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{32^2, 64^2, 128^2, 256^2, 512^2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">3</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>。可以看出，尺寸较大的 feature map 上的 anchor 的尺寸较小，适合用来检测小物体。<br><img src="pic4.png" alt="FPN 的 anchor 机制"></p><hr>*<font color="orange">关于 anchor 尺寸选取的个人理解。</font>*&emsp;&emsp;RPN 网络的输入 feature map 在原图上的感受野是固定的，取决于此 featured map 相对于原图的尺寸缩小了多少倍。缩小的倍数越大，相邻感受野的中心距离越远（因为 feature map 尺寸越小，就需要用越少的感受野覆盖整张原图，因此相邻感受野的中心距离就会越远）。如果在尺寸较小的 feature map 上使用尺寸较小的 anchor 的话，相邻感受野的 anchor 可能会不重叠，从而漏掉物体。![anchor 尺寸较小](pic5.png)&emsp;&emsp;但是在这种情况下选择较大尺寸 anchor 也会产生新的问题。当遇到小物体时，如果与大的 anchor 计算 IoU 时，IoU 可能较小，在生成样本时也会遇到问题。![anchor 尺寸较大时检测小物体](pic6.png)&emsp;&emsp;可以看出，由于 feature map 尺寸较小，对应在原图上的感受野个数也较少，因而需要用较少的 anchor 来覆盖原图。若 feature map 的尺寸较大，则用来覆盖原图的感受野的个数较多，则每个 anchor 的尺寸就不用太大，因而可以更好地检测小物体。![较大 feature map](pic7.png)&emsp;&emsp;可以看出，当 feature map 尺寸较大时，就可以用较小的 anchor 来覆盖原图，这样既不会出现 anchor 不相交从而漏检的情况，也不会造成小物体和 anchor 的 IoU 较小从而无法正确产生正样本的情况。<p><strong>从以上分析可以得出结论，尺寸较大的 feature map 适合用来检测用来检测小物体，尺寸较小的 feature map 适合用来检测大物体。因此，FPN 的思想就是将各种尺寸的 feature map 结合起来，将大物体分配给小的 feature map 进行检测，将小物体分配给大 feature map 进行检测，从而提升检测性能。</strong></p><br><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>  在 FPN 中，anchor 机制跟 Faster R-CNN 有所不同。FPN 产生了上文所述的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>5</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>6</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P_2, P_3,P_4,P_5, P_6\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 不同尺寸的 feature map，在一个 feature map 上只使用一个尺度的 anchor（Faster R-CNN 中为 3 个尺度）。在尺寸较大的 feature map 中使用尺度较小的 anchor，能够更好地检测小物体。</p><p>FPN 中有多个尺度的 feature map，每一个 feature map 作为输入进入一个 RPN。因此，有多少 feature map，就有多少 RPN。最后，将这些 RPN 的输出进行综合，得到所有的 proposals。</p><br><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://blog.csdn.net/u014380165/article/details/72890275" target="_blank" rel="noopener">https://blog.csdn.net/u014380165/article/details/72890275</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> Faster R-CNN </tag>
            
            <tag> FPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPN 中的 loss 理解</title>
      <link href="/2018/04/25/Faster-R-CNN/"/>
      <url>/2018/04/25/Faster-R-CNN/</url>
      
        <content type="html"><![CDATA[<p>本文解释了 Faster R-CNN 中的 RPN 部分的 GT 生成以及 loss 的计算方式.</p><a id="more"></a><h1 id="rpn-结构"><a class="markdownIt-Anchor" href="#rpn-结构"></a> RPN 结构</h1><p>  RPN 网络使用 特征提取网络的输出 feature map 作为输入. 然后在此基础上,用 anchor 的方式计算 分类误差 和 定位误差. Faster R-CNN 中的 RPN 网络在 caffe 框架中如下图所示.<br><img src="pic1.PNG" alt="RPN 网络结构图"><br>假设 RPN 网络输入 feature map 尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>×</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">s\times s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>, 那么图中 <em>rpn_cls_score</em> 和 <em>rpn_bbox_pred</em> 层的输出尺寸分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>×</mo><mi>s</mi><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">s\times s\times8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 以及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>×</mo><mi>s</mi><mo>×</mo><mn>36</mn></mrow><annotation encoding="application/x-tex">s\times s\times36</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">6</span></span></span></span>. <em>rpn-data</em> 是真实值, 与这两个 feature map 计算 loss. 可以推测, <em>rpn-data</em> 具有两个与 <em>rpn_cls_score</em> 和 <em>rpn_bbox_pred</em> 分别对应的 GT feature map. 对应于 <em>rpn_cls_score</em> 的真实值的尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>×</mo><mi>s</mi><mo>×</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">s\times s\times 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>, 对应于 <em>rpn_bbox_pred</em> 的真实值的尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>×</mo><mi>s</mi><mo>×</mo><mn>36</mn></mrow><annotation encoding="application/x-tex">s\times s\times 36</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">6</span></span></span></span>.</p><br><h1 id="ground-truth-的尺寸和计算方式"><a class="markdownIt-Anchor" href="#ground-truth-的尺寸和计算方式"></a> Ground Truth 的尺寸和计算方式</h1><p><em><font color="orange">以下部分为个人理解</font></em><br>  在 Faster R-CNN 中, RPN 输入 feature map 的每个空间位置都对应 9 个 anchor, (共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>×</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">s\times s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>个空间位置), 每个 anchor 产生一个预测框. Faster R-CNN 的正负样本生成策略是:</p><blockquote><ol><li>将每一个 GT box 与所有的 anchor 计算 IoU, 将 IoU 最大的 anchor 与当前 GT box 对应, 作为正样本, 记为 1. (这就保证了每个 GT box 至少有一个 anchor 与之对应)</li><li>将每一个 anchor 与 所有 GT box 计算 IoU, 若当前 anchor 与某一个 GT box 的 IoU 超过 0.7, 则将当前 anchor 与此 GT box 对应, 将当前 anchor 作为正样本, 记为 1. 对与所有 GT box 的 IoU 都小于 0.3 的 anchor 作为负样本, 记为 -1. 不满足上述条件的其他 anchor 不计入讨论, 记为 0.</li></ol></blockquote><p>  根据上述策略可以知道, anchor 和 GT box 之间是 多对多 的关系. 但是这是不合理的, 若一个 anchor 对应了 多个 GT box, 那岂不是这个 anchor 要负责检测多个物体? 这是不可能的. 因此, 个人感觉上述策略中, 第 2 步是在不满足第 1 步条件的 anchor 中进行的. 一旦一个 anchor 找到了与之对应的 GT box, 它就不会再与其他 GT box 计算 IoU, 这样, 即使某个 anchor 与 多个 GT box 的 IoU 都大于 0.7, 此 anchor 仍然只能与一个 GT box 对应.</p><p><font color="orange"><strong>2018/11/06 更新:</strong></font> 事实上，在为每个 anchor 匹配 GT box 时，是每一个 anchor 和每一个 GT box 算 IoU，为每个 anchor 找到与之 IoU 最大的 GT box。并计算每个 anchor 和与之对应的 GT box 之间的 delta 作为 RPN 学习的目标。</p><p>  因此, 从 GT box 的角度看, <font color="green">一个 GT box 有一个或多个 anchor 与之对应, 这些 anchor 负责检测这个 GT box.</font></p><br><h1 id="ground-truth-及-相关图示"><a class="markdownIt-Anchor" href="#ground-truth-及-相关图示"></a> Ground Truth 及 相关图示</h1><p>下图为每一个空间位置处的向量.<br><img src="pic2.png" alt="每个空间位置处的向量"><br>  在上图中, GT class 是一个 9 维的向量, 其可能值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">1,-1,0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span></span></span></span>, 1 表示正样本, 0 表示负样本, -1 表示非样本. 相同颜色表示某一空间位置处的不同类型的值. 在 GT class 向量中某处为 1 , 表示此空间位置处的此处的 anchor 为正样本, GT bbox 向量中对应的 4 个值为此 anchor 对应的 GT box 的真实 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,w,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>. 这样就可以与 rpn_cls_score 和 rpn_bbox_pred 对应位置的预测值计算损失. 针对正样本, 要计算 分类 和 定位 两种损失, 对于负样本, 只计算 分类损失, 因此 GT bbox 向量中对应位置的值不参与计算. 对于非样本, 不计算任何损失. 因此在生成 GT bbox 向量时, 只需计算正样本 anchor 对应 GT box 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,w,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span> 值.</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> Faster R-CNN </tag>
            
            <tag> RPN </tag>
            
            <tag> anchor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yolo v2 论文理解 （以及部分 yolo v3）</title>
      <link href="/2018/04/20/Yolo-v2/"/>
      <url>/2018/04/20/Yolo-v2/</url>
      
        <content type="html"><![CDATA[<p>本文针对 Yolo v2 的一些处理方法和细节给出了自己的理解。不一定正确，如有错误请指正。</p><a id="more"></a><p>本文尝试了使用一系列的方法来提升检测效果。<br><br>sco</p><h1 id="better"><a class="markdownIt-Anchor" href="#better"></a> Better</h1><h2 id="batch-normalization"><a class="markdownIt-Anchor" href="#batch-normalization"></a> Batch Normalization</h2><ul><li>在所有卷积层后加 Batch Normalization。</li><li>mAP 提高了2%。</li></ul><h2 id="high-resolution-classifier"><a class="markdownIt-Anchor" href="#high-resolution-classifier"></a> High Resolution Classifier</h2><ul><li>Yolo v1 使用 224×224 的图像预训练分类器，并用来对448的图像进行检测。这意味着网络的卷积层要在适应新的分辨率的同时还要学习检测。</li><li>Yolo v2 直接使用 448×448 的图像进行预训练。</li><li>mAP提高了4%。</li></ul><h2 id="convolutional-with-anchor-boxes"><a class="markdownIt-Anchor" href="#convolutional-with-anchor-boxes"></a> Convolutional With Anchor Boxes</h2><ul><li>Yolo 通过在卷积层上加全连接层来直接预测bbox的坐标。而 Faster R-CNN 使用 RPN 网络来预测 bbox 相对于 anchor 的 offset 和 confidence。预测 offset 比直接预测坐标来得简单。</li><li>Yolo v2 去除了全连接层，并减少了一个 Pooling 层。这样最后的 feature map 尺寸是输入的1/32。在这里，网络使用 416 尺寸而不是 448，因为作者想要最后的 feature map 尺寸为奇数。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>416</mn><mo>÷</mo><mn>32</mn><mo>=</mo><mn>13</mn></mrow><annotation encoding="application/x-tex">416\div32=13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span></span></span></span>。这是因为作者观察发现，很多物体都在图像的中间，因此检测这些图像中间的物体时，只需用最中心的那个位置而不是偶数情况下的中心4个位置。(个人理解为：在这种情况下，那些在图像中心位置的物体的中心点都会落在这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>13</mn><mo>×</mo><mn>13</mn></mrow><annotation encoding="application/x-tex">13\times 13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span></span></span></span> 栅格的中心格子中)</li><li>使用 anchor boxes 预测坐标的同时，<strong>Yolo v2 还对 conditional class probability 的预测机制和空间位置（栅格）做了解耦</strong>。<blockquote><p>就是说，条件类别概率不再与 grid 耦合，因为 v2 中每个 grid 中的 <code>B</code> 个 bbox 都有一个条件类别概率。</p></blockquote></li></ul><p>  在Yolo v1 将输入图像划分为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">S×S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 的栅格，每一个栅格预测 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 个 bounding boxes，以及这些 bounding boxes 的 confidence scores。</p><p>  每一个栅格还要预测 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 个 conditional class probability（条件类别概率）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mo stretchy="false">(</mo><mi>C</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>∣</mi><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it Pr(Classi|Object)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathit">P</span><span class="mord mathit">r</span><span class="mopen">(</span><span class="mord mathit">C</span><span class="mord mathit">l</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord">∣</span><span class="mord mathit">O</span><span class="mord mathit">b</span><span class="mord mathit">j</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mclose">)</span></span></span></span></span>。即在一个栅格包含一个 Object 的前提下，它属于某个类的概率。且每个栅格预测一组 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>个) 类概率，而不考虑框 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的数量。</p><p>  <strong>Yolo v2 不再由栅格去预测条件类别概率，而由 Bounding boxes 去预测</strong>。在 Yolo v1 中每个栅格只有1组条件类别概率，而在 Yolo v2 中，因为每个栅格有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 个 bounding boxes，所以有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 组条件类别概率。</p><p><font color="blue">在 Yolo v1 中输出的维度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>×</mo><mi>S</mi><mo>×</mo><mo stretchy="false">(</mo><mi>B</mi><mo>×</mo><mn mathvariant="italic">5</mn><mo>+</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it S\times S \times (B \times 5 + C )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathit">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathit">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">C</span><span class="mclose">)</span></span></span></span></span>，而 Yolo v2 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>×</mo><mi>S</mi><mo>×</mo><mo stretchy="false">(</mo><mi>B</mi><mo>×</mo><mo stretchy="false">(</mo><mn mathvariant="italic">5</mn><mo>+</mo><mi>C</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it S \times S \times (B \times (5 + C))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathit">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathit">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathit">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">C</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span>。</font>如下图所示。</p><ul><li>使用了Anchor box 后，mAP 从 69.5% 降到了 69.2%，但是 recall 从 81% 增加到了 88%。</li></ul><p><img src="pic1.png" alt="v1 和 v2 输出维度对比"></p><h2 id="dimension-clusters"><a class="markdownIt-Anchor" href="#dimension-clusters"></a> Dimension Clusters</h2><p>  采用 Anchor 机制后遇到两个遇到<font style="color:orange"> <strong>两个问题</strong> </font>，其中<font style="color:blue"> <strong>第一个</strong> </font>为 anchor 尺寸的设置问题。Faster R-CNN 等网络的 anchor 的尺寸是人工选定的，虽然网络可以通过学习来调整预测框的尺寸，但是如果一开始就给一个较合适的 anchor 的话，网络学习起来会更加的容易。Yolo v2 通过 k-means 的方式来学习到 anchor 的尺寸分布情况。对训练集中的所有标定的框，即 GT box，根据他们的 <code>(x,y,w,h)</code> 的值进行 k-means 聚类。如果将用 <code>(x,y,w,h)</code> 来代表一个 GT box，并用 <code>4</code> 维向量的标准欧式距离来作为距离度量的话，大的框可能会比小的框产生更大的误差，比如 <code>(1,1,2,2)</code> 和 <code>(2,2,4,4)</code> 的欧式距离为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mn>10</mn></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">1</span><span class="mord">0</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>，而 <code>(2,2,4,4)</code> 和 <code>(4,4,8,8)</code> 的欧式距离为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><msqrt><mn>10</mn></msqrt></mrow><annotation encoding="application/x-tex">2\sqrt{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord">2</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">1</span><span class="mord">0</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>，而如果采用IoU的度量方式，这两对框的距离相等都是 <code>3/4</code>。而后一种情况所代表的两种框是前一种情况两种框尺寸的两倍。因此，可以看出，采用IoU的方式作为两个框之间的距离度量，可以避免框的尺寸带来的影响。</p><p>  通过聚类，可以将所有的 <code>(x,y,w,h)</code> 聚为 <code>k</code> 类，最后得到 <code>k</code> 个类别中心，这 <code>k</code> 个类别中心就代表 <code>k</code> 个矩形框。论文中使用 Dimension Clusters 的结果如下图所示。<br><img src="pic2.jpg" alt="维度聚类-5类"></p><p><s>最后，聚类出的 <code>K</code> 个 anchor 会被分配到所有的 yolo 层上。不同 yolo 层的尺寸不一样，就是相对于 FPN。</s></p><blockquote><p>yolo v2 只有一个预测层，上面这句话是描述 yolo v3 的。标准的 yolo v3 有 3 个 yolo 层，每一个层 3 个 anchor。<br>AlexeyAB 的 repo 中 yolo v2 有 5 个 anchor，在一个层上。</p></blockquote><p>在网上看到另一种说法</p><blockquote><p>算法过程（k-means）是: 将每个 bbox 的宽和高相对整张图片的比例 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>w</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>h</mi><mi>r</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(w_r,h_r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 进行聚类，得到 k 个 anchor box.<br>算法实现代码可以参考: <a href="https://github.com/PaulChongPeng/darknet/blob/master/tools/k_means_yolo.py" target="_blank" rel="noopener">k_means_yolo.py</a><br>其实根据距离函数就可以看出，k-means 一定是对 <code>(x,y,w,h)</code> 进行聚类的（计算 IoU 需要用到 (x,y) ）。只不过最后不关注聚类中心的 <code>(x,y)</code> ，只关注聚类中心的 <code>(w,h)</code>。上面代码中的操作也证实了这一点。</p></blockquote><p>  与手工挑选的相比，使用 Dimension Clusters 的方法效果更好。对比效果如下图所示。<br><img src="pic3.jpg" alt="使用维度聚类效果对比"><br>其中 Cluster SSE 表示使用 sum squared error 作为度量进行聚类，Cluster IoU 表示使用 IoU 作为度量进行聚类。Anchor boxes 为采取类似 Faster R-CNN 中的方法。</p><h2 id="direct-location-prediction"><a class="markdownIt-Anchor" href="#direct-location-prediction"></a> Direct location prediction</h2><p>  前面提到了两个问题，其中 <font color="blue"><strong>第二个</strong></font> 问题是：模型的不稳定性。不稳定性主要来源于预测框的 <code>(x,y)</code> 坐标。在 RPN 中，网络预测 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">t_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> ，因此，框的中心<code>(x,y)</code>计算方式为:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo>∗</mo><msub><mi>w</mi><mi>a</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>x</mi><mi>a</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mi>y</mi></msub><mo>∗</mo><msub><mi>h</mi><mi>a</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>y</mi><mi>a</mi></msub></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex"> \begin{cases} x = (t_x * w_a) + x_a\\    y = (t_y * h_a) + y_a\\   \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>在原论文中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">x_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">y_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 前使用的是减号，估计是作者的笔误。其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">w_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">h_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为 anchor 的宽和长。如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t_x&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，bounding box 会向右移动 anchor 宽的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">t_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 倍，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t_x&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，bounding box 会向左移动 anchor 宽的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">t_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 倍。由公式可以看出，由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">t_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 没有限制（取值范围没有限制），因此最后得到的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 可以落在图像上的任意一个位置，因此一个 anchor 可能检测一个离自己很远的物体，尽管这个物体应该由离其自身近的 anchor 来检测。</p><p>  <font color="green"> <strong>Yolo v2 不采用预测 offset 的方法 (RPN 的方式)，而是延续 Yolo v1 预测 bbox 相对每个 grid cell 左上角的坐标，确保每个 bbox 的中心落在 grid cell 内</strong></font>。<strong>作者使用 logistic 函数来约束预测值</strong>。</p><p>  对网络的输出 feature map (13×13)，Yolo v2 对每一个 grid cell 预测 5 个 bbox (对应 5 个 anchor)，每个 bbox 由 5 维向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>o</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">( t_x,t_y,t_w,t_h,t_o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 表示。因此，对 feature map 上的每一个位置来说，都会预测出一个 5×5 的向量。(要牢记 feature map 上的每一个位置都对应图像上的一个 grid cell )。如果这个 grid cell 的左上角距离图像左上角偏移为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>c</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c_x,c_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>c</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">c_x, c_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的单位是 1，即 grid 的个数），anchor box 的宽高为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>p</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">p_w, p_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么这个预测的 bounding box 的中心点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b_x, b_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，宽高为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>h</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b_w, b_h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。计算方式如下图:</p><blockquote><p>虚线框为 anchor</p></blockquote><p><img src="pic4.png" alt="一个预测框的计算方式"></p><p><img src="meaning.jpeg" alt="每个参数的意义"></p><p><img src="yolov3.png" alt="yolov3的框的计算方式（与 v2 一样，只是anchor的个数不一样）"></p> <hr><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it \sigma(t_x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 是 bounding box 的中心相对栅格左上角的横坐标，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it \sigma(t_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 是纵坐标。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>o</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it \sigma(t_o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 是 bounding box 的 confidence score。<br>这样，就可以预测出 5 组 bbox.</p><blockquote><p><font color="green"><strong>个人理解</strong>: </font>由于预测的值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>o</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it ( t_x,t_y,t_w,t_h,t_o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 这 5 个数，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>h</mi></msub><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>f</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it (b_x,b_y,b_w,b_h,confidence)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">n</span><span class="mord mathit">f</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mclose">)</span></span></span></span></span> 可以由上面的预测值计算出来，因此不确定最后的 GT 向量是用哪一个来计算 loss。<s>个人猜测是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>h</mi></msub><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>f</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it (b_x,b_y,b_w,b_h,confidence)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">n</span><span class="mord mathit">f</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mclose">)</span></span></span></span></span>。因为这样与 Yolo v1 中的 loss 一致。因此有可能 5 个 GT 都是一样的，就像 Yolo v1 中的一样。</s></p></blockquote><center><font color="orange">---------------------------  损失计算理解更新  -----------------------------</font></center><p>通过阅读损失部分源码，感觉上面的猜测不正确。<strong>应该是使用</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mrow><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>o</mi></msub><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">(\it t_x,t_y,t_w,t_h,t_o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> <strong>这 5 个数进行损失计算的</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/AlexeyAB/darknet/blob/f37ea75b28f01a87f08cb3cdea2f3d58f72224f8/src/region_layer.c#L78</span></span><br><span class="line"><span class="function">box <span class="title">get_region_box</span><span class="params">(<span class="keyword">float</span> *x, <span class="keyword">float</span> *biases, <span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x[index + 0]: tx</span></span><br><span class="line">    <span class="comment">// x[index + 2]: tw</span></span><br><span class="line">    box b;</span><br><span class="line">    <span class="comment">// 这里跟公式的区别就是用 feature map 尺寸进行了归一化，这里 w, h 都是 13</span></span><br><span class="line">    <span class="comment">// 这里预测得到的(x,y,w,h)都是小于一的，是被图像的高宽归一化过的。</span></span><br><span class="line">    b.x = (i + logistic_activate(x[index + <span class="number">0</span>])) / w; </span><br><span class="line">    b.y = (j + logistic_activate(x[index + <span class="number">1</span>])) / h;</span><br><span class="line">    b.w = <span class="built_in">exp</span>(x[index + <span class="number">2</span>]) * biases[<span class="number">2</span>*n];</span><br><span class="line">    b.h = <span class="built_in">exp</span>(x[index + <span class="number">3</span>]) * biases[<span class="number">2</span>*n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(DOABS)&#123;</span><br><span class="line">        b.w = <span class="built_in">exp</span>(x[index + <span class="number">2</span>]) * biases[<span class="number">2</span>*n]   / w;</span><br><span class="line">        b.h = <span class="built_in">exp</span>(x[index + <span class="number">3</span>]) * biases[<span class="number">2</span>*n+<span class="number">1</span>] / h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/AlexeyAB/darknet/blob/f37ea75b28f01a87f08cb3cdea2f3d58f72224f8/src/region_layer.c#L92</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">delta_region_box</span><span class="params">(box truth, <span class="keyword">float</span> *x, <span class="keyword">float</span> *biases, <span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">float</span> *delta, <span class="keyword">float</span> scale, <span class="keyword">int</span> stride)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    box pred = get_region_box(x, biases, n, index, i, j, w, h, stride);</span><br><span class="line">    <span class="keyword">float</span> iou = box_iou(pred, truth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 i,j 是对 cell 的索引，因此 i,j 的范围都是 [0,12] 的整数. w,h 都是 13，delta 存储 loss， x 是预测结果，stride=169.</span></span><br><span class="line">    <span class="comment">// n 是 [0,5] 的整数，是一个确定 cell 内 bbox 的索引。</span></span><br><span class="line">    <span class="keyword">float</span> tx = (truth.x*w - i); <span class="comment">// 这里跟论文中有一点不一样，这里的 tx 其实相当于论文中的$\sigma&#123;t_x&#125;$，这里的 i 就相当于论文中的 cx。ty同理。</span></span><br><span class="line">    <span class="keyword">float</span> ty = (truth.y*h - j);</span><br><span class="line">    <span class="keyword">float</span> tw = <span class="built_in">log</span>(truth.w*w / biases[<span class="number">2</span>*n]); <span class="comment">// biases 数组中存储的是 5 个 anchor 的长宽。</span></span><br><span class="line">    <span class="keyword">float</span> th = <span class="built_in">log</span>(truth.h*h / biases[<span class="number">2</span>*n + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    delta[index + <span class="number">0</span>*stride] = scale * (tx - x[index + <span class="number">0</span>*stride]);</span><br><span class="line">    delta[index + <span class="number">1</span>*stride] = scale * (ty - x[index + <span class="number">1</span>*stride]);</span><br><span class="line">    delta[index + <span class="number">2</span>*stride] = scale * (tw - x[index + <span class="number">2</span>*stride]);</span><br><span class="line">    delta[index + <span class="number">3</span>*stride] = scale * (th - x[index + <span class="number">3</span>*stride]);</span><br><span class="line">    <span class="keyword">return</span> iou;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，计算每一个 bbox 的损失时，是将当前 bbox 所在 cell 对应的 GT box 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it (x,y,w,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">h</span><span class="mclose">)</span></span></span></span></span> 转换成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it (t_x,t_y,t_w,t_h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 后，再跟网络输出的预测值计算损失的。可以看出，针对同一 cell 内不同的 anchor 对应的预测框（一个 anchor 对应一个预测框），<font color="red">它们的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it (t_x,t_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 真实值都是相等的</font>，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">\it i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8498000000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathit">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">j</span></span></span></span></span> 是 cell 的索引，所以对某一 cell 内的预测框来说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">\it i, j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8498000000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathit">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">j</span></span></span></span></span> 都是相等的。但是， n 是 cell 内预测框或者 anchor 的索引，因此对每个预测框来说，<font color="red">他们的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it (t_w,t_h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 的真实值是不等的</font>。（这里没有说一个 cell 是否只计算 responsable 的那个 bbox 的损失，需要查看别的地方的代码）</p><p>Yolo v2 论文没有给出损失函数。网上找到的一个损失函数如下，不知正确与否。<br><img src="pic6.png" alt="Yolo v2 损失函数"></p><h2 id="fine-grained-features"><a class="markdownIt-Anchor" href="#fine-grained-features"></a> Fine-Grained Features</h2><p>  上述网络上的修改使 Yolo v2 最终在 13×13 的特征图上进行预测，虽然这足以胜任大尺度物体的检测，但是用上细粒度特征的话，这可能对小尺度的物体检测有帮助。Faster R-CNN 和 SSD 都在不同层次的特征图上产生区域建议（SSD 直接就可看得出来这一点）（Faster R-CNN 有吗？），获得了多尺度的适应性。这里使用了一种不同的方法，简单添加了一个转移层 ( passthrough layer )，这一层要把浅层特征图 （分辨率为 26×26，是底层分辨率4倍）连接到深层特征图（concat）。</p><blockquote><p>补充：关于 passthrough layer，具体来说就是特征重排（不涉及到参数学习），前面 26×26×512 的特征图使用按行和按列隔行采样的方法，就可以得到4个新的特征图，维度都是 13×13×512，然后做 concat 操作，得到 13×13×2048 的特征图，将其拼接到后面的层，相当于做了一次特征融合，有利于检测小目标。</p></blockquote><h2 id="multi-scale-training"><a class="markdownIt-Anchor" href="#multi-scale-training"></a> Multi-Scale Training</h2><p>  为了使网络具有较强的尺寸鲁棒性，即对不同尺寸的输入都有较好的检测效果。Yolo v2 每迭代几个 epoch 后就会随机选择输入图像的尺寸。由于网络下采样率为32，因此尺寸都是32的倍数，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>320</mn><mo separator="true">,</mo><mn>352</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mn>608</mn></mrow><annotation encoding="application/x-tex">{320,352,...,608}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">3</span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">5</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">8</span></span></span></span></span> 中随机选择。这样，网络不得不学着对不同分辨率的图像都要检测得很好。<br><br></p><h1 id="faster"><a class="markdownIt-Anchor" href="#faster"></a> Faster</h1><p>为了速度，避免使用 VGG-16。提出了 Yolo v2 专用网络 Darknet-19。</p><h2 id="darknet-19"><a class="markdownIt-Anchor" href="#darknet-19"></a> Darknet-19</h2><p>特点：</p><ol><li>主要使用 3×3 卷积核</li><li>每次 Pooling 后，通道数翻倍</li><li>在 3×3 卷积之间使用 1×1 进行特征压缩表示</li></ol><p>网络参数如下图所示:<br><img src="pic5.png" alt="网络参数"><br>  在进行检测时，将Darknet-19的全连接去掉，换上3个 3×3 的卷积层，每一个卷积层通道均为 1024，每一个 3×3 卷积后面都要接上一个 1×1 的卷积。最后的输出尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>13</mn><mo>×</mo><mn>13</mn><mo>×</mo><mo stretchy="false">(</mo><mn>5</mn><mo>×</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>20</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>13</mn><mo>×</mo><mn>13</mn><mo>×</mo><mn>125</mn></mrow><annotation encoding="application/x-tex">13×13×(5×(5+20))=13×13×125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span></span></span></span>。在最后一个 3×3×512 层和倒数第二个卷积层之间加上了 passthrough layer.</p><br><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="yolo-v3-网络结构图"><a class="markdownIt-Anchor" href="#yolo-v3-网络结构图"></a> yolo v3 网络结构图</h2><p><img src="yolov3-structure.png" alt="yolo v3 网络结构图"></p><h2 id="yolo-v3-中的损失源码"><a class="markdownIt-Anchor" href="#yolo-v3-中的损失源码"></a> yolo v3 中的损失源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/AlexeyAB/darknet/blob/f37ea75b28f01a87f08cb3cdea2f3d58f72224f8/src/yolo_layer.c#L116</span></span><br><span class="line"><span class="function">box <span class="title">get_yolo_box</span><span class="params">(<span class="keyword">float</span> *x, <span class="keyword">float</span> *biases, <span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> lw, <span class="keyword">int</span> lh, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> stride)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    box b;</span><br><span class="line">    <span class="comment">// ln - natural logarithm (base = e)</span></span><br><span class="line">    <span class="comment">// x` = t.x * lw - i;   // x = ln(x`/(1-x`))   // x - output of previous conv-layer</span></span><br><span class="line">    <span class="comment">// y` = t.y * lh - i;   // y = ln(y`/(1-y`))   // y - output of previous conv-layer</span></span><br><span class="line">                            <span class="comment">// w = ln(t.w * net.w / anchors_w); // w - output of previous conv-layer</span></span><br><span class="line">                            <span class="comment">// h = ln(t.h * net.h / anchors_h); // h - output of previous conv-layer</span></span><br><span class="line">    b.x = (i + x[index + <span class="number">0</span>*stride]) / lw;</span><br><span class="line">    b.y = (j + x[index + <span class="number">1</span>*stride]) / lh;</span><br><span class="line">    b.w = <span class="built_in">exp</span>(x[index + <span class="number">2</span>*stride]) * biases[<span class="number">2</span>*n]   / w;</span><br><span class="line">    b.h = <span class="built_in">exp</span>(x[index + <span class="number">3</span>*stride]) * biases[<span class="number">2</span>*n+<span class="number">1</span>] / h;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/AlexeyAB/darknet/blob/f37ea75b28f01a87f08cb3cdea2f3d58f72224f8/src/yolo_layer.c#L131</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">delta_yolo_box</span><span class="params">(box truth, <span class="keyword">float</span> *x, <span class="keyword">float</span> *biases, <span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> lw, <span class="keyword">int</span> lh, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">float</span> *delta, <span class="keyword">float</span> scale, <span class="keyword">int</span> stride)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    box pred = get_yolo_box(x, biases, n, index, i, j, lw, lh, w, h, stride);</span><br><span class="line">    <span class="keyword">float</span> iou = box_iou(pred, truth);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> tx = (truth.x*lw - i);</span><br><span class="line">    <span class="keyword">float</span> ty = (truth.y*lh - j);</span><br><span class="line">    <span class="keyword">float</span> tw = <span class="built_in">log</span>(truth.w*w / biases[<span class="number">2</span>*n]);</span><br><span class="line">    <span class="keyword">float</span> th = <span class="built_in">log</span>(truth.h*h / biases[<span class="number">2</span>*n + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    delta[index + <span class="number">0</span>*stride] = scale * (tx - x[index + <span class="number">0</span>*stride]);</span><br><span class="line">    delta[index + <span class="number">1</span>*stride] = scale * (ty - x[index + <span class="number">1</span>*stride]);</span><br><span class="line">    delta[index + <span class="number">2</span>*stride] = scale * (tw - x[index + <span class="number">2</span>*stride]);</span><br><span class="line">    delta[index + <span class="number">3</span>*stride] = scale * (th - x[index + <span class="number">3</span>*stride]);</span><br><span class="line">    <span class="keyword">return</span> iou;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述两个函数来自 yolov3 的 yolo 层代码，其中函数参数 <code>float* x</code> 来自前一个卷积层的输出，<code>shape = (C,H,W)</code>. 其中 <code>(H,W)</code> 表示特征图的宽高，通道 <code>C</code> 依次是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo separator="true">,</mo><mi>o</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo separator="true">,</mo><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mtext> </mtext><mi>c</mi><mi>l</mi><mi>a</mi><mi>s</mi><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it (t_x, t_y, t_w, t_h, objectness, score\ of\ class_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">o</span><span class="mord mathit">b</span><span class="mord mathit">j</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">s</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">r</span><span class="mord mathit">e</span><span class="mspace"> </span><span class="mord mathit">o</span><span class="mord mathit">f</span><span class="mspace"> </span><span class="mord mathit">c</span><span class="mord mathit">l</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.308752em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 利用sigmoid 函数变换到了[0,1] 之间。</p><p>先来看函数 <code>get_yolo_box()</code> 的参数，biases 中存储的是预定以的 anchor box 的宽和高（输入图尺度），<code>(lw,lh)</code> 是 yolo 层输入的特征图尺度，<code>(w,h)</code> 是整个网络输入图尺度，<code>get_yolo_box()</code> 函数利用了论文截图中的公式，而且把结果分别利用特征图宽高和输入图宽高做了归一化。既然这个机制是用来限制回归，避免预测很远的目标，那么这个预测范围是多大呢？<code>(b.x, b.y)</code> 最小是 <code>(i,j)</code>,最大是 <code>(i+1, j+1)</code>，即中心点在特征图上最多移动一个像素（假设输入图下采样 <code>n</code> 得到特征图，特征图中一个像素对应输入图的 <code>n</code> 个像素）<code>(b.w,b.h)</code> 最大是 <code>(2.7 * anchor.w, 2.7*anchor.h)</code>，最小就是 <code>(anchor.w,anchor.h)</code>，这是在输入图尺寸下的值。</p><p><code>delta_yolo_box()</code>负责计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo separator="true">,</mo><mi>o</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it (t_x, t_y, t_w, t_h, objectness)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">o</span><span class="mord mathit">b</span><span class="mord mathit">j</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span></span> 的误差，其参数和 <code>get_yolo_box()</code>类似，truth 是 groundtruth box，也是用输入图宽高归一化后的（中心点，宽高）。但其中的 scale 很奇怪，根据代码<br><code>sclae = 2 - truth.w * truth.h</code>, 其含义还没理解。</p></blockquote><br><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ol><li><a href="https://blog.csdn.net/hrsstudy/article/details/70767950" target="_blank" rel="noopener">https://blog.csdn.net/hrsstudy/article/details/70767950</a></li><li><a href="https://blog.csdn.net/jesse_mx/article/details/53925356" target="_blank" rel="noopener">https://blog.csdn.net/jesse_mx/article/details/53925356</a></li><li><a href="https://github.com/leetenki/YOLOv2/blob/master/YOLOv2.md" target="_blank" rel="noopener">https://github.com/leetenki/YOLOv2/blob/master/YOLOv2.md</a></li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 回归 </tag>
            
            <tag> Yolo </tag>
            
            <tag> yolov3 </tag>
            
            <tag> yolov2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yolo v1 论文理解</title>
      <link href="/2018/04/19/Yolo/"/>
      <url>/2018/04/19/Yolo/</url>
      
        <content type="html"><![CDATA[<p>本文针对 Yolo v1 的一些处理方法和细节给出了自己的理解。不一定正确，如有错误请指正。</p><a id="more"></a><h1 id="yolo-整体思想"><a class="markdownIt-Anchor" href="#yolo-整体思想"></a> Yolo 整体思想</h1><p>  YOLO 将输入图像分成 <code>SxS</code> 个格子，每个格子负责检测‘落入’该格子的物体。若某个物体的中心位置的坐标落入到某个格子，那么这个格子就负责检测出这个物体。如下图所示，图中物体狗的中心点（红色原点）落入第5行、第2列的格子内，所以这个格子负责预测图像中的物体-狗。<br><img src="pic1.jpg" alt="yolo 检测思想"><br>  </p><p style="color:green">  在计算 loss 时，此格子预测得到的 B 个 bounding box 分别与‘狗’这个物体的 gt box（即图中的红色框）计算 IoU，用 IoU 较大的 bounding box 来计算 localization 损失（称这个 bnd box 负责检测这个物体 --‘狗’），剩下的 bnd box 不参与计算。这边所讨论的是有物体的格子计算损失的方式，没有物体的格子的损失计算与之稍有不同。</p> 具体见损失函数。<p></p><h1 id="yolo输出特征图"><a class="markdownIt-Anchor" href="#yolo输出特征图"></a> Yolo输出特征图</h1><p>  根据论文中的参数，Yolo 网络的输出为 7×7×30，每一个格子对一个一个 30 维的向量。这个 30 维向量的含义如下图所示。<br><img src="pic2.gif" alt="30维向量含义"><br>  如图所示，<code>x,y</code> 分别是预测出的 bnd box 的中心相对于当前格子的边界的坐标值。其被格子的尺寸归一化到了[0,1]。也就是说，<strong>预测出的 bnd box 的中心是在格子内部的</strong>。<code>w,h</code> 是预测出的 bnd box 的长宽，其被图像尺寸归一化到了[0,1]。也就是说，预测出的 bnd box 的尺寸是不大于图像尺寸的任意尺寸。confidence 就是预测出的 bnd box 和 gt box的 IoU 值。</p><h1 id="损失函数"><a class="markdownIt-Anchor" href="#损失函数"></a> 损失函数</h1><p>网络的损失函数定义如下图：<br><img src="pic3.png" alt="网络损失函数"></p><p>从图中可以看出，损失函数主要分为【坐标预测】【confidence】【类别预测】三个部分。是计算出每一个格子的损失并将所有格子的损失加和作为最后的损失值。由于格子主要分为 【有物体】和【无物体】两种，因此对不同类型的格子，损失的计算方式不完全一样。对于有物体的格子，由于每个格子预测了两个bnd box，因此计算这两个 bnd box 和当前格子对应物体的 GT box 的 IoU，用 IoU 值大的 bnd box 来负责这个 GT box 的预测（也就是回归），也就是说，只计算 IoU 较大的 bnd box 的损失，不计算其他 bnd box 的损失。 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>1</mn><mi>i</mi><mrow><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\mathbb{1}^{obj}_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2438799999999999em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span></span> 表示第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个格子中是否有物体出现，若有，则为1，否则为0。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>1</mn><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\mathbb{1}^{obj}_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.379988em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个格子中的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个 bnd box 是否负责当前格子所对应 GT box 的预测。个人理解，当格子中没有物体，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>1</mn><mi>i</mi><mrow><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathbb{1}^{obj}_i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2438799999999999em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，对任何<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>1</mn><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\mathbb{1}^{obj}_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.379988em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span>都为 0。因此，对于没有物体的格子来说，此格子对损失函数的贡献只有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mrow><mi>n</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msub><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><msup><mi>S</mi><mn>2</mn></msup></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>B</mi></munderover><msubsup><mn>1</mn><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mi>n</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup><mo stretchy="false">(</mo><msub><mi>C</mi><mi>i</mi></msub><mo>−</mo><msub><mover accent="true"><mi>C</mi><mo>^</mo></mover><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\lambda_{noobj}\sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{1}^{noobj}_{ij} (C_i-\hat C_i)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.387702em;vertical-align:-1.4137769999999998em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9739250000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.19677em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>这一项，而其他的如分类误差和定位误差都为0。</p><h1 id="ground-truth设定"><a class="markdownIt-Anchor" href="#ground-truth设定"></a> Ground Truth设定</h1><p>Yolo 的网络输出为 7×7×30 的 feature map，为了能够构造损失函数，因此需要一个同样尺寸的 Ground Truth。针对每一个格子，它的 Ground Truth 也为一个 30 维的向量。其中 20 维为这个格子所对应的物体的类别，个人理解为 one hot。剩下10维为两个 bnd box 的 GT ，两个 bnd box 的 GT 值相同，即两个相同的 5 维向量。5 维向量分别为当前格子对应的物体的 <code>w,h,x,y,confidence</code>。对于有物体的格子，<code>w,h,x,y</code> 为格子对应物体的 GT box 的这四项参数，<code>confidence</code> 项为 <code>1</code>。对于没有物体的格子, <code>confidence</code> 项为 <code>0</code>，且在计算损失时，不计算当前格子预测出的两个 bnd box 的定位损失（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>1</mn><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathbb{1}^{obj}_{ij}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.379988em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>）和分类损失（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>1</mn><mi>i</mi><mrow><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathbb{1}^{obj}_{i}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2438799999999999em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>），因此没有物体的格子的 Ground Truth 中的 w,h,x,y 并不重要，因为它们不参与计算。这样，如上节所讲，没有物体的格子对损失函数的贡献只有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mrow><mi>n</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msub><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><msup><mi>S</mi><mn>2</mn></msup></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>B</mi></munderover><msubsup><mn>1</mn><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mi>n</mi><mi>o</mi><mi>o</mi><mi>b</mi><mi>j</mi></mrow></msubsup><mo stretchy="false">(</mo><msub><mi>C</mi><mi>i</mi></msub><mo>−</mo><msub><mover accent="true"><mi>C</mi><mo>^</mo></mover><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\lambda_{noobj} \sum_{i=0}^{S^2} \sum_{j=0}^{B} \mathbb{1}^{noobj}_{ij} (C_i-\hat C_i)^2 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.387702em;vertical-align:-1.4137769999999998em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9739250000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord">1</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9670159999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.19677em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9467699999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>这一项。</p><h1 id="inference流程"><a class="markdownIt-Anchor" href="#inference流程"></a> Inference流程</h1><p>  前面讲到，每一个格子最后会得到一个 30 维的向量，其中 10 维分别为两个 bnd box 预测的 w,h,x,y,confidence 值，20 维为此格子的条件类别概率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mo stretchy="false">(</mo><mi>C</mi><mi>l</mi><mi>a</mi><mi>s</mi><msub><mi>s</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Pr(Class_i|Object)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>。将两个 bnd box 预测的 confidence 分别和这个条件类别概率相乘，则得到两个 20 维的向量，称作 confidence score，它既包含了 bounding box 中预测的 class 的 probability 信息，也反映了 bounding box 是否含有 Object 和 bounding box 坐标的准确度。这样，对每一个格子，都得到两个 20 维的 score 向量。如下图。<br><img src="pic4.gif" alt="score向量"></p><blockquote><p><strong>这里我有一个疑问:</strong> 前面的 score 向量是最后用来比较的标准，即判断每个 bnd box 好坏的标准，但是这里并没有用到 w,h,x,y 四个预测坐标来计算与 GT box 的 IoU。我的解释是：在训练阶段，w,h,x,y 和 confidence 是绑定的，即预测的 bnd box 的 w,h,x,y 向真实值靠近(针对有物体的格子)，confidence 向 1 靠近，因此，当 confidence 较接近 1 时，说明 w,h,x,y 四个值也接近真实值。这样在预测阶段，就不用把 w,h,x,y 拿出来计算，直接拿预测的 confidence 计算，就可以表达 bnd box 是否很好地预测了 GT box 的坐标。</p></blockquote><h2 id="得到score向量后的流程"><a class="markdownIt-Anchor" href="#得到score向量后的流程"></a> 得到score向量后的流程</h2><p>  在得到每个 bnd box 的 score 向量后（论文中共有 2×7×7=98 个），将其看作一个 20×98 的矩阵。其中每一列为每个 bnd box 的 score 向量，每一行为每个 bnd box 对某个类别的预测 score。针对此矩阵，逐行，即逐类别进行操作。</p><ul><li>对某一行（假设第一行，即第一类）的 98 个 score 值进行阈值化，将小于固定阈值的 score 值置零。</li><li>根据此行阈值化后的 score 值的大小，对每个 bnd box 的 score 向量（列与列进行排序，不是列的元素排序）进行降序排序。</li><li>降序排序后，根据此行的 98 个 score 值以及预测出的 98 对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(w,h,x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 进行 NMS，将此行部分 bnd box 的 score 值置零 (见 NMS 的具体方式图)。</li><li>对每一行（即每个类别）重复上述三个步骤，这样就得到一个全新的 20×98 的矩阵，其中有大量 0 元素。</li><li>对新矩阵的每一列（每一个 bnd box），找出其 score 值最大的类别，若其最大 score 值大于 0，则用此类别对应的颜色画出当前 bnd box 预测的框。</li></ul><p>其中，阈值化-降序排序-NMS 流程如下图所示：<br><img src="pic5.gif" alt="阈值化-降序排序-NMS"><br>NMS 的具体方式如下图所示：<br><img src="pic6.gif" alt="NMS 流程"><br>从新矩阵中画出检测框的过程如下图所示：<br><img src="pic7.gif" alt="画检测框"></p><h1 id="yolo-的缺点"><a class="markdownIt-Anchor" href="#yolo-的缺点"></a> Yolo 的缺点</h1><ul><li>localization error 较大，定位不准确</li><li>recall rate 较低 (由于每个格子内只预测 B 个 bnd box，因此当有多个物体的中心落入同一个格子时，Yolo 是无法检出的，因此 Yolo 对成群出现的小物体检测效果很差)</li></ul><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://blog.csdn.net/hrsstudy/article/details/70305791" target="_blank" rel="noopener">https://blog.csdn.net/hrsstudy/article/details/70305791</a><br><a href="https://arxiv.org/abs/1506.02640" target="_blank" rel="noopener">论文原文 https://arxiv.org/abs/1506.02640</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 回归 </tag>
            
            <tag> Yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Node.js 生成随机数的服务</title>
      <link href="/2018/04/16/node-random-number-service/"/>
      <url>/2018/04/16/node-random-number-service/</url>
      
        <content type="html"><![CDATA[<p>使用 Node.js 写一个服务器程序，用来返回一个不大于给定数的随机数。</p><a id="more"></a><p>程序代码为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// these modules need to be imported in order to use them.</span></span><br><span class="line"><span class="comment">// Node has several modules.  They are like any #include</span></span><br><span class="line"><span class="comment">// or import statement in other languages</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The most important line in any Node file.  This function</span></span><br><span class="line"><span class="comment">// does the actual process of creating the server.  Technically,</span></span><br><span class="line"><span class="comment">// Node tells the underlying operating system that whenever a</span></span><br><span class="line"><span class="comment">// connection is made, this particular callback function should be</span></span><br><span class="line"><span class="comment">// executed.  Since we're creating a web service with REST API,</span></span><br><span class="line"><span class="comment">// we want an HTTP server, which requires the http variable</span></span><br><span class="line"><span class="comment">// we created in the lines above.</span></span><br><span class="line"><span class="comment">// Finally, you can see that the callback method receives a 'request'</span></span><br><span class="line"><span class="comment">// and 'response' object automatically.  This should be familiar</span></span><br><span class="line"><span class="comment">// to any PHP or Java programmer.</span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The response needs to handle all the headers, and the return codes</span></span><br><span class="line">   <span class="comment">// These types of things are handled automatically in server programs</span></span><br><span class="line">   <span class="comment">// like Apache and Tomcat, but Node requires everything to be done yourself</span></span><br><span class="line">   response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Here is some unique-looking code.  This is how Node retrives</span></span><br><span class="line">   <span class="comment">// parameters passed in from client requests.  The url module</span></span><br><span class="line">   <span class="comment">// handles all these functions.  The parse function</span></span><br><span class="line">   <span class="comment">// deconstructs the URL, and places the query key-values in the</span></span><br><span class="line">   <span class="comment">// query object.  We can find the value for the "number" key</span></span><br><span class="line">   <span class="comment">// by referencing it directly - the beauty of JavaScript.</span></span><br><span class="line">   <span class="keyword">var</span> params = url.parse(request.url, <span class="literal">true</span>).query;</span><br><span class="line">   <span class="keyword">var</span> input = params.number;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// These are the generic JavaScript methods that will create</span></span><br><span class="line">   <span class="comment">// our random number that gets passed back to the caller</span></span><br><span class="line">   <span class="keyword">var</span> numInput = <span class="keyword">new</span> <span class="built_in">Number</span>(input);</span><br><span class="line">   <span class="keyword">var</span> numOutput = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="built_in">Math</span>.random() * numInput).toFixed(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Write the random number to response</span></span><br><span class="line">   response.write(numOutput);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Node requires us to explicitly end this connection.  This is because</span></span><br><span class="line">   <span class="comment">// Node allows you to keep a connection open and pass data back and forth,</span></span><br><span class="line">   <span class="comment">// though that advanced topic isn't discussed in this article.</span></span><br><span class="line">   response.end();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// When we create the server, we have to explicitly connect the HTTP server to</span></span><br><span class="line"> <span class="comment">// a port.  Standard HTTP port is 80, so we'll connect it to that one.</span></span><br><span class="line">&#125;).listen(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output a String to the console once the server starts up, letting us know everything</span></span><br><span class="line"><span class="comment">// starts up correctly</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Random Number Generator Running..."</span>);</span><br></pre></td></tr></table></figure><p>在命令行执行此js脚本</p><figure class="highlight plain"><figcaption><span>lang:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node xxx.js</span><br></pre></td></tr></table></figure><p>然后，在客户端，在地址栏输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:80?number=46</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何截取网页长屏</title>
      <link href="/2018/04/16/Webpage2Picture/"/>
      <url>/2018/04/16/Webpage2Picture/</url>
      
        <content type="html"><![CDATA[<p>本文主要展示如何通过使用 nodejs 进行网页截屏，并截取整个网页。</p><a id="more"></a><p> <br>js 部分代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> page = <span class="built_in">require</span>(<span class="string">'webpage'</span>).create();</span><br><span class="line">page.open(<span class="string">'http://www.guancha.cn/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"status:"</span> + status);</span><br><span class="line">  <span class="keyword">if</span> (status == <span class="string">"success"</span>) &#123;</span><br><span class="line">    page.render(<span class="string">"example.png"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  phantom.exit();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> <br>这对一般的网站来说能得到很好的效果。但是存在一个问题，当截取如优酷等视频网站时，由于网页加载时间较长，因此容易在网页还蛮完全渲染完全时进行截图，造成图中部分图片缺失。</p><img src="/2018/04/16/Webpage2Picture/failed.png" title="failed"><a href="https://www.v2ex.com/t/67689" target="_blank" rel="noopener">这篇文章</a>也遇到了同样的问题，并给出了解决方案。<p> <br>我尝试了使用sleep方式解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> t = <span class="built_in">Date</span>.now(); <span class="built_in">Date</span>.now() - t &lt;= d; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start_time = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="keyword">var</span> page = <span class="built_in">require</span>(<span class="string">'webpage'</span>).create();</span><br><span class="line"></span><br><span class="line">page.open(<span class="string">'http://www.youku.com/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"status:"</span> + status);</span><br><span class="line">  <span class="keyword">if</span> (status == <span class="string">"success"</span>) &#123;</span><br><span class="line">    sleep(<span class="number">10000</span>);</span><br><span class="line">    page.render(<span class="string">"example.png"</span>);</span><br><span class="line">    <span class="keyword">var</span> end_time = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">var</span> used_time = (end_time - start_time) / <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Used time is: "</span> + used_time + <span class="string">' s'</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  phantom.exit();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是效果并不好。</p><p> <br>因此，又尝试了获取页面 img 元素的方式，判断某个图片是否加载完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> stat = page.evaluate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> laifeng = <span class="built_in">document</span>.getElementById(<span class="string">"m_250037"</span>);</span><br><span class="line">    <span class="keyword">var</span> pict = laifeng.getElementsByTagName(<span class="string">"img"</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> pict.complete;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'complete---'</span> + stat);</span><br><span class="line">  <span class="keyword">return</span> stat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitForReady</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!check()) &#123;</span><br><span class="line">    setTimeout(waitForReady(), <span class="number">10</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'element showed'</span>);</span><br><span class="line">    page.render(<span class="string">"example.png"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> page = <span class="built_in">require</span>(<span class="string">'webpage'</span>).create();</span><br><span class="line">page.open(<span class="string">'http://www.youku.com/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"status:"</span> + status);</span><br><span class="line">  <span class="keyword">if</span> (status == <span class="string">"success"</span>) &#123;</span><br><span class="line">    waitForReady();</span><br><span class="line">  &#125;</span><br><span class="line">  phantom.exit();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是并没有达到想要的效果，虽然能够获取到元素的完成状态，但实际上截图时图片并没有显示出来。</p><img src="/2018/04/16/Webpage2Picture/example.png" title="bad result"><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 网页 </tag>
            
            <tag> 截屏 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
