<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>taosean&#39;s 学习之旅</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://taosean.github.io/"/>
  <updated>2021-04-20T07:58:59.359Z</updated>
  <id>https://taosean.github.io/</id>
  
  <author>
    <name>taosean</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【转载】矩阵之芯 SVD：奇异值分解及其几何解释</title>
    <link href="https://taosean.github.io//2021/04/19/SVD/"/>
    <id>https://taosean.github.io//2021/04/19/SVD/</id>
    <published>2021-04-19T08:21:35.000Z</published>
    <updated>2021-04-20T07:58:59.359Z</updated>
    
    <content type="html"><![CDATA[<p>在网上看到一篇非常好的关于 SVD 的文章，转载在这里。并附上自己的理解。</p><a id="more"></a><p>原文来源: <a href="https://my.oschina.net/mathinside/blog/4760837" target="_blank" rel="noopener"><font color="purple">矩阵之芯 SVD: 奇异值分解及其几何解释</font></a></p><p><img src="svd1.jpeg" alt="svd"></p><p><img src="svd2.jpeg" alt="svd"></p><p><img src="svd3.jpeg" alt="svd"></p><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><p><a href="https://www.cnblogs.com/qizhou/p/13864589.html" target="_blank" rel="noopener">实对称矩阵的特征值一定为实数证明</a></p><p><a href="https://my.oschina.net/JiamingMai/blog/366093" target="_blank" rel="noopener">证明：实对称矩阵中，属于不同特征值的特征向量相互正交</a><br>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">p</mi></mrow><mo>=</mo><msub><mi>λ</mi><mn>1</mn></msub><mi mathvariant="bold-italic">p</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{Ap}=\lambda_1\boldsymbol{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8805499999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol">p</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">q</mi></mrow><mo>=</mo><msub><mi>λ</mi><mn>2</mn></msub><mi mathvariant="bold-italic">q</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{Aq}=\lambda_2\boldsymbol{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8805499999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">A</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span></span></span></span> 为实对称矩阵，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\lambda_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\lambda_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">A</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span></span></span></span> 的不同的特征值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">p</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">q</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span></span></span> 分别是对应的特征向量。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mo stretchy="false">(</mo><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">q</mi></mrow><mo stretchy="false">)</mo><mo>=</mo><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>2</mn></msub><mi mathvariant="bold-italic">q</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>λ</mi><mn>2</mn></msub><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">q</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">\boldsymbol{p}^T(\boldsymbol{Aq})=\boldsymbol{p}^T(\lambda_2\boldsymbol{q})=\lambda_2\boldsymbol{p}^T\boldsymbol{q}  \tag{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0857709999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span><span class="tag"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi><mo stretchy="false">)</mo><mi mathvariant="bold-italic">q</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><msup><mi mathvariant="bold-italic">A</mi><mi>T</mi></msup><mo stretchy="false">)</mo><mi mathvariant="bold-italic">q</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>1</mn></msub><mi mathvariant="bold-italic">p</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mi mathvariant="bold-italic">q</mi><mo>=</mo><msub><mi>λ</mi><mn>1</mn></msub><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">q</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(2)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">(\boldsymbol{p}^T\boldsymbol{A})\boldsymbol{q}=(\boldsymbol{p}^T\boldsymbol{A}^T)\boldsymbol{q}=(\lambda_1\boldsymbol{p})^T\boldsymbol{q} =\lambda_1\boldsymbol{p}^T\boldsymbol{q} \tag{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.167341em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.917341em;"><span style="top:-3.1390100000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0857709999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span><span class="tag"><span class="strut" style="height:1.167341em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p><p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mo stretchy="false">(</mo><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">q</mi></mrow><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi><mo stretchy="false">)</mo><mi mathvariant="bold-italic">q</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{p}^T(\boldsymbol{Aq})=(\boldsymbol{p}^T\boldsymbol{A})\boldsymbol{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span></span></span>, 由 (1)-(2)得：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mo stretchy="false">(</mo><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">q</mi></mrow><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi><mo stretchy="false">)</mo><mi mathvariant="bold-italic">q</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>1</mn></msub><mo>−</mo><msub><mi>λ</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mrow><msup><mi mathvariant="bold-italic">p</mi><mi mathvariant="bold-italic">T</mi></msup><mi mathvariant="bold-italic">q</mi></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{p}^T(\boldsymbol{Aq})-(\boldsymbol{p}^T\boldsymbol{A})\boldsymbol{q}=(\lambda_1-\lambda_2)\boldsymbol{p^Tq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1432769999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8932769999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight" style="margin-right:0.15972em;">T</span></span></span></span></span></span></span></span><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span></span></span></span></p><p>即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>=</mo><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>1</mn></msub><mo>−</mo><msub><mi>λ</mi><mn>2</mn></msub><mo stretchy="false">)</mo><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">q</mi></mrow><annotation encoding="application/x-tex">0=(\lambda_1-\lambda_2)\boldsymbol{p}^T\boldsymbol{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span></span></span><br>又由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mn>1</mn></msub><mi mathvariant="normal">≠</mi><msub><mi>λ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\lambda_1\neq\lambda_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="bold-italic">p</mi><mi>T</mi></msup><mi mathvariant="bold-italic">q</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\boldsymbol{p}^T\boldsymbol{q}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi mathvariant="bold-italic">p</mi><mo separator="true">,</mo><mi mathvariant="bold-italic">q</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&lt;\boldsymbol{p}, \boldsymbol{q}&gt;=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 从而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">p</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">q</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">q</span></span></span></span></span></span> 相互正交。</p><p><a href="https://blog.csdn.net/itnerd/article/details/83032543" target="_blank" rel="noopener">所有特征值大于零的矩阵一定是正定阵吗？</a></p><p><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="bold-italic">A</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{A}^T\boldsymbol{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.917341em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.917341em;"><span style="top:-3.1390100000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span></span></span></span>  是对称且非负定的。</strong><br>证明：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="bold-italic">A</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mo>=</mo><msup><mi mathvariant="bold-italic">A</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi></mrow><annotation encoding="application/x-tex">(\boldsymbol{A}^T\boldsymbol{A})^T=\boldsymbol{A}^T\boldsymbol{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.167341em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.917341em;"><span style="top:-3.1390100000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.917341em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.917341em;"><span style="top:-3.1390100000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span></span></span></span>, 因此对称。<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="bold-italic">x</mi><mi>T</mi></msup><mo stretchy="false">(</mo><msup><mi mathvariant="bold-italic">A</mi><mi>T</mi></msup><mi mathvariant="bold-italic">A</mi><mo stretchy="false">)</mo><mi mathvariant="bold-italic">x</mi><mo>=</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">x</mi></mrow><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">x</mi></mrow><mo>=</mo><mi mathvariant="normal">∥</mi><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">x</mi></mrow><mi mathvariant="normal">∥</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\boldsymbol{x}^T(\boldsymbol{A}^T\boldsymbol{A})\boldsymbol{x}=(\boldsymbol{Ax})^T\boldsymbol{Ax}=\Vert \boldsymbol{Ax} \Vert &gt;= 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.167341em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.917341em;"><span style="top:-3.1390100000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol">x</span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol">x</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span><span class="mord boldsymbol">x</span></span></span><span class="mord">∥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br><a href="https://www.3rxing.org/question/3b7705af11769615154.html" target="_blank" rel="noopener">矩阵乘矩阵的转置一定正定吗</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网上看到一篇非常好的关于 SVD 的文章，转载在这里。并附上自己的理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="矩阵分解" scheme="https://taosean.github.io/tags/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/"/>
    
      <category term="奇异矩阵" scheme="https://taosean.github.io/tags/%E5%A5%87%E5%BC%82%E7%9F%A9%E9%98%B5/"/>
    
      <category term="特征值" scheme="https://taosean.github.io/tags/%E7%89%B9%E5%BE%81%E5%80%BC/"/>
    
      <category term="特征向量" scheme="https://taosean.github.io/tags/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>多元高斯分布推导及二维高斯分布的图像</title>
    <link href="https://taosean.github.io//2021/04/15/Gaussian-Distribution/"/>
    <id>https://taosean.github.io//2021/04/15/Gaussian-Distribution/</id>
    <published>2021-04-15T08:08:15.000Z</published>
    <updated>2021-04-19T02:54:31.997Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要转载了关于多元高斯分布概率密度函数的推导过程，并画出了二维高斯分布的图像，以便得到更直观的理解。</p><a id="more"></a><p>在知乎上看到两篇文章，分别是<br><a href="https://zhuanlan.zhihu.com/p/58987388" target="_blank" rel="noopener"><font color="blue">多元高斯分布完全解析</font></a>, 记为 <strong>文章一</strong> ,    <a href="https://zhuanlan.zhihu.com/p/36522776" target="_blank" rel="noopener"><font color="blue">从零开始推导多元高斯分布</font></a>，记为 <strong>文章二</strong></p><h2 id="font-colorpurple文章一的流程大致为font"><a class="markdownIt-Anchor" href="#font-colorpurple文章一的流程大致为font"></a> <font color="purple"><strong>文章一的流程大致为</strong></font></h2><ul><li><p>给出一维高斯分布及其概率密度函数, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mi>μ</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \mathcal{N}(\mu, \sigma^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p></li><li><p>对随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 进行标准化，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac></mrow><annotation encoding="application/x-tex">Z=\frac{X-\mu}{\sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.269439em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.924439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 进行换元，得到的随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> 服从一元标准高斯分布，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z \sim \mathcal{N}(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><blockquote><p><strong>随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 标准化的过程, 实际上的消除量纲影响和分布差异的过程. 通过将随机变量的值减去其均值再除以标准差, 使得随机变量与其均值的差距可以用若干个标准差来衡量, 从而实现了不同随机变量与其对应均值的差距, 可以以一种相对的距离来进行比较.</strong></p></blockquote></li><li><p>将一元高斯分布和多元高斯分布联系起来。如果随机<strong>向量</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">[</mo><msub><mi>Z</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>Z</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\vec{Z}=[Z_1,\cdots, Z_n]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 中每个随机<strong>变量</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 都服从标准高斯分布且两两彼此独立，则随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">[</mo><msub><mi>Z</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>Z</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\vec{Z}=[Z_1,\cdots, Z_n]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 的联合概率密度函数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>z</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>⋯</mo><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(z_1,\cdots,z_n) = p(z_1)\cdots p(z_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，称之为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mn>0</mn><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="bold-italic">I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z} \sim \mathcal{N}(\vec{0}, \boldsymbol{I})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.17744em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.92744em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.21344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="mclose">)</span></span></span></span>. 即随机向量服从均值为零向量, 协方差矩阵为单位矩阵的高斯分布。</p></li><li><p>对于普通的随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{X} \sim \mathcal{N}(\vec{\mu}, \Sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mclose">)</span></span></span></span> , 即其每个随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><msub><mi>μ</mi><mi>i</mi></msub><mo separator="true">,</mo><msubsup><mi>σ</mi><mi>i</mi><mn>2</mn></msubsup><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_i \sim \mathcal{N}(\mu_i, \sigma^2_i)(i=1,\cdots,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.072772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_i,X_j(i,j=1,\cdots,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 彼此不独立的情况下 <strong>我们通过线性变换, 使得随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\vec{X}=[X_1,\cdots,X_n]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 中的每个随机变量彼此独立, 则我们也可以通过独立随机变量概率密度函数之间的关系求出其联合概率密度函数</strong></p></li><li><p>引入<strong>定理 1</strong>，将随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{X} \sim \mathcal{N}(\vec{\mu}, \Sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mclose">)</span></span></span></span> 变换为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mn>0</mn><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="bold-italic">I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z} \sim \mathcal{N}(\vec{0}, \boldsymbol{I})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.17744em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.92744em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.21344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="mclose">)</span></span></span></span>. 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><msup><mi>B</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z}=B^{-1}(\vec{X}-\vec{\mu})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.21633em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. 经过推导，得到最终的联合概率密度函数</p></li></ul><p><img src="therom.png" alt="定理1"></p><p><img src="eq0.svg" alt="联合概率密度函数"></p><h2 id="font-colorpurple文章二的流程大致为font"><a class="markdownIt-Anchor" href="#font-colorpurple文章二的流程大致为font"></a> <font color="purple"><strong>文章二的流程大致为</strong></font></h2><ul><li>给出一元标准高斯分布</li><li>给出均值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>，方差为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sigma^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 情况下，使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac></mrow><annotation encoding="application/x-tex">z=\frac{x-\mu}{\sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.199439em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 进行标准化。<strong>标准化的意义在于将数据点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 到均值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span> 的距离转化为数据点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 到均值的距离等于多少个总体的标准差 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span> ，这样，就消除了数据分布差异和量纲对概率计算的影响</strong>，此时的概率密度函数为：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>σ</mi><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><msup><mi>z</mi><mn>2</mn></msup><mn>2</mn></mfrac></mrow></msup><mo>=</mo><mfrac><mn>1</mn><mrow><mi>σ</mi><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">f(x)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{z^2}{2}}=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25144em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.20602em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1328857142857145em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.04844em;"><span style="top:-3.04844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25909em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.32909em;"><span style="top:-3.4534200000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.250957142857143em;"><span style="top:-2.5061857142857145em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9384399999999999em;"><span style="top:-2.93844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.5020714285714285em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.04844em;"><span style="top:-3.04844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49381428571428565em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>可见，<strong>高斯分布的概率密度计算核心在于计算数据点到中心的距离，并且除以标准差将这个绝对距离转化为相对距离，然后通过距离平方的指数衰减计算概率密度。</strong></p><ul><li>介绍各维度<strong>不相关</strong>的多元正态分布的概率密度函数的推导。</li><li>对各维度<strong>相关</strong>的多元正态分布，记为随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>，先将数据通过投影到正交单位向量上，进行去相关，投影过程用矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> 表示。（其实也可以理解为旋转，通过旋转，将随机向量的每个维度变得不相关）。记投影或旋转后的得到的随机向量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>。这时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 虽然已经去相关，但是还没有进行标准化，因此，对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 进行标准化，以得到随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span>。三者之间的关系如下</li><li></li></ul><p><img src="eq1.svg" alt="随机向量 X,Y,Z 之间的关系"></p><p>从公式可以看出，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> 是由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 减去均值后的向量，先通过矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>U</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">U^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 进行投影/旋转变换，去除相关性，然后通过矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 进行缩放变换得到的。</p><h2 id="font-colorpurple总结font"><a class="markdownIt-Anchor" href="#font-colorpurple总结font"></a> <font color="purple"><strong>总结</strong></font></h2><p>在文章一中，根据定理一得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><msup><mi>B</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z}=B^{-1}(\vec{X}-\vec{\mu})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.21633em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其具体操作了<br><img src="eq2.svg" alt="具体操作"></p><p>文章二中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mi>D</mi><msup><mi>U</mi><mi>T</mi></msup><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><msub><mi>μ</mi><mi>X</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z=DU^T(X-\mu_X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 为缩放矩阵，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>U</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">U^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 为旋转/投影矩阵</p><p>可以看出，<strong>文章一中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>B</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">B^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 等价于文章二中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><msup><mi>U</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">DU^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></strong></p><p>在文章一中，存在一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 空间和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> 空间的比例变化，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>z</mi><mn>1</mn></msub><mo>⋯</mo><mi>d</mi><msub><mi>z</mi><mi>n</mi></msub><mo>=</mo><msup><mrow><mo fence="true">∣</mo><mi>B</mi><msup><mi>B</mi><mi>T</mi></msup><mo fence="true">∣</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mi>d</mi><msub><mi>x</mi><mi>i</mi></msub><mo>⋯</mo><mi>d</mi><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">dz_1\cdots dz_n=\left|BB^T\right|^{-\frac{1}{2}}dx_i\cdots dx_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.55592em;vertical-align:-0.35000999999999993em;"></span><span class="minner"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.86199em;"><span style="top:-2.2559899999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86199em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000999999999993em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.86199em;"><span style="top:-2.2559899999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86199em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000999999999993em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.20591em;"><span style="top:-3.6148900000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (<strong><a href="https://my.oschina.net/mathinside/blog/4702928" target="_blank" rel="noopener">雅可比行列式</a>，目前还没搞懂，需要了解一下</strong>), 而又因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><msup><mi>B</mi><mi>T</mi></msup><mo>=</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">BB^T=\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>，因此最后的联合概率密度函数有一项为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><msup><mrow><mo fence="true">∣</mo><mi mathvariant="normal">Σ</mi><mo fence="true">∣</mo></mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\left|\Sigma\right|^{\frac{1}{2}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.687253em;vertical-align:-0.8421449999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.332855em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span><span class="mord mtight">Σ</span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.224492857142857em;"><span style="top:-3.48775em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size1 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03144em;"><span style="top:-2.468em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.387em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.532em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size1 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8421449999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。具体推导见文章一公式(9)-(14)</p><p>可以发现，两篇文章都是通过将随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim \mathcal{N}(\vec{\mu}, \Sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mclose">)</span></span></span></span> 变换到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mn>0</mn><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="bold-italic">I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z \sim \mathcal{N}(\vec{0}, \boldsymbol{I})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.17744em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.92744em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.21344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="mclose">)</span></span></span></span> 来求随机变量的联合概率分布的。不同的是，文章一直接通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>B</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">B^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 来表示这种变换，而文章二中则通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>U</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">U^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 两个变换以及引入中间随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 来达到同样的效果。</p><p>在文章一中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mi>B</mi><msup><mi>B</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\Sigma=BB^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>, 且由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> 是实对称矩阵，因此可以正交对角化, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mi>Q</mi><mi mathvariant="normal">Λ</mi><msup><mi>Q</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\Sigma=Q \Lambda Q^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord">Λ</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>。根据定理1，我们有</p><p><img src="eq3.svg" alt="Z^T·Z推导(用B表示)"></p><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mi>Q</mi><mi mathvariant="normal">Λ</mi><msup><mi>Q</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\Sigma=Q \Lambda Q^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord">Λ</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 代入，得到</p><p><img src="eq4.svg" alt="推导(用Q表示)"></p><p><strong>问：这里为什么要计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mi>T</mi></msup><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{Z}^T\vec{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 呢？</strong><br>答：这是因为，由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 变换得到的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mn>0</mn><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="bold-italic">I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z} \sim \mathcal{N}(\vec{0},\boldsymbol{I})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.17744em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.92744em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.21344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.07778em;">I</span></span></span><span class="mclose">)</span></span></span></span>，因此，随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> 的联合概率密度函数为</p><p><img src="eq5.svg" alt="Z的联合概率密度函数"></p><p>其中，指数函数的指数部分就是用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mi>T</mi></msup><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{Z}^T\vec{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 来表示的。我们通过推导，得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mi>T</mi></msup><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">(</mo><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><msup><mo stretchy="false">)</mo><mi>T</mi></msup><msup><mi mathvariant="normal">Σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z}^T\vec{Z} = (\vec{X}-\vec{\mu})^T\Sigma^{-1}(\vec{X}-\vec{\mu})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.21633em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.21633em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。可以将其代入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>z</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(z_1,\cdots,z_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 中。又因为  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>z</mi><mn>1</mn></msub><mo>⋯</mo><mi>d</mi><msub><mi>z</mi><mi>n</mi></msub><mo>=</mo><msup><mrow><mo fence="true">∣</mo><mi>B</mi><msup><mi>B</mi><mi>T</mi></msup><mo fence="true">∣</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mi>d</mi><msub><mi>x</mi><mi>i</mi></msub><mo>⋯</mo><mi>d</mi><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">dz_1\cdots dz_n=\left|BB^T\right|^{-\frac{1}{2}}dx_i\cdots dx_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.55592em;vertical-align:-0.35000999999999993em;"></span><span class="minner"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.86199em;"><span style="top:-2.2559899999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86199em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000999999999993em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.86199em;"><span style="top:-2.2559899999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86199em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000999999999993em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.20591em;"><span style="top:-3.6148900000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (<strong>雅可比行列式</strong>) 关系，所以要在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>z</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(z_1,\cdots,z_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 上再乘上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mo fence="true">∣</mo><mi>B</mi><msup><mi>B</mi><mi>T</mi></msup><mo fence="true">∣</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">\left|BB^T\right|^{-\frac{1}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.55592em;vertical-align:-0.35000999999999993em;"></span><span class="minner"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.86199em;"><span style="top:-2.2559899999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86199em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000999999999993em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.86199em;"><span style="top:-2.2559899999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86199em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000999999999993em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.20591em;"><span style="top:-3.6148900000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mo fence="true">∣</mo><mi mathvariant="normal">Σ</mi><mo fence="true">∣</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">\left|\Sigma\right|^{-\frac{1}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.34392em;vertical-align:-0.25em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord">Σ</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.09392em;"><span style="top:-3.5029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>。这样也就得到了最后的概率密度函数。</p><p><font color="orange"><strong>个人理解：</strong></font><br>我个人比较倾向于文章一的推导流程。根据我自己的理解，我总结了完整的推导流程：</p><ul><li>给出一元标准高斯分布的概率密度函数，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">Z</mi><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{Z} \sim \mathcal{N}(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07944em;">Z</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 即</li></ul><p><img src="eq6.svg" alt="一元标准高斯分布的概率密度函数"></p><ul><li>根据标准高斯分布的概率密度函数，很容易得到内部每个随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 都服从标准高斯分布且两两彼此独立的随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">[</mo><msub><mi>Z</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>Z</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\vec{Z}=[Z_1,\cdots, Z_n]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 的概率密度函数。即</li></ul><p><img src="eq7.svg" alt="多元标准高斯分布"></p><ul><li><p>当面对普通的随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{X} \sim \mathcal{N}(\vec{\mu}, \Sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mclose">)</span></span></span></span> 时，即其每个随机变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><msub><mi>μ</mi><mi>i</mi></msub><mo separator="true">,</mo><msubsup><mi>σ</mi><mi>i</mi><mn>2</mn></msubsup><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_i \sim \mathcal{N}(\mu_i, \sigma_i^2) (i = 1, \cdots, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.072772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_i, X_j(i, j = 1, \cdots, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 彼此不独立的情况下, 我们该如何求随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span></span></span></span> 的联合概率密度函数呢?</p><blockquote><p>一个很自然的想法是, 如果我们能<strong>通过线性变换, 使得随机向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">\vec{X} = [X_1, \cdots, X_n]^\top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span> 中的每个随机变量彼此独立, 则我们也可以通过独立随机变量概率密度函数之间的关系求出其联合概率密度函数。</strong><br><strong>Note</strong>: 文章一说的是通过变换使得每个随机变量彼此独立，我觉得可以更进一步，通过变换使得每个随机变量彼此独立，并服从标准正态分布。文章一也正是这么做的。</p></blockquote></li><li><p>通过线性变换公式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>Z</mi><mo>⃗</mo></mover><mo>=</mo><msup><mi>B</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mover accent="true"><mi>X</mi><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><mi>μ</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{Z}=B^{-1}(\vec{X}-\vec{\mu})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.21633em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">μ</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewbox="0 0 471 714" preserveaspectratio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 替换掉联合概率密度函数中指数部分的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>Z</mi><mi>T</mi></msup><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z^TZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span>。这样，联合概率密度函数就变成了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的函数。</p></li><li><p>再通过积分的换元，得出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>z</mi><mn>1</mn></msub><mo>⋯</mo><mi>d</mi><msub><mi>z</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">dz_1\cdots dz_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>x</mi><mn>1</mn></msub><mo>⋯</mo><mi>d</mi><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">dx_1\cdots dx_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之间的关系，体现在联合概率密度函数的系数部分。</p></li><li><p>接着，通过推导得到的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><msup><mi>B</mi><mi>T</mi></msup><mo>=</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">BB^T=\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>, 将联合概率密度函数里的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 进行替换，则最后得到的概率密度函数与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 无关。因此，我们无需显式地求出变换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，就可以得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 的联合概率密度。</p></li></ul><h2 id="font-colorpurple二维高斯分布图像font"><a class="markdownIt-Anchor" href="#font-colorpurple二维高斯分布图像font"></a> <font color="purple"><strong>二维高斯分布图像</strong></font></h2><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1.5</mn><mo separator="true">;</mo><mn>1.5</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mu=(0,0), \Sigma=[1, 1.5; 1.5, 4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span></p><p><img src="Gaussian_1_1.5_1.5_4.svg" alt="二维高斯分布1"></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1.5</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">;</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mu=(1,1.5), \Sigma=[3, 0; 0, 3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span></p><p><img src="Gaussian_3_0_0_3.svg" alt="二维高斯分布2"></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>0.8</mn><mo separator="true">;</mo><mo>−</mo><mn>0.8</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mu=(0,0), \Sigma=[1, -0.8; -0.8, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><p><img src="Gaussian_1_-0.8_1_-0.8.svg" alt="二维高斯分布3"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要转载了关于多元高斯分布概率密度函数的推导过程，并画出了二维高斯分布的图像，以便得到更直观的理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Gaussian" scheme="https://taosean.github.io/tags/Gaussian/"/>
    
      <category term="Distribution" scheme="https://taosean.github.io/tags/Distribution/"/>
    
      <category term="高斯分布" scheme="https://taosean.github.io/tags/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83/"/>
    
      <category term="正态分布" scheme="https://taosean.github.io/tags/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83/"/>
    
      <category term="概率" scheme="https://taosean.github.io/tags/%E6%A6%82%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>IoU variants</title>
    <link href="https://taosean.github.io//2021/03/30/IoU-variants/"/>
    <id>https://taosean.github.io//2021/03/30/IoU-variants/</id>
    <published>2021-03-30T11:38:37.000Z</published>
    <updated>2021-03-30T11:38:37.081Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>激活函数详解</title>
    <link href="https://taosean.github.io//2021/03/30/Activation-functions/"/>
    <id>https://taosean.github.io//2021/03/30/Activation-functions/</id>
    <published>2021-03-30T06:59:36.000Z</published>
    <updated>2021-04-01T07:27:47.178Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了深度学习中出现的各种激活函数，从公式，函数曲线和导数函数曲线等角度进行了总结。</p><a id="more"></a><p>激活函数可分为 <strong>饱和激活函数</strong> 和 <strong>非饱和激活函数</strong> 两种。</p><p>饱和激活函数主要有 Sigmoid, tanh 等，饱和激活函数主要有 ReLU, Leaky ReLU, SELU, Swish, Mish, Maxout 等。</p><h2 id="饱和激活函数"><a class="markdownIt-Anchor" href="#饱和激活函数"></a> 饱和激活函数</h2><h3 id="sigmoid-函数"><a class="markdownIt-Anchor" href="#sigmoid-函数"></a> Sigmoid 函数</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac><mo>=</mo><mfrac><msup><mi>e</mi><mi>x</mi></msup><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">S(x) = \frac{1}{1+e^{-x}} = \frac{e^x}{e^x+1} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.110722em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.341392em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S&#x27;(x) = S(x)(1-S(x)) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><img src="sigmoid.png" alt="Sigmoid 函数曲线"></p><p><img src="g-sigmoid.png" alt="Sigmoid 梯度函数曲线"></p><p>Sigmoid 函数的三个主要缺陷：</p><ol><li><p>梯度消失：注意：Sigmoid 函数趋近 0 和 1 的时候变化率会变得平坦，也就是说，Sigmoid 的梯度趋近于 0。神经网络使用 Sigmoid 激活函数进行反向传播时，输出接近 0 或 1 的神经元其梯度趋近于 0。这些神经元叫作饱和神经元。因此，这些神经元的权重不会更新。此外，与此类神经元相连的神经元的权重也更新得很慢。该问题叫作梯度消失。因此，想象一下，如果一个大型神经网络包含 Sigmoid 神经元，而其中很多个都处于饱和状态，那么该网络无法执行反向传播。</p></li><li><p>不以零为中心：Sigmoid 输出不以零为中心的。</p></li><li><p>计算成本高昂：exp() 函数与其他非线性激活函数相比，计算成本高昂。</p></li></ol><p>下一个要讨论的非线性激活函数解决了 Sigmoid 函数中值域期望不为 0 的问题。</p><h3 id="tanh-函数"><a class="markdownIt-Anchor" href="#tanh-函数"></a> Tanh 函数</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac><mo>=</mo><mfrac><mn>2</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>x</mi></mrow></msup></mrow></mfrac><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">tanh(x) = \frac{e^x-e^{-x}}{e^x+e^{-x}} = \frac{2}{1+e^{-2x}}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.217661em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.448331em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><msup><mi>h</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">tanh&#x27;(x) = \frac{e^x+e^{-x}}{e^x-e^{-x}} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.217661em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.448331em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src="tanh.png" alt="tanh 函数曲线及其梯度函数曲线"></p><p>Tanh 激活函数又叫作双曲正切激活函数（hyperbolic tangent activation function）。与 Sigmoid 函数类似，Tanh 函数也使用真值，但 Tanh 函数将其压缩至 <code>-1</code> 到 <code>1</code> 的区间内。与 Sigmoid 不同，Tanh 函数的输出以零为中心，因为区间在 <code>-1</code> 到 <code>1</code> 之间。<code>可以把 tanh 函数看做是 sigmoid 向下平移和拉伸后的结果。</code> 在实践中，Tanh 函数的使用优先性高于 Sigmoid 函数。负数输入被当作负值，零输入值的映射接近零，正数输入被当作正值。<br>唯一的缺点是：</p><ol><li>Tanh 函数也会有梯度消失的问题，因此在饱和时也会「杀死」梯度。</li></ol><h3 id="hard-sigmoid-函数"><a class="markdownIt-Anchor" href="#hard-sigmoid-函数"></a> Hard-Sigmoid 函数</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>a</mi><mi>r</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>g</mi><mi>m</mi><mi>o</mi><mi>i</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mfrac><mrow><mn>2</mn><mi>x</mi><mo>+</mo><mn>5</mn></mrow><mn>10</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mi>f</mi><mtext> </mtext><mi>x</mi><mo>&lt;</mo><mo>−</mo><mn>2.5</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mn>0.2</mn><mo>∗</mo><mi>x</mi><mo>+</mo><mn>0.5</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mi>f</mi><mtext> </mtext><mo>−</mo><mn>2.5</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>2.5</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mi>f</mi><mtext> </mtext><mi>x</mi><mo>&gt;</mo><mn>2.5</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> hard\_sigmoid(x)=max(0,min(1, \frac{2x+5}{10}))=\left\{\begin{aligned}0 &amp; &amp; if \  x &lt;-2.5 \\0.2*x+0.5 &amp; &amp; if \  -2.5\leq x\leq 2.5 \\1 &amp; &amp; if \  x&gt;2.5\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-1.4999999999999991em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src="hardsigmoid.png" alt="Sigmoid 函数和 hard-Sigmoid 函数对比图"></p><p><img src="g-hardsigmoid.png" alt="Sigmoid 梯度函数和 hard-Sigmoid 梯度函数对比图"></p><p>Hard-Sigmoid 函数是 Sigmoid 激活函数的分段线性近似。从公式和曲线上来看，其更易计算，因此会提高训练的效率，不过同时会导致一个问题：就是首次派生值为零可能会导致神经元 died 或者过慢的学习率。</p><h2 id="非饱和激活函数"><a class="markdownIt-Anchor" href="#非饱和激活函数"></a> 非饱和激活函数</h2><h3 id="relu-修正线性单元"><a class="markdownIt-Anchor" href="#relu-修正线性单元"></a> ReLU （修正线性单元）</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)=max(0,x) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p><p><img src="relu.png" alt="ReLU 函数曲线"></p><p><img src="g-relu.png" alt="ReLU 梯度函数曲线"></p><p>该激活函数使网络更快速地收敛。它不会饱和，即它可以对抗梯度消失问题，至少在正区域（<code>x&gt;0</code> 时）可以这样，因此神经元至少在一半区域中不会把所有零进行反向传播。由于使用了简单的阈值化（thresholding），ReLU 计算效率很高。但是 ReLU 神经元也存在一些缺点：</p><ol><li>不以零为中心：和 Sigmoid 激活函数类似，ReLU 函数的输出不以零为中心。</li><li>前向传导（forward pass）过程中，如果 <code>x &lt; 0</code>，则神经元保持非激活状态，且在后向传导（backward pass）中「杀死」梯度。这样权重无法得到更新，网络无法学习。当 <code>x = 0</code> 时，该点的梯度未定义，但是这个问题在实现中得到了解决，通过采用左侧或右侧的梯度的方式。</li></ol><h3 id="relu6抑制其最大值"><a class="markdownIt-Anchor" href="#relu6抑制其最大值"></a> ReLU6（抑制其最大值）</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mn>6</mn><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ReLU6=min(6,max(0,x)) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><img src="relu6.png" alt="ReLU6 和 ReLU 函数曲线对比"></p><p><img src="g-relu6.png" alt="ReLU6 和 ReLU 梯度函数曲线对比"></p><p>主要是为了在移动端 float16 的低精度的时候，也能有很好的数值分辨率，如果对 ReLu 的输出值不加限制，那么输出范围就是 <code>0</code> 到正无穷，而低精度的 float16 无法精确描述其数值，带来精度损失。</p><h3 id="elu-指数线性单元-exponential-linear-units"><a class="markdownIt-Anchor" href="#elu-指数线性单元-exponential-linear-units"></a> ELU (指数线性单元 exponential linear units)</h3><p><img src="equation1.png" alt="ELU 公式"></p><p><img src="elu.png" alt="ELU 函数曲线"></p><p>其将激活函数的平均值接近零，从而加快学习的速度。同时，还可以通过正值的标识来避免梯度消失的问题。根据一些研究，ELU 的分类 精确度要高于 Relu。</p><ul><li><p>融合了 Sigmoid 和 ReLU，<strong>左侧具有软饱和性</strong>，右侧无饱和性。</p></li><li><p>右侧线性部分使得 ELU 能够缓解梯度消失，而<strong>左侧软饱能够让 ELU 对输入变化或噪声更鲁棒</strong>。</p></li><li><p>ELU 的输出<strong>均值接近于零</strong>，所以收敛速度更快。</p></li><li><p>在 ImageNet 上，不加 Batch Normalization 30 层以上的 ReLU, 网络会无法收敛，PReLU 网络在 MSRA 的 Fan-in（caffe）初始化下会发散，而 ELU 网络在 Fan-in/Fan-out 下都能收敛。</p></li></ul><h3 id="selu-缩放指数线性单元-scaled-exponential-linear-units"><a class="markdownIt-Anchor" href="#selu-缩放指数线性单元-scaled-exponential-linear-units"></a> SELU (缩放指数线性单元 scaled exponential linear units)</h3><p>就是给 ELU 乘上一个系数，该系数大于 <code>1</code>。</p><p>在这篇 paper Self-Normalizing Neural Networks 中，作者提到，SELU 可以使得输入在经过一定层数之后变为固定的分布。</p><p>以前的 ReLU、P-ReLU、ELU 等激活函数都是在负半轴坡度平缓，这样在激活的方差过大时可以让梯度减小，防止了梯度爆炸，但是在正半轴其梯度简单地设置为了 <code>1</code>。而 SELU 的正半轴大于 <code>1</code>，在方差过小的时候可以让它增大，但是同时防止了梯度消失。这样激活函数就有了一个不动点，网络深了之后每一层的输出都是均值为 <code>0</code>，方差为 <code>1</code>.</p><p>其中超参 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 的值是 <strong>证明得到</strong> 的（而非训练学习得到）</p><p><img src="equation3.png" alt="SELU 函数及其梯度函数公式"></p><p><img src="selu.png" alt="SELU 函数曲线"></p><h3 id="leaky-relu"><a class="markdownIt-Anchor" href="#leaky-relu"></a> Leaky-ReLU</h3><p>Leaky ReLU 和 ReLU 不同的是，ReLU 是将所有的负值设为零，而 Leaky ReLU 是给所有负值赋予一个非零斜率，即用一个负值部分除以大于 <code>1</code> 的数。(公式中 <code>a</code> 是大于 <code>1</code> 的一个常数)</p><p><img src="equation4.png" alt="Leaky ReLU 公式"></p><p><img src="lrelu.png" alt="Leaky ReLU 函数曲线"></p><h3 id="p-relu参数化修正线性单元"><a class="markdownIt-Anchor" href="#p-relu参数化修正线性单元"></a> P-ReLU（参数化修正线性单元）</h3><p><img src="equation5.svg" alt="P-ReLU 公式"></p><p>可以看作是 Leaky ReLU 的一个变体，不同的是，P-ReLU 中的负值部分的斜率是根据数据来定的，即 <code>a</code> 的值并不是一个常数。</p><p>注意区分 PReLU 和 LeakyReLU，PReLU 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> 是一个可学习的数组，尺寸与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 相同。</p><p>PReLU 是针对 ReLU 的一个改进型，在负数区域内，PReLU 有一个很小的斜率，这样也可以避免 ReLU 死掉的问题。相比于 ELU，PReLU 在负数区域内是线性运算，斜率虽然小，但是不会趋于0，这算是一定的优势。</p><h3 id="r-relu-随机纠正线性单元"><a class="markdownIt-Anchor" href="#r-relu-随机纠正线性单元"></a> R-ReLU (（随机纠正线性单元)</h3><p>R-ReLU 也是 Leaky ReLU 的一个变体，只不过在这里负值部分的斜率在训练的时候是随机的，即在一个范围内随机抽取 <code>a</code> 的值，不过这个值在测试环节会固定下来。</p><h3 id="swish"><a class="markdownIt-Anchor" href="#swish"></a> Swish</h3><p>paper : Searching for Activation Functions</p><p>beta是个常数或者可以训练的参数。其具有无上界有下界、平滑、非单调的特性。其在模型效果上优于 ReLU。</p><blockquote><p>由于训练会受多种因素的影响，我们很难证明为什么一个激活函数会优于另一个。但是我们认为 Swish <strong>无上界有下界</strong>、<strong>非单调</strong>且<strong>平滑</strong>的特性都是优势。</p></blockquote><p><img src="equation6.png" alt="Swish 公式及其梯度函数公式"></p><p><img src="swish.png" alt="Swish 函数曲线"></p><p><img src="g-swish.png" alt="Swish 梯度函数曲线"></p><h3 id="hard-swish"><a class="markdownIt-Anchor" href="#hard-swish"></a> Hard-Swish</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>−</mo><mi>s</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mfrac><mrow><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mn>6</mn><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><mn>6</mn></mfrac></mrow><annotation encoding="application/x-tex">h-swish(x) = x \frac{ReLU6(x+3)}{6} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord mathdefault">x</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord">6</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>在论文 Searching for MobileNet V3 中，作者提到，虽然这种 Swish 非线性提高了精度，但是在嵌入式环境中，他的成本是非零的，因为在移动设备上计算 sigmoid 函数代价要大得多。</p><p>因此作者使用 hard-Swish 和 hard-Sigmoid 替换了 ReLU6 和 SE-block 中的 Sigmoid 层，但是只是在网络的后半段才将 ReLU6 替换为 h-Swish，因为作者发现 Swish 函数只有在更深的网络层使用才能体现其优势。</p><p>首先是肯定了 Swish 的重要性，然后指出<strong>在量化模式下，Sigmoid 函数比 ReLU6 的计算代价大的多，所以才有了这个 ReLU6 版本的 h-Swish</strong>。</p><p><img src="hardswish.png" alt="Swish 和 hard-Swish 函数曲线对比"></p><p><img src="g-hardswish.png" alt="Swish 和 hard-Swish 梯度函数曲线对比"></p><h3 id="mish"><a class="markdownIt-Anchor" href="#mish"></a> Mish</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>i</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><mi>t</mi><mi>a</mi><mi>n</mi><mi>h</mi><mo stretchy="false">(</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi>e</mi><mi>x</mi></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Mish(x) = x * tanh(ln(1+e^x)) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><img src="mish.png" alt="Mish 和 Swish 函数曲线对比"></p><p><img src="g-mish.png" alt="Mish 和 Swish 梯度函数曲线对比"></p><p>为什么 Mish 表现的更好：</p><blockquote><p>无边界(即正值可以达到任何高度)避免了由于封顶而导致的饱和。理论上对负值的轻微允许允许更好的梯度流，而不是像 ReLU 中那样的硬零边界。<br>平滑的激活函数允许更好的信息深入神经网络，从而得到更好的准确性和泛化。<br>Mish 函数在曲线上几乎所有点上的平滑度</p></blockquote><h3 id="maxout"><a class="markdownIt-Anchor" href="#maxout"></a> Maxout</h3><p>与常规的激活函数不同，Maxout 是一个可以学习的分段线性函数。</p><p>其可以看做是在深度学习网络中加入了一层激活函数层，包含一个参数 <code>k</code>，这一层相比 ReLU，Sigmoid 等，其在于增加了 <code>k</code> 个神经元，然后输出激活值最大的值。<br>其需要学习的参数就是 <code>k</code> 个神经元中的权值和偏置，这就相当于<strong>常规的激活函数一层，而 Maxout 是两层，而且参数个数增加了 <code>k</code> 倍</strong>。</p><p>其可以有效的原理是，<strong>任何 ReLU 及其变体等激活函数都可以看成分段的线性函数，而 Maxout 加入的一层神经元正是一个可以学习参数的分段线性函数</strong>。</p><p><strong>优点</strong>：<br>其拟合能力很强，理论上可以拟合任意的凸函数；<br>具有 ReLU 的所有优点，线性和非饱和性；<br>同时没有 ReLU 的一些缺点，如神经元的死亡；</p><p><strong>缺点</strong>：<br>导致整体参数的激增。</p><p><img src="maxout.png" alt="Maxout 示意图"></p><p><img src="maxoutnet.png" alt="Maxout network 示意图"></p><blockquote><p>对上图做个说明，第 <code>i</code> 层有 <code>3</code> 个节点，红点表示，而第 <code>i+1</code> 层有 <code>4</code> 个结点，用彩色点表示，此时在第 <code>i+1</code> 层采用 maxout（<code>k=3</code>）。我们看到第 <code>i+1</code> 层的每个节点的激活值都有 <code>3</code> 个值，<code>3</code> 次计算的最大值才是对应点的最终激活值。我举这个例子主要是为了说明，决定结点的激活值的时候并不是以层为单位，仍然以节点为单位。</p></blockquote><h3 id="softplus"><a class="markdownIt-Anchor" href="#softplus"></a> Softplus</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi>e</mi><mi>x</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y=log(1+e^x) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><img src="softplus.png" alt="Softplus 和 ReLU 的函数曲线对比"></p><blockquote><p>softplus可以看作是 ReLU 的平滑。根据神经科学家的相关研究，softplus 和 ReLU 与脑神经元激活频率函数有神似的地方。也就是说，相比于早期的激活函数，softplus 和 ReLU 更加接近脑神经元的激活模型，而神经网络正是基于脑神经科学发展而来，这两个激活函数的应用促成了神经网络研究的新浪潮。</p></blockquote><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="https://blog.csdn.net/jsk_learner/article/details/102822001" target="_blank" rel="noopener">深度学习—激活函数详解（Sigmoid、tanh、ReLU、ReLU6及变体P-R-Leaky、ELU、SELU、Swish、Mish、Maxout、hard-sigmoid、hard-swish）</a><br><a href="https://www.jiqizhixin.com/articles/2017-11-02-26" target="_blank" rel="noopener">一文概览深度学习中的激活函数</a><br><a href="https://zhuanlan.zhihu.com/p/122267172" target="_blank" rel="noopener">深度学习中常用的激活函数详解</a><br><a href="https://blog.csdn.net/Chaolei3/article/details/78873039" target="_blank" rel="noopener">深度学习笔记–激活函数：sigmoid，maxout</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了深度学习中出现的各种激活函数，从公式，函数曲线和导数函数曲线等角度进行了总结。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>YOLOv4</title>
    <link href="https://taosean.github.io//2021/03/29/YOLOv4/"/>
    <id>https://taosean.github.io//2021/03/29/YOLOv4/</id>
    <published>2021-03-29T07:33:05.000Z</published>
    <updated>2021-04-01T07:10:01.484Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录了关于 yolo v4 的内容。</p><a id="more"></a><h1 id="0-序言"><a class="markdownIt-Anchor" href="#0-序言"></a> 0. 序言</h1><p>Yolo v4 论文主要由 <strong>目标检测网络构成</strong>，<strong>Bag of freebies</strong>, <strong>Bag of specials</strong> 这三部分组成。</p><p>作者首先详细列举了目前已有的目标检测网络构成部件，以及已有的 Bag of freebies, Bag of specials, 然后分别从这三大部分中选取合适的内容，组成了 Yolo v4.</p><p>列举的三大部分如下面三张图</p><p><img src="detector-parts.png" alt="目标检测网络的构成部件"></p><p><img src="freebies.png" alt="Bag of freebies"></p><p><img src="specials.png" alt="Bag of specials"></p><h1 id="1-yolo-v4-的选择"><a class="markdownIt-Anchor" href="#1-yolo-v4-的选择"></a> 1. YOLO v4 的选择</h1><p>YOLO v4 对各个部分的选择如下图所示</p><p><img src="selections.png" alt="YOLO v4 的选择"></p><h1 id="2-各部分详细解读"><a class="markdownIt-Anchor" href="#2-各部分详细解读"></a> 2. 各部分详细解读</h1><h2 id="21-backbone"><a class="markdownIt-Anchor" href="#21-backbone"></a> 2.1 Backbone</h2><h3 id="211-densenet"><a class="markdownIt-Anchor" href="#211-densenet"></a> 2.1.1 DenseNet</h3><p>Transition layer 由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的卷积和 pooling 组成，分别用来降低通道数和空间尺寸。</p><p><img src="denseblock.jpeg" alt="DenseBlock"></p><p><img src="densenet.png" alt="DenseNet"></p><h3 id="212-cross-stage-partial-connections-csp"><a class="markdownIt-Anchor" href="#212-cross-stage-partial-connections-csp"></a> 2.1.2 Cross-Stage-Partial-connections (CSP)</h3><p>CSP 可以用在不同的网络上，下面的图展示了在 DenseNet 上使用 CSP 的结构。</p><p>CSPNet 将输入分成两部分 (沿通道分开)，一部分经过 DenseBlock 的处理，另一部分直接跳过处理，输入最后的输出层。</p><p><img src="CSP1.jpeg" alt="CSP Block"></p><p><img src="CSP2.png" alt="CSPNet"></p><h3 id="213-cspdarknet53"><a class="markdownIt-Anchor" href="#213-cspdarknet53"></a> 2.1.3 CSPDarknet53</h3><p>YOLO v4 使用 Darknet53 + CSP 连接组成的 CSPDarknet53 作为 backbone.</p><p><img src="CSPDarknet53.png" alt="YOLO v4 网络结构"></p><h2 id="22-neck"><a class="markdownIt-Anchor" href="#22-neck"></a> 2.2 Neck</h2><h3 id="221-feature-pyramid-networks-fpn"><a class="markdownIt-Anchor" href="#221-feature-pyramid-networks-fpn"></a> 2.2.1 Feature Pyramid Networks (FPN)</h3><p><img src="FPN.png" alt="FPN"></p><h3 id="222-spp-spatial-pyramid-pooling-layer"><a class="markdownIt-Anchor" href="#222-spp-spatial-pyramid-pooling-layer"></a> 2.2.2 SPP (spatial pyramid pooling layer)</h3><p><img src="SPP.jpeg" alt="原始的SPP"></p><h3 id="223-yolo-with-spp"><a class="markdownIt-Anchor" href="#223-yolo-with-spp"></a> 2.2.3 YOLO with SPP</h3><p>YOLO 中的 SPP 和本来的作用有点不一样，YOLO 中的 SPP 使用不同的 pooling 层对输入进行池化，但是不改变空间尺寸。然后不同 pooling 层得到的结果和原始的输入都 concatenate 在一起。</p><p><img src="SPP-yolo.jpeg" alt="YOLO 中的 SPP"></p><h3 id="224-path-aggregation-network-pan"><a class="markdownIt-Anchor" href="#224-path-aggregation-network-pan"></a> 2.2.4 Path Aggregation Network (PAN)</h3><p>下图是目标检测的 Path Aggregation Network(PAN)。 自底向上的路径 (b) 被扩展，使低层信息更容易传播到顶层。 在 FPN 中，局部空间信息在红色箭头中向上传递。 虽然在图中没有清楚地显示，但是红色的路径穿过了大约 <code>100</code> 多层。 PAN 引入了一条简捷的路径(绿色路径) ，只需要大约 <code>10</code> 层就可以到达顶层 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">N_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。 <strong>这种短路概念使细粒度的本地化信息可用于顶层</strong>。</p><p><img src="PAN.png" alt="PAN 结构"></p><p><img src="view-pan.jpeg" alt="另一种看待 PAN 的方法"></p><p>不过在 YOLOv4 中，特征图不是加上邻居层，而是 concate 在一起。</p><p><img src="modified-pan.jpg" alt="YOLO v4 中修改过的 PAN"></p><h3 id="225-spatial-attention-module-sam"><a class="markdownIt-Anchor" href="#225-spatial-attention-module-sam"></a> 2.2.5 Spatial Attention Module (SAM)</h3><p>注意力 (Attention) 在 DL 设计中有着广泛的应用。 在 SAM 中，最大池化和平均池化分别应用于输入特征图，生成两组特征图。 这些结果被输入到一个卷积层，然后经过 sigmoid 函数，以产生空间注意力。</p><p><img src="SAM.jpeg" alt="SAM 模块"></p><p>对应 空间注意力模块 (SAM)，也有 通道注意力模块 (CAM)</p><p><img src="CAM.png" alt="CAM 模块"></p><p>在 YOLOv4 中，使用了一个修改的 SAM，没有应用最大和平均池化。</p><p><img src="modified-sam.jpeg" alt="YOLO v4 中 SAM"></p><p>在 YOLO v4 中，FPN 概念逐渐被修改版的 SPP和 PAN 实现/取代。</p><h2 id="23-bag-of-freebies-bof-for-backbone"><a class="markdownIt-Anchor" href="#23-bag-of-freebies-bof-for-backbone"></a> 2.3 Bag of Freebies (BoF) for backbone</h2><p>YOLOv4 backbone 的 BoF 特性包括:</p><ul><li>CutMix 和 Mosaic 数据增强</li><li>DropBlock 正则化</li><li>类别标签平滑</li></ul><h3 id="231-cutmix-数据增强"><a class="markdownIt-Anchor" href="#231-cutmix-数据增强"></a> 2.3.1 CutMix 数据增强</h3><p>Cutout 数据增强删除图像的一个区域(见下图)。 <strong>这迫使模型在进行分类时不要对特定特性过于自信</strong>。 然而这样的话，图像的一部分充满了没用的信息，这是一种浪费。 在 CutMix 中，图像的一部分被剪切并粘贴到另一个图像上。 Ground truth 标签会根据补丁的面积按比例重新调整，例如 <code>0.6</code> 像狗，<code>0.4</code> 像猫。</p><p><img src="cutmix.jpeg" alt="CutMix 与其他方法效果比较"></p><p>从概念上讲，CutMix 对于一个对象可能由什么组成有更广阔的视野。 CutOut 区域迫使模型学习目标分类的不同特征集合。 这样可以避免过度自信。 由于该区域被替换为另一个图像，图像中的信息量和训练效率也不会受到显著影响。</p><h3 id="232-mosaic-数据增强"><a class="markdownIt-Anchor" href="#232-mosaic-数据增强"></a> 2.3.2 Mosaic 数据增强</h3><p>Mosaic 是一种数据增强方法，组合了 4 个训练图像到一个训练图像中(而不是 CutMix 中的2个)。 这增强了对其正常 context 之外的对象的检测。 此外，每个 mini-batch 都包含更大数量的图像 (4x)，因此减少了估计均值和方差时对大的 mini-batch 的需求。</p><p><img src="mosaic.jpeg" alt="Mosaic 增强示意图"></p><h3 id="233-dropblock-正则化"><a class="markdownIt-Anchor" href="#233-dropblock-正则化"></a> 2.3.3 DropBlock 正则化</h3><p>在全连接层中，我们可以应用 dropout 强制模型从各种特征中学习，而不是对一些特征过于自信。然而这可能对卷积层无效。相邻位置是高度相关的。所以即使有些像素被去掉了(下面的中图) ，空间信息仍然可以被检测到。 DropBlock 正则化基于一个类似的概念，但适用于卷积层。</p><p><img src="dropblock.png" alt="DropBlock"></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><msub><mi>k</mi><mi>s</mi></msub><mi>i</mi><mi>z</mi><mi>e</mi><mo>×</mo><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><msub><mi>k</mi><mi>s</mi></msub><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">block_size × block_size</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span></span></span></span> 大小的块被整块删除，而不是删掉单独的像素。</p><p><img src="dropblock2.jpg" alt="dropblock算法"></p><h3 id="234-类别标签平滑class-label-smoothing"><a class="markdownIt-Anchor" href="#234-类别标签平滑class-label-smoothing"></a> 2.3.4 类别标签平滑(Class label smoothing)</h3><p>每当你觉得自己绝对正确的时候，你很可能是错的。 100% 相信一个预测可能会显示出这个模型是在记忆数据而不是在学习。 标签平滑将预测的目标上限调整为一个较低的值，比如 <code>0.9</code>。 它将使用这个值而不是 <code>1.0</code> 来计算损失。 这个概念减轻了 overfitting 问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p = tf.placeholder(tf.float32, shape=[<span class="keyword">None</span>, <span class="number">10</span>])</span><br><span class="line"><span class="comment"># Use 0.9 instead of 1.0.</span></span><br><span class="line">feed_dict = &#123;</span><br><span class="line">  p: [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]] <span class="comment"># Image with label "3"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># logits_real_image is the logits calculated by </span></span><br><span class="line"><span class="comment"># the discriminator for real images.</span></span><br><span class="line">d_real_loss = tf.nn.sigmoid_cross_entropy_with_logits(</span><br><span class="line">                    labels=p, logits=logits_real_image)</span><br></pre></td></tr></table></figure><h2 id="24-bag-of-specials-bos-for-backbone"><a class="markdownIt-Anchor" href="#24-bag-of-specials-bos-for-backbone"></a> 2.4 Bag of Specials (BoS) for backbone</h2><p>YOLOv4 backbone 的 BoS 特性包括:</p><ul><li>Mish 激活</li><li>Cross-stage partial connections (CSP)</li><li>Multi-input weighted residual connections (MiWRC)</li></ul><h3 id="241-mish-激活"><a class="markdownIt-Anchor" href="#241-mish-激活"></a> 2.4.1 Mish 激活</h3><p>下面这个新的激活函数，称为 Swish，表现出比 ReLU 和很多其它激活函数更好的性能。</p><p><img src="swish.jpeg" alt="不同  值下的 Swish 激活函数"></p><p>Mish 是另一个与 ReLU 和 Swish 非常相似的激活函数。 正如论文所宣称的，Mish 在很多深层网络不同数据集的表现都优于它们。</p><p><img src="mish.jpeg" alt="Mish 激活函数"></p><p>关于激活函数的详细内容，请看这篇文章 <a href="//2021/03/30/Activation-functions/" title="激活函数详解">激活函数详解</a></p><h3 id="242-multi-input-weighted-residual-connections-miwrc"><a class="markdownIt-Anchor" href="#242-multi-input-weighted-residual-connections-miwrc"></a> 2.4.2 Multi-input weighted residual connections (MiWRC)</h3><blockquote><p>讲了 EfficientDet 中的逆残差块 (inverted residual block)</p></blockquote><p>在许多 ML 和 DL 问题中，我们学习输入的低维表示。 我们通过创建“信息”瓶颈 (bottleneck) 来提取数据的核心信息。 这迫使我们去发现最重要的信息，这是学习的核心原则。 根据这一原则，一个逆残差块以一个低维表示作为输入，并通过卷积(线性运算)和非线性运算对其进行操作。 但是像 ReLU 这样的非线性部分存在一个主要问题。非线性操作不成比例地拉伸或压缩区域。在这种压缩中，输入可能映射到相同的区域/点。 例如，ReLU 可能在这个低维空间中折叠通道，从而不可避免地丢失信息。 正如论文上引用的:</p><blockquote><p>为了保持表达能力，在窄层上消除非线性是很重要的。</p></blockquote><p>为了解决这个问题，我们可以暂时扩展维度(通道数量)。 我们希望在有很多的通道的情况下，在非线性操作之后，信息仍然可以保存在某些通道中。 下面是一个逆残留块的细节:</p><p><img src="inverted.jpeg" alt="逆残差模块 Inverted residual block"></p><p>如图所示，低维表示首先扩展到 tk 通道。 然后，用轻量级的 3x3 depthwise 卷积滤波。 然后在模块的末端将特性降低到低维。 在高维空间中时，会加上非线性操作。</p><p><img src="inverted-block.png" alt="逆残差模块示意图"></p><p>残差连接从模块的开始添加到尾部。 左图是传统的残差块，右图是描述的逆残差块。</p><p><img src="inverted-compare.png" alt="传统残差模块和逆残差模块对比"></p><p>理解 EfficientDet 的关键概念是件好事。 但 EfficientDet 对 YOLOv4的主要贡献是多Multi-input weighted residual connections。 在 EfficientDet 论文中，我们观察到不同的输入特征在不同的分辨率下，对输出特征的贡献是不均匀的。 但是在我们之前的讨论中，我们平等地加上了这些特性。 在 EfficientDet 中，输入特征在合成输出时的权重是不同的:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>=</mo><msub><mi>Σ</mi><mi>i</mi></msub><mfrac><msub><mi>w</mi><mi>i</mi></msub><mrow><mi>ϵ</mi><mo>+</mo><msub><mi>Σ</mi><mi>j</mi></msub><msub><mi>w</mi><mi>j</mi></msub></mrow></mfrac><mo>⋅</mo><msub><mi>I</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\it O =  \Sigma_i \frac{w_i}{\epsilon + \Sigma_jw_j} \cdot {I_i} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.079668em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mord mathit">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathit">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.308752em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30875199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathit">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30875199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.308752em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mord mathit">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.308752em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\it w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathit">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.308752em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 会像其它可训练的参数一样被训练和学习。</p><h2 id="25-bag-of-freebies-bof-for-detector"><a class="markdownIt-Anchor" href="#25-bag-of-freebies-bof-for-detector"></a> 2.5 Bag of Freebies (BoF) for detector</h2><p>Yolov4检测器的 BoF 功能包括:</p><ul><li>CIoU-loss</li><li>CmBN</li><li>DropBlock 正则化</li><li>Mosaic 数据增强</li><li>Self-Adversarial 训练</li><li>消除网格敏感性 (Eliminate grid sensitivity)</li><li>用多个 anchors 来对应单个 ground truth</li><li>Cosine annealing scheduler</li><li>最佳超参数</li><li>随机训练形状</li></ul><h3 id="251-ciou-loss"><a class="markdownIt-Anchor" href="#251-ciou-loss"></a> 2.5.1 CIoU-loss</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>C</mi><mi>I</mi><mi>o</mi><mi>U</mi></mrow></msub><mo>=</mo><mn>1</mn><mo>−</mo><mi>I</mi><mi>o</mi><mi>U</mi><mo>+</mo><mfrac><mrow><msup><mi>ρ</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><msup><mi>b</mi><mrow><mi>g</mi><mi>t</mi></mrow></msup><mo stretchy="false">)</mo></mrow><msup><mi>c</mi><mn>2</mn></msup></mfrac><mo>+</mo><mi>α</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">L_{CIoU} = 1- IoU + \frac{\rho^2(b,b^{gt})}{c^2} + \alpha v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.177108em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>=</mo><mfrac><mn>4</mn><msup><mi>π</mi><mn>2</mn></msup></mfrac><mo stretchy="false">(</mo><mi>a</mi><mi>r</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mfrac><msup><mi>w</mi><mrow><mi>g</mi><mi>t</mi></mrow></msup><msup><mi>h</mi><mrow><mi>g</mi><mi>t</mi></mrow></msup></mfrac><mo>−</mo><mi>a</mi><mi>r</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mfrac><mi>w</mi><mi>h</mi></mfrac><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">v = \frac{4}{\pi^2}(arctan\frac{w^{gt}}{h^{gt}} - arctan\frac{w}{h})^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3482399999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.00324em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7253428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8703428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1591079999999998em;vertical-align:-0.345em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mi>v</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>I</mi><mi>o</mi><mi>U</mi><mo stretchy="false">)</mo><mo>+</mo><mi>v</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\alpha=\frac{v}{(1-IoU)+v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.215392em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>关于各种 IoU 的详细内容，请看这篇文章。<a href="//2021/03/30/IoU-variants/" title="IoU variants">IoU variants</a></p><h3 id="252-cmbn"><a class="markdownIt-Anchor" href="#252-cmbn"></a> 2.5.2 CmBN</h3><p>原始的 Batch normalization 在一个 mini-batch 收集样本的均值和方差，以对层输入进行白话 (whiten)。 然而，如果 mini-batch size 很小，这些估计就会产生很大的噪声。一个解决方案是在很多 mini-batches 中估计它们。 但是，由于权重在每次迭代中都在变化，在这些权重下收集的统计信息在新的权重下可能变得不准确。 简单地进行平均是不正确的。幸运的是，权重是逐渐变化的。在 Cross-Iteration Batch Normalization(CBN) 中，它使用下面的调整来估计前面 <code>k</code> 次迭代中的统计信息。</p><p><img src="CBN.jpeg" alt="CBN 和 BN 的对比"></p><p>CmBN 是一个修改过的版本，它只收集单个 batch 内的 mini-batches 之间的统计数据。</p><h3 id="253-self-adversarial-training-sat"><a class="markdownIt-Anchor" href="#253-self-adversarial-training-sat"></a> 2.5.3 Self-Adversarial Training (SAT)</h3><p>SAT 是一种数据增强技术。首先，它对训练样本进行前向传播。在传统的反向传播算法中，我们通过调整模型权重来改进检测器的性能。在这里，它朝着相反的方向。它改变图像来最大化降低检测器的性能。也就是说，尽管新图片在视觉上看起来是一样的，但它会对当前模型产生对抗性攻击。接下来，使用原始边界框和类标签对模型进行训练。这有助于模型泛化并减少过拟合。</p><h3 id="254-消除网格敏感性eliminate-grid-sensitivity"><a class="markdownIt-Anchor" href="#254-消除网格敏感性eliminate-grid-sensitivity"></a> 2.5.4 消除网格敏感性(Eliminate grid sensitivity)</h3><p>边界框 b 的计算方法是:</p><p><img src="box.jpeg" alt="yolo 中边界框的计算方式"></p><p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>x</mi></msub><mo>=</mo><msub><mi>c</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">b_x=c_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>x</mi></msub><mo>=</mo><msub><mi>c</mi><mi>x</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">b_x=c_x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，我们需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">t_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别有一个巨大的负值和正值。但是我们可以用比例因子 (&gt;1.0) 来乘 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\it\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">σ</span></span></span></span></span>，这样更简单。 以下是源代码的更改:</p><p><img src="sensitivity.png" alt="源码的更改"></p><h3 id="255-multiple-anchors-for-a-single-ground-truth"><a class="markdownIt-Anchor" href="#255-multiple-anchors-for-a-single-ground-truth"></a> 2.5.5 Multiple anchors for a single ground truth</h3><p>如果 IoU(ground true，anchor) &gt; IoU 阈值，则使用多个 anchors。 (注意，我还没有足够的信息来确定它在 YOLOv4中的作用。)</p><h3 id="256-cosine-annealing-scheduler"><a class="markdownIt-Anchor" href="#256-cosine-annealing-scheduler"></a> 2.5.6 Cosine annealing scheduler</h3><p>余弦 schedule 根据余弦函数调整学习率。 它从缓慢降低大的学习率开始。 然后在中途迅速降低学习率，最终学习率降低以微小的斜率告终。</p><p><img src="cosine-formation.jpeg" alt="余弦学习率公式"></p><p>图表显示了学习率是如何衰减的(学习率 warmup 也在下面的图表中应用)及其对 mAP 的影响。 这可能不是很明显，新的 schedule 有稳定的变化，而不是停滞很长一段时间后再次发生变化。</p><p><img src="step-cosine.jpeg" alt="余弦学习率和阶梯学习率的对比"></p><h3 id="257-基于遗传算法的超参数选择进化算法"><a class="markdownIt-Anchor" href="#257-基于遗传算法的超参数选择进化算法"></a> 2.5.7 基于遗传算法的超参数选择(进化算法)</h3><h3 id="258-随机训练形状"><a class="markdownIt-Anchor" href="#258-随机训练形状"></a> 2.5.8 随机训练形状</h3><h2 id="26-bag-of-specials-bos-for-detector"><a class="markdownIt-Anchor" href="#26-bag-of-specials-bos-for-detector"></a> 2.6 Bag of Specials (BoS) for detector</h2><p>YOLOv4检测器的 BoS 功能包括:</p><ul><li>Mish 激活</li><li>改进的 SPP-block</li><li>改进的 SAM-block</li><li>改进的 PAN path-aggregation block</li><li>DIoU-NMS</li></ul><h3 id="261-diou-nms"><a class="markdownIt-Anchor" href="#261-diou-nms"></a> 2.6.1 DIoU-NMS</h3><p>NMS 过滤掉其它预测相同目标的边界框，并保留一个最有信心的边界框。</p><p>在 NMS 中使用了 DIoU (前面讨论过)作为因子。该方法利用 IoU 和两个边界框中心点之间的距离来抑制冗余边界框。这使得它对于遮挡的情况更加鲁棒。</p><p><img src="NMS.jpeg" alt="YOLO 中 NMS 流程"></p><h1 id="3-yolo-v4-网络结构分析"><a class="markdownIt-Anchor" href="#3-yolo-v4-网络结构分析"></a> 3. YOLO v4 网络结构分析</h1><p><img src="yolov4.jpg" alt="YOLO v4 网络结构"></p><blockquote><p>这里我们直接从代码上看看这个 CSPDarknet53 什么样子，定义如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">darknet_body</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''Darknent body having 52 Convolution2D layers'''</span></span><br><span class="line">    x = DarknetConv2D_BN_Mish(<span class="number">32</span>, (<span class="number">3</span>,<span class="number">3</span>))(x)</span><br><span class="line">    x = resblock_body(x, <span class="number">64</span>, <span class="number">1</span>, <span class="keyword">False</span>)</span><br><span class="line">    x = resblock_body(x, <span class="number">128</span>, <span class="number">2</span>)</span><br><span class="line">    x = resblock_body(x, <span class="number">256</span>, <span class="number">8</span>)</span><br><span class="line">    x = resblock_body(x, <span class="number">512</span>, <span class="number">8</span>)</span><br><span class="line">    x = resblock_body(x, <span class="number">1024</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果把 <strong>堆叠的残差单元</strong> (resblock_body)看成整体的话，那么这个结构和 Darknet53 以及 ResNet 等的确差别不大，特别是 resblock_body 的 num_blocks为 <code>1，2，8，8，4</code>, 和darknet53一模一样。</p><p>那么我们解析一下resblock_body的定义，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resblock_body</span><span class="params">(x, num_filters, num_blocks, all_narrow=True)</span>:</span></span><br><span class="line">    <span class="string">'''A series of resblocks starting with a downsampling Convolution2D'''</span></span><br><span class="line">    <span class="comment"># Darknet uses left and top padding instead of 'same' mode</span></span><br><span class="line">    preconv1 = ZeroPadding2D(((<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)))(x)</span><br><span class="line">    preconv1 = DarknetConv2D_BN_Mish(num_filters, (<span class="number">3</span>,<span class="number">3</span>), strides=(<span class="number">2</span>,<span class="number">2</span>))(preconv1)</span><br><span class="line">    shortconv = DarknetConv2D_BN_Mish(num_filters//<span class="number">2</span> <span class="keyword">if</span> all_narrow <span class="keyword">else</span> num_filters, (<span class="number">1</span>,<span class="number">1</span>))(preconv1)</span><br><span class="line">    mainconv = DarknetConv2D_BN_Mish(num_filters//<span class="number">2</span> <span class="keyword">if</span> all_narrow <span class="keyword">else</span> num_filters, (<span class="number">1</span>,<span class="number">1</span>))(preconv1)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_blocks):</span><br><span class="line">        y = compose(</span><br><span class="line">                DarknetConv2D_BN_Mish(num_filters//<span class="number">2</span>, (<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                DarknetConv2D_BN_Mish(num_filters//<span class="number">2</span> <span class="keyword">if</span> all_narrow <span class="keyword">else</span> num_filters, (<span class="number">3</span>,<span class="number">3</span>)))(mainconv)</span><br><span class="line">        mainconv = Add()([mainconv,y])</span><br><span class="line">    postconv = DarknetConv2D_BN_Mish(num_filters//<span class="number">2</span> <span class="keyword">if</span> all_narrow <span class="keyword">else</span> num_filters, (<span class="number">1</span>,<span class="number">1</span>))(mainconv)</span><br><span class="line">    route = Concatenate()([postconv, shortconv])</span><br><span class="line">    <span class="keyword">return</span> DarknetConv2D_BN_Mish(num_filters, (<span class="number">1</span>,<span class="number">1</span>))(route)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这么一看，和传统的ResBlock差别就出来了，为了大家更清晰地了解结构，我把这个残差单元的结构绘制出来，如下：</p><p><img src="resblock_body.jpg" alt="resblock_body 的结构图 (相对于 res_stage)"></p><p>对照代码和上面的图片，可以比较清晰地看出来这个 <strong>CSP 残差单元</strong>和 <strong>DarkNet/ResNet 的残差单元</strong>的区别了。</p><p>其中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DarknetConv2D_BN_Mish</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Darknet Convolution2D followed by BatchNormalization and LeakyReLU."""</span></span><br><span class="line">    no_bias_kwargs = &#123;<span class="string">'use_bias'</span>: <span class="keyword">False</span>&#125;</span><br><span class="line">    no_bias_kwargs.update(kwargs)</span><br><span class="line">    <span class="keyword">return</span> compose(</span><br><span class="line">        DarknetConv2D(*args, **no_bias_kwargs),</span><br><span class="line">        BatchNormalization(),</span><br><span class="line">        Mish())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DarknetConv2D</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Wrapper to set Darknet parameters for Convolution2D."""</span></span><br><span class="line">    darknet_conv_kwargs = &#123;&#125;</span><br><span class="line">    darknet_conv_kwargs[<span class="string">'kernel_initializer'</span>] = keras.initializers.RandomNormal(mean=<span class="number">0.0</span>, stddev=<span class="number">0.01</span>)</span><br><span class="line">    darknet_conv_kwargs[<span class="string">'padding'</span>] = <span class="string">'valid'</span> <span class="keyword">if</span> kwargs.get(<span class="string">'strides'</span>)==(<span class="number">2</span>,<span class="number">2</span>) <span class="keyword">else</span> <span class="string">'same'</span></span><br><span class="line">    darknet_conv_kwargs.update(kwargs)</span><br><span class="line">    <span class="keyword">return</span> Conv2D(*args, **darknet_conv_kwargs)</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><blockquote><p>在 YOLO V4 Keras 代码中，通常将 YOLO HEAD (图片上的橙色块）紧接在 SSP+PAN 后面。为了便于说明，这里我们根据总图上的 process1-5 与三个 YOLO HEAD, 对 SSP+PAN+YOLO HEAD 部分进行解析。</p><p><strong>其中 process1 的代码实现为</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(darknet.output)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">1024</span>, (<span class="number">3</span>,<span class="number">3</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(y19)</span><br><span class="line">maxpool1 = MaxPooling2D(pool_size=(<span class="number">13</span>,<span class="number">13</span>), strides=(<span class="number">1</span>,<span class="number">1</span>), padding=<span class="string">'same'</span>)(y19) <span class="comment">#（19，19）</span></span><br><span class="line">maxpool2 = MaxPooling2D(pool_size=(<span class="number">9</span>,<span class="number">9</span>), strides=(<span class="number">1</span>,<span class="number">1</span>), padding=<span class="string">'same'</span>)(y19) <span class="comment">#（19，19）</span></span><br><span class="line">maxpool3 = MaxPooling2D(pool_size=(<span class="number">5</span>,<span class="number">5</span>), strides=(<span class="number">1</span>,<span class="number">1</span>), padding=<span class="string">'same'</span>)(y19) <span class="comment">#（19，19）</span></span><br><span class="line">y19 = Concatenate()([maxpool1, maxpool2, maxpool3, y19])</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">1024</span>, (<span class="number">3</span>,<span class="number">3</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(y19)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>显而易见，该进程接受 CSPDarknet53 最终的输出，返回变量 <code>y19</code> (如总图上 process1 所示），这里我们也给出图示，如下：</p><p><img src="process1.jpg" alt="process 1"></p><p><strong>process2 代码如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">y19_upsample = compose(DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>)), UpSampling2D(<span class="number">2</span>))(y19)</span><br><span class="line"></span><br><span class="line"><span class="comment">#38x38 head</span></span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(darknet.layers[<span class="number">204</span>].output)</span><br><span class="line">y38 = Concatenate()([y38, y19_upsample])</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(y38)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>即先将上述的 <code>y19</code> 进行上采样至大小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>38</mn><mi>x</mi><mn>38</mn></mrow><annotation encoding="application/x-tex">38x38</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mord mathdefault">x</span><span class="mord">3</span><span class="mord">8</span></span></span></span>，然后再和 CSPDarknet53 的 <code>204</code> 层输出进行堆叠，最后通过一系列 DarknetConv2D_BN_Leaky 模块，获得特征图 <code>y38</code>。</p><p><strong>process3</strong></p><p>process3 的代码接受 <code>y_38</code> 上采样后的特征图 <code>y38_upsample</code> 以及 darknet 网络的第 <code>131</code> 层输出作为输入，从而获得特征图 <code>y_38</code>，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y38_upsample = compose(DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">1</span>,<span class="number">1</span>)), UpSampling2D(<span class="number">2</span>))(y38)</span><br><span class="line"></span><br><span class="line">y76 = DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">1</span>,<span class="number">1</span>))(darknet.layers[<span class="number">131</span>].output)</span><br><span class="line">y76 = Concatenate()([y76, y38_upsample])</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>YOLO HEAD 1</strong></p><p>紧接在 process3 之后，代码中使用简单的 5+2 层卷积层对上面的 <code>y76</code> 进行输出。其实这里的卷积层就是图中橙色区域 YOLO HEAD1 ,在后面的 <code>y38_output</code> 和 <code>y19_output</code> 的输出过程中仍能够看到。其中代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#YOLO HEAD 1</span></span><br><span class="line">y76 = DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">1</span>,<span class="number">1</span>))(y76)</span><br><span class="line">y76 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">3</span>,<span class="number">3</span>))(y76)</span><br><span class="line">y76 = DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">1</span>,<span class="number">1</span>))(y76)</span><br><span class="line">y76 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">3</span>,<span class="number">3</span>))(y76)</span><br><span class="line">y76 = DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">1</span>,<span class="number">1</span>))(y76)</span><br><span class="line"><span class="comment">#76x76 output</span></span><br><span class="line">y76_output = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">3</span>,<span class="number">3</span>))(y76)</span><br><span class="line">y76_output = DarknetConv2D(num_anchors*(num_classes+<span class="number">5</span>), (<span class="number">1</span>,<span class="number">1</span>))(y76_output)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>该网络最后使用 <code>1x1</code> 卷积输出最大的一张特征图 <code>y76_output</code>，维度为 <code>(76,76,num_anchor*(num_classes+5))</code>。对应结构图中最大的输出特征图（最右边的淡蓝色特征图）。</p><p><strong>process4 的代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#38x38 output</span></span><br><span class="line">y76_downsample = ZeroPadding2D(((<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)))(y76)</span><br><span class="line">y76_downsample = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">3</span>,<span class="number">3</span>), strides=(<span class="number">2</span>,<span class="number">2</span>))(y76_downsample)</span><br><span class="line">y38 = Concatenate()([y76_downsample, y38])</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这一步骤比较关键，PAN 和 FPN 的差异在于，<strong>FPN</strong> 是<strong>自顶向下</strong>的特征融合，<strong>PAN 在 FPN 的基础上</strong>，多了个<strong>自底向上</strong>的特征融合。具体自底向上的特征融合，就是 process4 完成的，可以看到该步骤先将 <code>y76</code> 下采样至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>38</mn><mi>x</mi><mn>38</mn></mrow><annotation encoding="application/x-tex">38x38</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mord mathdefault">x</span><span class="mord">3</span><span class="mord">8</span></span></span></span> 大小，再和 <code>y38</code> 堆叠，作为 YOLO HEAD2 的输入。</p><p><strong>YOLO HEAD 2</strong></p><p>类似于 YOLO HEAD 1, YOLO HEAD 2 也进行一系列卷积运算，获得维度大小为 <code>(38,38,num_anchor*(num_classes+5))</code> 的输出 <code>y38_output</code>，其中代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#YOLO HEAD 2</span></span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>))(y38)</span><br><span class="line">y38 = DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>))(y38)</span><br><span class="line"></span><br><span class="line">y38_output = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>))(y38)</span><br><span class="line">y38_output = DarknetConv2D(num_anchors*(num_classes+<span class="number">5</span>), (<span class="number">1</span>,<span class="number">1</span>))(y38_output)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>其中process4和YOLO HEAD2如下图所示。</p><p><img src="head2.jpg" alt="process4 和 yolo head2 的流程"></p><p><strong>Process 5代码如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#19x19 output</span></span><br><span class="line">y38_downsample = ZeroPadding2D(((<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)))(y38)</span><br><span class="line">y38_downsample = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>), strides=(<span class="number">2</span>,<span class="number">2</span>))(y38_downsample)</span><br><span class="line">y19 = Concatenate()([y38_downsample, y19])</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Process 5 和 process 4 进程类似，不多赘述。后面接上 YOLO HEAD 3。</p><p><strong>YOLO HEAD 3</strong></p><p>和 YOLO HEAD 1 以及 YOLO HEAD 2 定义几乎类似，YOLO HEAD 3 定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">1024</span>, (<span class="number">3</span>,<span class="number">3</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">1024</span>, (<span class="number">3</span>,<span class="number">3</span>))(y19)</span><br><span class="line">y19 = DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">1</span>,<span class="number">1</span>))(y19)</span><br><span class="line"></span><br><span class="line">y19_output = DarknetConv2D_BN_Leaky(<span class="number">1024</span>, (<span class="number">3</span>,<span class="number">3</span>))(y19)</span><br><span class="line">y19_output = DarknetConv2D(num_anchors*(num_classes+<span class="number">5</span>), (<span class="number">1</span>,<span class="number">1</span>))(y19_output)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>YOLO HEAD 3 输出为 <code>(19,19,num_anchor*(num_classes+5))</code> 的特征图 <code>y19_output</code>.</p></blockquote><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><ul><li><a href="https://jonathan-hui.medium.com/yolov4-c9901eaa8e61" target="_blank" rel="noopener">YOLOv4</a></li><li><a href="https://zhuanlan.zhihu.com/p/138510087" target="_blank" rel="noopener">YOLOv4</a></li><li><a href="https://blog.csdn.net/qq_48984174/article/details/111680645?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">CSPDarkNet53学习</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录了关于 yolo v4 的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="目标检测" scheme="https://taosean.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="yolo" scheme="https://taosean.github.io/tags/yolo/"/>
    
      <category term="CSP" scheme="https://taosean.github.io/tags/CSP/"/>
    
      <category term="SPP" scheme="https://taosean.github.io/tags/SPP/"/>
    
      <category term="PAN" scheme="https://taosean.github.io/tags/PAN/"/>
    
      <category term="CutMix" scheme="https://taosean.github.io/tags/CutMix/"/>
    
      <category term="数据增强" scheme="https://taosean.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA/"/>
    
      <category term="DropBlock" scheme="https://taosean.github.io/tags/DropBlock/"/>
    
      <category term="GIoU" scheme="https://taosean.github.io/tags/GIoU/"/>
    
      <category term="DIoU" scheme="https://taosean.github.io/tags/DIoU/"/>
    
      <category term="CIoU" scheme="https://taosean.github.io/tags/CIoU/"/>
    
  </entry>
  
  <entry>
    <title>Making Convolutional Networks Shift-Invariant Again</title>
    <link href="https://taosean.github.io//2021/03/19/Make-CNN-shift-invariant-again/"/>
    <id>https://taosean.github.io//2021/03/19/Make-CNN-shift-invariant-again/</id>
    <published>2021-03-19T09:37:02.000Z</published>
    <updated>2021-03-22T07:11:09.045Z</updated>
    
    <content type="html"><![CDATA[<p>本文讨论了关于下采样所带来的平移等变性被破坏的情况，并提出通过整合经典的抗锯齿操作来提升网络的平移等变性，进而提升平移不变性。(在后面的层中，平移不变性等于平移等变性)</p><br><a id="more"></a><blockquote><p>这文章通篇证明了一件事：<strong>CNN 下采样导致的混叠会降低性能</strong>(之前也有文章说过)，我们建议在下采样之前加低通滤波。<br>文章的工作量很大，尤其是在很多应用方向都做了实验，说明了<strong>移不变的CNN可以在相关方向获得更好的性能</strong>。<br><a href="https://www.zhihu.com/question/329025043/answer/720840077" target="_blank" rel="noopener"><font color="purple">2019 年 ICML 有哪些糟糕的论文？ - SuperMHP的回答 - </font></a></p></blockquote><br><blockquote><p>先解释两个概念 平移不变性：指的是输入平移一定距离，最终的结果不变，分类里面就是分类的概率结果是不变的。 平移同变性：指的是输入平移一定距离，其对应的 feature 也做同样的平移。 本文主要是针对特征的平移同变性去解决问题，而<strong>实际上实现了特征的平移同变形，后面接的是 fc 层，最后一层的平移不变性是等价于平移同变性的，所以实现了特征的平移同变性就是实现了整个网络输出的平移不变性</strong>。例如，vgg 网络的最后两层是 fc 层和 softmax，显然 fc 层的 spatial dim 只有唯一一个元素(高维向量)，所以平移不变性和平移等变性在这一层是等价的。<br><a href="https://my.oschina.net/u/4357035/blog/3313711" target="_blank" rel="noopener"><font color="purple"> [论文理解] Making Convolutional Networks Shift-Invariant Again</font></a></p></blockquote><br><h1 id="0-abstract"><a class="markdownIt-Anchor" href="#0-abstract"></a> 0. Abstract</h1><ol><li>现代 CNN 没有移不变性，输入的很小的平移都可能造成输出的剧烈变化。</li><li>Pooling 和步长大于1的卷积等下采样手段，忽略了采样定理。<blockquote><p>个人理解这句话的意思是：pooling 和 strided-convolution 后的结果，不满足奈奎斯特采样定理，即输入频率较高，采样频率太低，造成信息损失很大。</p></blockquote></li><li>不能简单地在网络结构中插入低通滤波。</li></ol><br><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><ol><li>在对信号下采样前，对信号进行低通滤波来抗锯齿是教科书式的操作。</li><li>否则，高频分量会混叠进低频分量。（因为不满足采样定理）</li><li>早期网络采用的 average pooling 是一种形式的模糊后下采样。</li><li>经过观察，我们把 max pooling 分成 max 和 pooling 两步。</li><li>有一种担忧是，过度使用滤波会造成严重的信息损失，降低性能。</li><li>本文具体操作<ol><li>整合经典的抗锯齿操作来提高深度网络的<strong>平移等变性</strong>。</li><li>在不同网络结构上测试了 max pooling，average pooling, 带步长卷积 等下采样操作，并在不同任务上进行了测试。</li><li>发现增加了抗锯齿操作后，accuracy 不降反升，且泛化性能也更好了。</li></ol></li></ol><br><h1 id="2-related-work"><a class="markdownIt-Anchor" href="#2-related-work"></a> 2. Related Work</h1><ol><li>近来很多工作涉及了旋转，光照和尺度的不变性，这里我们专注于平移不变性。</li><li>Simioncelli 等人的工作认为，进行下采样时，严格意义的平移等变性 (shift-equivariance) 是不成立的。<ol><li>当特征被 densely extracted 时，平移等变性是可被恢复的。(意思是采样频率够高？)</li><li>深度网络也可以通过去除 stride 来达到 dense 的效果，但这会使计算量剧增，不合适。</li><li>因此，本文研究通过<strong>在下采样之前进行模糊</strong>的方法来提高平移等变性。</li></ol></li><li>早期网络是使用 average pooling 的，但是后来由于 max pooling 的效果更好，因此 max pooling 更流行。</li></ol><br><h1 id="3-methods"><a class="markdownIt-Anchor" href="#3-methods"></a> 3. Methods</h1><h2 id="31-preliminaries"><a class="markdownIt-Anchor" href="#31-preliminaries"></a> 3.1. Preliminaries</h2><ol><li>N-周期 平移不变性/等变性</li><li>环状卷积和平移来获取边界的内容。</li></ol><br><h2 id="32-anti-aliasing-to-improve-shift-equivariance"><a class="markdownIt-Anchor" href="#32-anti-aliasing-to-improve-shift-equivariance"></a> 3.2 Anti-aliasing to improve shift-equivariance</h2><ol><li>传统的降低空间分辨率的方法都会打破平移等变性。</li><li>将 max pooling 拆解为 max 和 pooling 两步操作。<ol><li>max 保留了 平移等变性。</li><li>后续 pooling 破坏了平移等变性。</li></ol></li><li>提出<ol><li>MaxPool -&gt; MaxBlurPool</li><li>StridedConv -&gt; ConvBlurPool</li><li>AveragePool -&gt; BlurPool</li></ol></li></ol><br><h1 id="4-experiments"><a class="markdownIt-Anchor" href="#4-experiments"></a> 4. Experiments</h1><h2 id="41-testbeds"><a class="markdownIt-Anchor" href="#41-testbeds"></a> 4.1. Testbeds</h2><ul><li>CIFAR Classification</li><li>ImageNet Classification</li><li>Conditional Image Generation</li></ul><br><h2 id="42-shift-invarianceequivariance-metrics"><a class="markdownIt-Anchor" href="#42-shift-invarianceequivariance-metrics"></a> 4.2. Shift-Invariance/Equivariance Metrics</h2><p>理想情况下，输入的偏移会导致特征图的相同偏移。评价指标为：</p><ul><li><strong>Internal feature distance.</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>S</mi><mi>h</mi><mi>i</mi><mi>f</mi><msub><mi>t</mi><mrow><mi>Δ</mi><mi>h</mi><mo separator="true">,</mo><mi>Δ</mi><mi>w</mi></mrow></msub><mo stretchy="false">(</mo><mover accent="true"><mi>F</mi><mo stretchy="true">~</mo></mover><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mover accent="true"><mi>F</mi><mo stretchy="true">~</mo></mover><mo stretchy="false">(</mo><mi>S</mi><mi>h</mi><mi>i</mi><mi>f</mi><msub><mi>t</mi><mrow><mi>Δ</mi><mi>h</mi><mo separator="true">,</mo><mi>Δ</mi><mi>w</mi></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it d(Shift_{\Delta{h},\Delta{w}}(\widetilde{F}(X)),  \widetilde{F}(Shift_{\Delta{h},\Delta{w}}(X)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.229438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">S</span><span class="mord mathit">h</span><span class="mord mathit">i</span><span class="mord mathit">f</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">Δ</span><span class="mord mtight"><span class="mord mathit mtight">h</span></span><span class="mpunct mtight">,</span><span class="mord mathit mtight">Δ</span><span class="mord mtight"><span class="mord mathit mtight">w</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94333em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">F</span></span></span><span class="svg-align" style="top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width="100%" height="0.26em" viewbox="0 0 600 260" preserveaspectratio="none"><path d="M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z"/></svg></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">X</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94333em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">F</span></span></span><span class="svg-align" style="top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width="100%" height="0.26em" viewbox="0 0 600 260" preserveaspectratio="none"><path d="M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z"/></svg></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">S</span><span class="mord mathit">h</span><span class="mord mathit">i</span><span class="mord mathit">f</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">Δ</span><span class="mord mtight"><span class="mord mathit mtight">h</span></span><span class="mpunct mtight">,</span><span class="mord mathit mtight">Δ</span><span class="mord mtight"><span class="mord mathit mtight">w</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">X</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></li><li><strong>Classification consistency</strong>: 同一张图做两种平移，输出同样结果的频率。</li><li><strong>Generation stability.</strong></li></ul><br><h2 id="43-internal-shift-equivariance"><a class="markdownIt-Anchor" href="#43-internal-shift-equivariance"></a> 4.3. Internal shift-equivariance</h2><p><img src="heatmap.png" alt="与完美平移不变性的偏差"></p><ul><li>内部特征距离被看作偏移量和层数的函数。</li><li>在第一次下采样 <code>max1</code> 前的所有层，都是平移等变的，一旦发生下采样 <code>pool1</code>，平移等变性就被破坏了。</li><li>但是，如 <code>pool1</code> 中的 stippling pattern 所示，N-周期的平移不变性仍然成立，且每下采样一次，N 翻番一次。</li><li>heatmap 中的每个像素代表一个偏移 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Δ</mi><mi>h</mi><mo separator="true">,</mo><mi>Δ</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\it \Delta{h}, \Delta{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathit">Δ</span><span class="mord"><span class="mord mathit">h</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">Δ</span><span class="mord"><span class="mord mathit">w</span></span></span></span></span></span></li><li>在 pool5, 分类器和 softmax 层中，等变性和不变性是一个东西，因为特征没有空间维度。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讨论了关于下采样所带来的平移等变性被破坏的情况，并提出通过整合经典的抗锯齿操作来提升网络的平移等变性，进而提升平移不变性。(在后面的层中，平移不变性等于平移等变性)&lt;/p&gt;
&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>How much Position Information Do Convolutional Neural Networks Encode?</title>
    <link href="https://taosean.github.io//2021/03/19/Position-information-CNN-encode/"/>
    <id>https://taosean.github.io//2021/03/19/Position-information-CNN-encode/</id>
    <published>2021-03-19T07:03:19.000Z</published>
    <updated>2021-03-29T02:03:38.525Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录了关于论文 How much Position Information Do Convolutional Neural Networks Encode? 所表达的内容。</p><a id="more"></a><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/99766566" target="_blank" rel="noopener">CNN是怎么学到图片内的绝对位置信息的?</a></p><p>[2] <a href="https://zhuanlan.zhihu.com/p/265801525" target="_blank" rel="noopener">[论文分享]CNN中编码了多少位置信息？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录了关于论文 How much Position Information Do Convolutional Neural Networks Encode? 所表达的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="position" scheme="https://taosean.github.io/tags/position/"/>
    
      <category term="CNN" scheme="https://taosean.github.io/tags/CNN/"/>
    
      <category term="zero padding" scheme="https://taosean.github.io/tags/zero-padding/"/>
    
      <category term="CoordConv" scheme="https://taosean.github.io/tags/CoordConv/"/>
    
  </entry>
  
  <entry>
    <title>Why do deep convolutional networks generalize so poorly to small image transformations</title>
    <link href="https://taosean.github.io//2021/03/19/CNN-generalize-poorly/"/>
    <id>https://taosean.github.io//2021/03/19/CNN-generalize-poorly/</id>
    <published>2021-03-19T05:50:18.000Z</published>
    <updated>2021-03-24T06:20:59.734Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录了关于论文 Why do deep convolutional networks generalize so poorly to small image transformations 所表达的内容。</p><a id="more"></a><blockquote><p>这篇文章实在是太难读了，看着非常不舒服！</p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/301522740/answer/531606623" target="_blank" rel="noopener"><font color="purple">既然cnn对图像具有平移不变性，那么利用 图像平移（shift）进行数据增强来训练cnn会有效果吗？ - Hengkai Guo的回答 - 知乎</font></a></p><p>首先，解释一下什么是CNN的<strong>平移不变性</strong>。简单来说，平移不变性（translation invariant）指的是CNN对于同一张图及其平移后的版本，都能输出同样的结果。这对于图像分类（image classification）问题来说肯定是最理想的，因为对于一个物体的平移并不应该改变它的类别。而对于其它问题，比如物体检测（detection）、物体分割（segmentation）来说，这个性质则不应该有，原因是当输入发生平移时，输出也应该相应地进行平移。这种性质又称为<strong>平移等价性</strong>（translation equivalence）。这两个概念是比较混淆的，但确实是两个不同的东西（敲黑板）。</p><p>那么，平移不变性是从哪里来的呢？一般来说，一个 CNN 的性质，要么是从它本身使用的<strong>结构</strong>得到的，要么是从它在数据集中学到的<strong>参数</strong>得到的。前者的简单例子是加了 sigmoid 层的网络的输出范围自然变成了<code>0</code>到<code>1</code>之间，后者的例子则是 CNN 在 ImageNet 上训练之后就有了能分类图像的能力且特征也具有一定的泛化性。</p><p>CNN 比较常见的层有卷积层、池化层（max 或者 mean）、全连接层，其中池化层又包括普通池化层和用在全连接层之前的全局池化层（global pooling）。按照市面上最常见的观点，CNN 本身结构中卷积+池化就具有平移不变性。本人并不同意这个观点，下面具体分析一下。</p><p>先来分析单层的情况。</p><p>(1) 卷积层：在信号处理中，卷积（以及相关）的性质包含了平移等价性。对于共享权值的卷积层来说，只在平移量为 stride 的整数倍时平移等价性才严格成立。而仅仅在卷积核比较均匀而且输入也有很多均匀区域的时候才有比较弱的平移不变性，因为此时微小的移动对于输出改变比较少。</p><p>(2) 池化层：普通池化层中，均值池化等价于固定卷积核的卷积层，因此性质也相同；最大值池化也类似，但取最大值的操作使其相对于均值带有更强的平移不变性。全局池化层将整个输入变成 <code>1x1</code> 大小的输出，忽略了特征的位置信息，当前面的输入具有平移等价性的时候具有比较强的平移不变性。</p><p>(3) 全连接层：全连接层这两个性质都没有，因为没有在不同位置共享权值，特征在不同位置对于输出的贡献变化很大。因此，从单层来看，只有全局池化有一定的平移不变性，其它都比较弱甚至没有。</p><p>如果把这些层串起来，那么在使用全连接层的时候整个CNN的结构一般不具有平移不变性。就算用了全局池化层，由于前面叠加的多层卷积层的累计效应，最后的平移不变性也很弱，只有当<strong>位移是整个网络的降采样倍数的整数倍</strong>才存在，概率很低。因此，能用于分类的平移不变性主要来源于参数。因为卷积层的平移等价性，这种平移不变性主要是由最后的全连接层来学习，而对于没有全连接层的网络更难有这种性质。</p><p>参数的学习需要数据，由于数据中平移的分布一般都比较不均匀，引入平移的数据增强（augmentation）肯定是必要的。那有人会问，为什么好像没看到有这个增强方式？其实裁切（crop）就是一种平移的数据增强方式，因为不同裁切方式对应的patch之间的变换就是平移。而且这种方式相比于平移更加自然，没有周围的黑边padding，因此更加常用。</p><p>总结起来，就是 <strong>CNN 的平移不变性主要是通过数据学习来的</strong>，结构只能带来非常弱的平移不变性，而学习又依赖于数据增强中的裁切，裁切相当于一种更好的图像平移。</p><p>最后再说点题外话。正是因为池化本身带有弱的平移不变性，且会损失一些信息，在对平移需要等价性的一些任务里（比如检测、分割）会经常用 stride 为 <code>2</code> 的卷积层来替代池化层。而在很多分类任务中，为了学习到一些全局特征，常常会在网络的最后使用全局池化或者金字塔池化的方式来消除平移的影响。</p></blockquote><br><h1 id="0-abstract"><a class="markdownIt-Anchor" href="#0-abstract"></a> 0. Abstract</h1><ul><li>以前以为 CNN 对小的图像变形具有不变性（结构或者数据增强的原因），但事实并非如此。</li><li>讨论了两种解决办法：<ul><li>Anti-alisaing</li><li>增加数据增强</li></ul></li><li>数据增强不会带来不变性，因为 CNN 只会学到对与数据集中非常相似的图的不变性。</li><li>结果表明，在保留高频信息的情况下，确保网络对小的变换的不变性的问题仍然没有得到解决。</li></ul><br><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><ul><li>机器学习方法的 <font color="purple" size="3"> <strong>归纳偏置</strong> </font> 是其成功的关键。</li><li>很显然，NN 中架构的选取对归纳偏置有重大影响。</li><li>归纳偏置的另一个来源是数据增强。</li><li>感觉，所谓归纳偏置，就是<strong>从现实生活中观察到的现象中归纳出一定的规则（heuristics） ，选择出更符合现实规则的模型。</strong></li><li>归纳偏置的一个来源就是<strong>网络的结构设计</strong>，卷积，池化的设计方式本身就引入了归纳偏置。比如卷积的局部链接和权值共享。</li><li>归纳偏置的另一个来源就是<strong>数据增强</strong>。通过剪切等变换处理过的图片就是告诉网络，发生了这些变换的图片依旧是与之前同一类别。</li></ul><br><h1 id="2-quantifying-the-lack-of-invariance-in-modern-cnns"><a class="markdownIt-Anchor" href="#2-quantifying-the-lack-of-invariance-in-modern-cnns"></a> 2. Quantifying the lack of invariance in modern CNNs</h1><p>基础实验：<br>从ImageNet测试集中随机选取一张图片，用四种方式对图片进行一个像素的扰动，测量网络的敏感程度。</p><ul><li>敏感程度的测量使用两种方法：<ul><li>P(Top-1 change): 一像素扰动后网络top-1预测发生改变的概率。<ul><li>它对网络最后一层输出的任何单调性变形都具有不变性。</li></ul></li><li>mean absolute change: 最高类别（即在两帧的第一帧中具有最高概率的类别）在发生一像素扰动后，网络计算出的概率的平均绝对变化。<ul><li>这个 metric 的作用是排除 top-1 预测的变化是由最可能类别和此可能类别之间的微小差别造成的可能性。</li></ul></li></ul></li><li>四种方式：<ul><li>在图像中随机截取一个框再 resize 到 224x224。再进行一个像素的对角线平移</li><li>embedding: 保持长宽比降采样到短边尺寸为 <code>100</code>，再随机嵌入到 224x224 图像中的随机位置，空余用黑色像素填充。再进行一个像素平移</li><li>类似第二种方法，但是用图像修复算法补全空余部分。</li><li>类似第二种方法，增大被嵌入图像一个像素单位。</li><li>优劣势：<ul><li>第一种方法可能导致重要信息丢失，平移后边缘信息会有区别。</li><li>第二种方法虽然保留了所有信息，但是可能引入非典型边界像素。</li></ul></li><li>带来的细微变化都是人类无法感知到的、可辨识度没有变化</li><li>景观变化是人类难以感知的，但模型预测类别变化的概率可以达到 <code>30%</code>，故此前论文中关于CNN缺乏不变性的报告不是偶然而是有着很高的出现频率。</li></ul></li><li>对于此结果的质疑可以是这些变换的图像在训练集中没有见过。引出两个对不变性的定义<ul><li>完全不变性：对任何模式以及其变换的形式输出相同的结果</li><li>部分不变性：在某种模式或与其类似的模式在训练集中出现的前提下，输出相同的结果。</li></ul></li><li>实验结果指明 CNN 并不具有完全不变性。</li></ul><br><h1 id="3-ignoring-the-sampling-theorem"><a class="markdownIt-Anchor" href="#3-ignoring-the-sampling-theorem"></a> 3. Ignoring the Sampling Theorem</h1><ul><li>Stride 永远是 1 的 CNN 是平移不变的.</li><li>如果对任何<code>x</code>来说，检测器在<code>x</code>位置的输出都可以被下采样网格中的响应线性插值恢复的话，那么下采样参数为<code>s</code>的特征检测器<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>可以被称为 shiftable.</li><li>VGG16 网络，表征向量似乎是跟随物体一起偏移的，包括最后一层。即使随后一层不是简单的原来响应的偏移，但是似乎是保留了这张图的全局和。</li></ul><p><img src="vgg.png" alt="vgg"></p><ul><li>当基于早期的层训练分类器时，一个像素的偏移导致输出改变的概率低于<code>5%</code>，但是当层数越来越深时，下采样操作和非线性会使得表征不再 shiftable, 网络也丢失了不变性。</li></ul><p><img src="depth.png" alt="不同深度的层由于像素偏移造成的输出改变"></p><ul><li>非线性操作可能带来输入中所不具有的高频</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathit">r</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span> 是先下采样（采样率<code>s</code>），然后经过一系列卷积和非线性操作的结果。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn mathvariant="italic">2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r_2(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathit">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span> 是不下采样，直接进行同样的卷积和非线性操作（所有的卷积核都是空洞率为 <code>s</code>）。对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn mathvariant="italic">2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r_2(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathit">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span> 下采样（采样率为<code>s</code>）得到的结果就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></li><li>对 CNN 中一个 stride 为 <code>s</code> 的层，对任何后面的层，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathit">r</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span>, 试想一个等价于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn mathvariant="italic">2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r_2(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathit">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span> 的层，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn mathvariant="italic">2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r_2(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathit">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span> 包含超过奈奎斯特频率 <code>s</code> 的频率，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\it r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathit">r</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span> 则不是 shiftable 的。</li></ul><br><h1 id="4-why-dont-modern-cnns-learn-to-be-invariant-from-data-augmentation"><a class="markdownIt-Anchor" href="#4-why-dont-modern-cnns-learn-to-be-invariant-from-data-augmentation"></a> 4. Why don’t modern CNNs learn to be invariant from data augmentation?</h1><ul><li>CNN的结构不能带来平移不变性，但是通过训练样本来学习到平移不变性还是有可能的。</li><li>这可以通过网络学习到能量集中在低频的 filter 来实现。</li><li>使用数据增强训练得到这样的 filter 是可以期待的。</li><li>数据增强使用了很多随机 crop 的图像，所以网络有同样的概率看到一张图以及它的平移一个像素的版本。为什么这样不能使得网络学到一个对一个像素偏移具有不变性的判别函数呢？<ul><li>一个可能的原因是网络只能学到对数据集里存在的图的不变性。网络的泛化性能可能只能泛化到跟训练集里图像比较相似的图像。</li></ul></li><li>如果CNN中大多数的平移不变性是网络在训练时学到的<strong>部分平移不变性</strong>的话，那么网络对大的嵌入图像应该更平移不变，对小的嵌入图像不那么平移不变。图6证实了这点</li></ul><p><img src="embedding.png" alt="不同embedding window size造成的不同程度的不变性"></p><br><h1 id="5-possible-solutions"><a class="markdownIt-Anchor" href="#5-possible-solutions"></a> 5. Possible Solutions</h1><h2 id="51-antialiasing"><a class="markdownIt-Anchor" href="#51-antialiasing"></a> 5.1 Antialiasing</h2><h2 id="52-increased-data-augmentation"><a class="markdownIt-Anchor" href="#52-increased-data-augmentation"></a> 5.2 Increased Data Augmentation</h2><h2 id="53-reducing-subsampling"><a class="markdownIt-Anchor" href="#53-reducing-subsampling"></a> 5.3 Reducing subsampling</h2><br><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/50222337" target="_blank" rel="noopener">难以泛化的卷积神经网络</a></p><p>[2] <a href="https://lossherl.github.io/2020/04/28/2019%20Why%20do%20deep%20convolutional%20networks%20generalize%20so%20poorly%20to%20small%20image%20transformation/" target="_blank" rel="noopener">Why do deep convolutional networks generalize so poorly to small image transformation?</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录了关于论文 Why do deep convolutional networks generalize so poorly to small image transformations 所表达的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="generalize" scheme="https://taosean.github.io/tags/generalize/"/>
    
      <category term="transformation" scheme="https://taosean.github.io/tags/transformation/"/>
    
  </entry>
  
  <entry>
    <title>【转载】谈谈CNN中的位置和尺度问题</title>
    <link href="https://taosean.github.io//2021/03/18/Location-and-scale-in-CNN/"/>
    <id>https://taosean.github.io//2021/03/18/Location-and-scale-in-CNN/</id>
    <published>2021-03-18T12:10:01.000Z</published>
    <updated>2021-03-30T07:14:52.715Z</updated>
    
    <content type="html"><![CDATA[<p>在知乎上看到一篇关于 CNN 的平移不变性和平移等变性以及 CNN 对位置和深度信息预测的文章，觉得很有收获，因此转载在这里。里面也会穿插自己的理解。</p><a id="more"></a><p><strong>提示：</strong><br>转载文章中与不变性同时提到的 相等性（equivalence）其实是作者的错误，在图像中，一般同时出现的是 不变性(invariance) 和 等变性(equivariance)。而不是这里所说的相等性(equivalence)。</p><p><strong>个人总结:</strong></p><blockquote><ul><li>Making Convolutional Networks Shift-Invariant Again:<ul><li>窗户实验表明<strong>传统的CNN网络并不具有平移不变性</strong>。</li><li>Max pooling 及 <code>stride&gt;1</code> 的卷积等操作涉及下采样，此操作对平移等变性影响更大。</li><li>提出 Anti aliasing 方法，在下采样前进行 blur 操作，即进行低通滤波，降低输入内容的频率。</li></ul></li><li>Why do deep convolutional networks generalize so poorly to small image transformations：<ul><li>作者发现<ul><li>较小的图像变换或缩放导致网络的预测结果变换极大。</li></ul></li><li>作者认为<ul><li>卷积架构忽视了传统的采样定理。</li><li>数据增强仅能让CNN对类似训练集中的变换具有不变性。</li></ul></li></ul></li><li>How much Position Information Do Convolutional Neural Networks Encode <a href="//2021/03/19/Position-information-CNN-encode/" title="详细内容">详细内容</a><br>提出结论<ul><li>位置信息是 zero-padding 透露的</li></ul></li><li>How Do Neural Networks See Depth in Single Images<br>实验发现<ul><li>CNN 网络是通过目标纵坐标来估计深度的</li><li>由于深度与目标纵坐标有关系，那么 pitch 角的影响很大</li><li>相对的，roll 的影响就比较小了</li></ul></li><li>On Translation Invariance in CNNs: Convolutional Layers can Exploit Absolute Spatial Location</li></ul></blockquote><br>以下为正文：<br><h1 id="1-cnn是否存在平移和尺度的不变性和相等性"><a class="markdownIt-Anchor" href="#1-cnn是否存在平移和尺度的不变性和相等性"></a> 1. CNN是否存在平移和尺度的不变性和相等性</h1><h2 id="11-不变性和相等性的定义"><a class="markdownIt-Anchor" href="#11-不变性和相等性的定义"></a> 1.1 不变性和相等性的定义</h2><p>在介绍卷积神经网络（CNN）之前，我们对于不变性和相等性的理解可能来自于传统图像处理算法中的，平移、旋转、光照和尺度等不变性，比如 HOG 梯度方向直方图，由于<code>cell</code>的存在，其对于平移、旋转有一定的不变性，另外由于对图像局部对比度归一化的操作，使其对于光照也有着一定的不变性。又比如说 SIFT 特征提取，其对于以上四点都有着不变性，其中由于尺度金字塔，使得对尺度也有不变性。这里我们对于不变性的理解就是，同一对象发生平移、旋转、光照变化、尺度变换甚至形变等，其属性应该一致。下面我们给出具体的不变性和相等性的定义。</p><p>其中不变性（invariance）的定义正如上文所说，因此其形式为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">[</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F(x)=F[transform(x)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p><p>而对于相等性（equivalence），顾名思义，就是对输入进行变换之后，输出也发生相应的变换：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mo stretchy="false">[</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mi>F</mi><mo stretchy="false">[</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">transform[F(x)]=F[transform(x)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p><p>不过如果我们只考虑输出对于输入不变性和相等性的情况，则会难以理解，因为我们更多地是想象着特征层面的映射，比如：</p><p><img src="invariance-equivalence.jpg" alt="不变性和等变性"></p><p>那么特征层面对于输出的影响我们可能考虑得比较少，但是却实质存在，比如目标在图像中的平移和尺度等变换，<strong>在目标检测任务中，必须要使得网络具有相关的变换相等性，由此捕捉目标的位置和形状变化</strong>。<strong>而在图像分类、目标识别、行人重识别等任务中，又必须使得网络具有相关变换的不变性</strong>。这两点也是目标检测和行人检索领域中一个经典的矛盾问题，目前好像还没有特别好的解决，更多地是分阶段地执行不同的任务，防止特征共用。比如：经典的两阶段目标检测任务中，第一阶段是粗检测和前景背景分类，第二阶段是精修和具体类别分类，有一定的偏重。行人检索算法则大多是先检测后识别的策略。当然除了不变性和相等性的问题，还存在类内差异的问题，比如不同的人对于检测而言都是行人类别，对于识别而言则是不同的人，这对于特征提取也存在挑战。</p><blockquote><p><font color="orange">这部分观点应该是来自 DCNv2 </font></p></blockquote><br><h2 id="12-cnn网络的执行过程"><a class="markdownIt-Anchor" href="#12-cnn网络的执行过程"></a> 1.2 CNN网络的执行过程</h2><p>我记得我几年前第一次接触到深度学习的时候，对于全连接和 CNN 的局部连接形式，都有平移、尺度不变性的说法。对于全连接网络，由于下一层的每个节点都会与上一层进行连接：</p><p><img src="fc.jpg" alt="全连接网络"></p><p>因此无论输入发生了平移、尺度等什么变换，只要其属性没变，全连接网络更能捕捉其中的不变性。而对于卷积神经网络，我们都知道两个特点：局部连接和权值共享。</p><p><img src="cnn.jpg" alt="卷积神经网络和全连接网络对比"></p><p>对于局部连接，因为全连接参数太多，容易造成过拟合，并且图像领域更多地关注局部细节信息，所以局部连接方式有效。至于权值共享，也有减少参数的作用，很像图像处理中的滤波器。我们早期对于其不变性的理解更多是遵循一个宏观的感受，即由于卷积核的移位滤波，上一层的特征到下一层的特征相对位置 <strong>宏观不变</strong>，直到最后输出，类似于全连接的效果，从而获得不变性。</p><br><h2 id="13-cnn网络潜在问题与改进"><a class="markdownIt-Anchor" href="#13-cnn网络潜在问题与改进"></a> 1.3 CNN网络潜在问题与改进</h2><p>正因为我刚说的宏观不变，使得输入在经过多次卷积、池化之后，微观/细节的变化累积放大，从而失去了这种不变性，接下来我会结合两篇论文进行介绍。</p><p>第一个是为了解决 CNN 平移不变性对抗性攻击的一篇 ICML2019 论文《<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1904.11486.pdf%3Ffbclid%3DIwAR1VRPIrctulC6EhTAhKFjIFrlx_JjKR09JnESzLELUnlTL40iOT5tYwotA" target="_blank" rel="noopener">Making Convolutional Networks Shift-Invariant Again</a>》。这篇文章主要讨论了CNN网络中的降采样对于平移不变性的影响：</p><p><img src="window1.jpg" alt=""></p><p>上图是对于一个窗户分别采用从<code>0~7</code>的平移量，其特征图与不平移的差异，可以明显看到，特征图出现了波动。相应地，上半部分是利用 pix2pix 生成的图像，我们可以看到随着平移量的增大，窗户中的竖直线从两根变成了一根。<font color="red"> <strong>这一点就表明传统的 CNN 网络并不具有平移不变性。</strong></font></p><p>首先，作者做了这样一个小实验，即采用 max pooling 对一维向量<code>[0011001100]</code>进行池化，由此得到向量<code>[01010]</code>：</p><p><img src="experiment.jpg" alt="小实验"></p><p>接着，如果将输入向右平移一个单位，则得到向量<code>[111111]</code>：</p><p><img src="res.jpg" alt="小实验结果"></p><p>很明显，<strong>平移相等性和不变性都丢失了</strong>。接着作者做了进一步实验，利用余弦距离来刻画平移相等性，采用 VGG 网络对 Cifar 数据集进行试验：</p><p><img src="experiment2.jpg" alt=""></p><p>其中颜色越深说明差异越大，可以看到每次 max pooling 都增加了特征的差异性，不过作者将 max 和 pool 操作分开了，为了区分取最大值和降采样的影响：</p><p><img src="maxpooling.jpg" alt=""></p><p>很明显，<strong>降采样对于平移相等性的影响更大</strong>，而 CNN 中涉及到降采样的操作有：池化（max pooling 和 average pooling）和带步长的卷积（strided convolution）。对此作者提出了一种名为 <strong>Anti_aliasing</strong> 方法，中文叫做抗锯齿处理。传统信号处理领域中对于抗锯齿的技术，一般要么增大采样频率，但由于图像处理任务一般都需要降采样，这一点不适合。要么采用图像模糊（bluring）技术，<font color="orange"><em>根据 Nyquist 采样理论，是给定采样频率，通过降低原始信号的频率来使得信号能够被重构出来</em> </font>，如下图所示。对模糊化处理和未处理的原图像进行下采样，得到图中底部的两张图，模糊化处理的原图像下采样的图像还能看出一些轮廓，而未处理的原图像下采样的图像就显得更加混乱。</p><blockquote><p><font color="orange"><strong>对橙色部分的理解：</strong></font> 在信号处理中，根据 奈奎斯特 采样定理，如果采样频率大于信号最大频率的两倍，则原始信号能够被完全恢复出来。在这里，pooling 就是一种下采样的过程，当其参数固定后，相当于其采样频率也是固定的。在原图中，有很多边缘等细节，属于高频内容。因此，如果直接对其进行 pooling，也就是下采样，则采样频率无法达到原图最大频率的两倍，从而无法恢复出原图内容。这时，可以逆向思维，通过降低原图的频率，则相对地提高了 pooling 的采样频率。因此，先对原图进行一次低通滤波，也就是模糊处理，来降低它的频率，这样，经过 pooling 下采样后的图像就相对原图下采样的结果可理解了很多。<br>关于图像滤波的内容，可以参考 <a href="//2021/03/18/Image-and-Filtering/" title="【转载】图像与滤波">【转载】图像与滤波</a></p></blockquote><p><img src="blur.jpg" alt="原图下采样和模糊后图像下采样对比"></p><p>作者就是采用了模糊的方式，提出了三种不同的 blur kernel：</p><ul><li>Rectangle-2：<code>[1, 1]</code>，类似于均值池化和最近邻插值；</li><li>Triangle-2：<code>[1, 2, 1]</code>，类似于双线性插值；</li><li>Binomial-5：<code>[1, 4, 6, 4, 1]</code>，这个被用在拉普拉斯金字塔中。</li></ul><p>每个核都需要归一化，即除以核内所有元素之和，然后加入到降采样过程，即在降采样之前使用 blur kernel 进行卷积滤波：</p><p><img src="aa.jpg" alt=""></p><p>可以看到其效果很不错：</p><p><img src="res1.jpg" alt="实验效果"></p><p><img src="table1.jpg" alt="实验结果"></p><p>代码和模型见：<a href="https://richzhang.github.io/antialiased-cnns/" target="_blank" rel="noopener">https://richzhang.github.io/antialiased-cnns/</a>或者<a href="https://github.com/adobe/antialiased-cnns" target="_blank" rel="noopener">https://github.com/adobe/antialiased-cnns</a></p><br><p><strong>第二篇</strong>是同年发表在 JMLR 的一篇论文《<a href="https://link.zhihu.com/?target=http%3A//www.jmlr.org/papers/volume20/19-519/19-519.pdf" target="_blank" rel="noopener">Why do deep convolutional networks generalize so poorly to small image transformations?</a>》。作者首先给出了几组示例，分别表示了平移、尺度以及轻微图像差异对网络预测分类置信度的影响：</p><p><img src="transformation.jpg" alt="平移、尺度和轻微图像差异对预测分类置信度的影响"></p><p>作者认为 CNN 忽视了采样定理，这一点之前 Simoncelli 等人已经在论文 Shiftable multiscale transforms 中验证了二次采样在平移不变性上的失败，他们在文中说：</p><blockquote><p>我们不能简单地把系统中的平移不变性寄希望于卷积和二次采样，输入信号的平移不意味着变换系数的简单平移，除非这个平移是每个二次采样因子的倍数。</p></blockquote><p>我们现有的网络框架中，越深的网络，降采样次数越多，因此出现的问题更多。紧接着，作者提出了几点论述：</p><ul><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 是经过卷积操作且满足平移不变性的特征，那么全局池化操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∑</mo><mi>i</mi></msub><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_i r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 也满足平移不变性；</li><li>对于特征提取器 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 和降采样因子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> ，如果输入的平移都可以在输出上线性插值反映出来：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mi>i</mi></munder><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>r</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i}B(x-x_i)r(x_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.327674em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>由香农-奈奎斯特定理知， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 满足可移位性，要保证采样频率至少为最高信号频率的2倍。</p><p>接下来，作者对这些问题做了一些改进尝试：</p><ul><li><strong>抗锯齿</strong>，这个就是我们刚刚介绍的方法；</li><li><strong>数据增强</strong>，当前在很多图像任务中，我们基本都会采用随机裁剪、多尺度、颜色抖动等等数据增强手段，的确也让网络学习到了部分不变性；</li><li><strong>减少降采样</strong>，也就是说只依赖卷积对于输入尺度的减小来变化，这一点只对小图像适用，主要是因为计算代价太高。</li></ul><br><h1 id="2-cnn对于位置和深度信息的预测"><a class="markdownIt-Anchor" href="#2-cnn对于位置和深度信息的预测"></a> 2. CNN对于位置和深度信息的预测</h1><h2 id="21-cnn如何获取目标的位置信息"><a class="markdownIt-Anchor" href="#21-cnn如何获取目标的位置信息"></a> 2.1 CNN如何获取目标的位置信息</h2><p>最早接触神经网络和深度学习相关任务时，我的感觉就是这类算法本质是做的分类任务，比如图像分割是对前景背景的分类和具体类别分类，识别任务就是类间类内的区分任务。其中图像分割任务就利用了 CNN 中的部分相等性，那么对于目标检测任务中的目标位置回归是怎么获取的呢？我们可以知道的是同样是对目标位置的搜索，在单目标跟踪任务中，存在有置信图：</p><p><img src="confmap.png" alt="置信图"></p><p>但是置信图本质上是对区域进行搜索得到的，因此可以近似为对多个子区域的识别过程，所以单目标跟踪中的目标定位也可以用分类的理解，但是目标检测则不好用分类来理解了。</p><p>接下来我们思考一个问题，我们所设计的网络究竟包含了哪些信息？图像特征、网络结构（卷积核大小、padding）。从上一章我们可以知道，网络可以学习到一定的相等性：</p><p><img src="vgg16.jpg" alt=""></p><p>因此，通过不断地训练，<font color="orange"><em>网络在最后的特征输出中是可以通过对应的特征数值和区域大小，结合一定的倍数（降采样大小）估计目标尺度的</em>。</font>但是对于目标的位置，我们人眼对于目标位置的判定是通过坐标系的，即目标距离图像的边缘距离，但是网络是如何了解这一信息的呢？</p><blockquote><p><font color="orange">对橙色部分的理解:</font>对一个物体的检测包括两个部分，位置(x,y)和尺度(w,h)，这里所说的，就是如何从网络的输出特征中计算得到目标的尺度的。这里认为，通过 对应的特征数值（即找到激活区域）和 区域大小 （激活区域的大小），结合一定的倍数 (feature map 相对于原图降采样的倍数)，可以估计出目标在原图的尺度。</p></blockquote><br><p>《How much Position Information Do Convolutional Neural Networks Encode?》这篇文章做出了回答。</p><p>作者首先做了一组实验：</p><p><img src="hvg.jpg" alt=""></p><p>对于不同的输入图像，采用多种 mask 扰动，H、V、G 分别代表水平、竖直和高斯等分布，用这种方式生成多种 groundtruth，对于这点我们可能对单目标跟踪中以目标中心为均值的高斯分布比较熟悉。结果发现：</p><p><img src="hvg2.jpg" alt=""></p><p>GT 是三种分布生成的 groundtruth，PosENet 是作者提出的网络，没有 padding。我们可以看到 PosENet 并没有得到位置分布信息，而是保持了相等性。而存在 padding 的 VGG 和 ResNet 则都预测出了位置分布。由此可见 padding 对于位置的作用，也对上一章的内容作了补充，padding 对于平移不变性和相等性也有影响。</p><p>不过这里我们可能不好理解，我做了个小测试，不过不一定是这么做的，仅仅方便我理解：</p><p><img src="equation.svg" alt=""></p><p>上面是两个不同位置“目标”的卷积结果，可以看到，从输出结果得不到什么位置反映，如果加入 padding：</p><p><img src="equation2.svg" alt=""></p><p>首先我们可以知道的是，加入了 zero-padding 之后，目标边缘相对中心的输出更小了，其次目标距离图像边缘距离越远，其特征映射中出现<code>0</code>的次数越多。所以我猜网络就是在训练过程中让 padding 和这个相对的关系对应上了，如果没有 padding，目标距离边缘越远，同样出现<code>0</code>的次数也会越多，但问题在于无法跟 padding 造成的边缘数值小，中心数值大的特殊分布相比。当然，以上仅仅是我个人的理解，为了帮助我加深印象罢了。也有人说加入了 padding 影响了 CNN 的平移相等性，从而使得 CNN 学到了位置信息，但这个不大好解释。</p><p>不过有关 padding 的问题，在 CVPR2019 的一片单目标跟踪算法 SiamRPN++ 中也做了探讨。其出发点在于为何 Siamese 网络无法扩展为大型网络，其原因就在于 padding 影响了平移相等性，从而让目标位置的分布发生了偏移。所以作者通过对目标中心的随机扰动，使得网络克服自身的偏移：</p><p><img src="shift.jpg" alt=" "></p><p>也有一些研究探索了如何让 CNN 结合绝对位置信息，比较出名的应该是当前很热门的 SOLO 单阶段实例分割算法。SOLO 的出发点很简单，我们都知道语义分割只需要分割出不同类别的目标，而实例分割对于同一类别的个体还需要区分。但是显而易见，同一类别的目标只要位置和形状不同则可以区分。因此 SOLO 就是将位置和形状（用尺寸简化）信息结合进来。具体而言，就是将输入系统的图像统一划分为 S\timesS 的网格，如果对象的中心落入网格单元，那么这个网格单元就负责预测语义类别以及分割该对象实例。</p><p><img src="solo.jpg" alt="SOLO"></p><p>特别地，SOLO 算法中采用 CoordConv 策略（代码：<a href="https://github.com/uber-research/coordconv" target="_blank" rel="noopener">https://github.com/uber-research/coordconv</a>），该算法将每个特征区域的坐标信息结合进来，从而让网络显示地学会记忆特征的绝对位置信息。SOLO 通过这个策略提升了 <code>3.6AP</code>，并且论证只需要一层提供该信息即可达到稳定的提升。</p><p><img src="coordconv.jpg" alt="CoordConv引入了每个像素的绝对坐标"></p><br><h2 id="22-cnn如何预测目标的深度信息"><a class="markdownIt-Anchor" href="#22-cnn如何预测目标的深度信息"></a> 2.2 CNN如何预测目标的深度信息</h2><p>深度估计也是一个类似的问题，不同的是，图像中并没有包含深度信息，但是网络是如何获取深度信息的呢。How Do Neural Networks See Depth in Single Images?这篇文章给出了回答，关于这篇文章 NaiyanWang 老师已经在博客里讨论过，我这里也就再整理下。</p><p><img src="camera.jpg" alt=""></p><p>我们可以看到，物体的绝对深度与相机位姿有着很大关系，那么 CNN 如何学习到这种需要几何先验的绝对信息的呢？作者做了这样一个实验：</p><p><img src="depth.jpg" alt=""></p><p>上图中作者做了三组实验：同时变化目标位置和尺寸、只变化位置以及只变化尺寸，我们从上面的定性结果好像看不出什么问题，下面是定量的结果：</p><p><img src="ana.jpg" alt="定量分析结果"></p><p>可以发现，尺度对于深度信息的预测没有什么影响，也就是说<font color="red"><strong>CNN网络是通过目标纵坐标来估计深度的</strong></font>，所以说网络实际上是在过拟合训练集，从中学习到一些固定场景下的深度和相对位置的对应关系。</p><p>作者又讨论了相机运动对于深度预测的影响，既然深度与目标纵坐标有关系，那么 pitch 角的影响应该很大：</p><p><img src="pitch.jpg" alt="pitch俯仰角的影响较大"></p><p>可以发现，<strong>pitch的确影响比较大</strong>，相对的, roll 的影响就比较小了：</p><p><img src="roll.jpg" alt="roll翻滚角的影响较小"></p><p>最后作者还讨论了颜色和纹理对深度估计的影响：</p><p><img src="texture.jpg" alt="颜色和纹理对深度估计的影响"></p><p>可以发现，<strong>仅仅是改变目标的颜色纹理，深度估计的效果也会下降</strong>，可将CNN网络在训练时有多“偷懒”，不知道如果将上述实验变成数据增强的手段的话会让深度估计网络失效还是变强。</p><br><h1 id="2020318更新"><a class="markdownIt-Anchor" href="#2020318更新"></a> 2020.3.18更新</h1><p>昨天碰巧看到一篇 CVPR2020 的文章《On Translation Invariance in CNNs: Convolutional Layers can Exploit Absolute Spatial Location》，其中也提到了 CNN 中的平移不变性问题和绝对位置信息编码问题，其切入点是 CNN 中的边界问题。</p><p>作者首先以三种卷积方式为例，full/same/valid，各自的区别在于 padding 的大小，具体方式我就不细说了，给个示意图：</p><p><img src="padding.jpg" alt=""></p><p><img src="1dpadding.jpg" alt=""></p><p>其中红色部分表示 padding，绿色部分表示边界区域。很明显，<code>valid</code>模式下卷积核最右边的<code>1</code>永远无法作用于绿色部分的<code>1</code>，<code>same</code>模式下的卷积核最右边 <code>1</code>永远无法作用于绿色部分的<code>1</code> 。作者以 <code>zero-padding</code> 和<code>circular-padding</code> 两种模式做了一个例子说明：</p><br><p><img src="compare.jpg" alt=""></p><p>可以看到 Class-1 中前两个例子都没有检测到<code>1</code>，<code>valid</code> 和 <code>same+zero-padding</code> 模式对于待卷积区域的绝对位置比较敏感。紧接着作者又分析了每个位置被卷积的次数：</p><p><img src="equation3.svg" alt=""></p><p>由此引出距离图像边界多远时某一固定像素可以被检测到这一问题，于是作者通过给图片四周添加不同大小的黑色边界进行试验：</p><p><img src="border.jpg" alt=""></p><p>有意思的是，<strong>增加了黑色边界之后分类的准确率都出现了明显的下滑，只不过不同的训练策略和不同的 backbone 的抗干扰能力不同罢了。</strong></p><p><img src="border_result.jpg" alt=""></p><p>为了定量分析各个卷积策略对于边界的处理区别，建了一个分类数据集，特殊点都分布在边界：</p><p><img src="dataset.jpg" alt=""></p><p>结果差别很大：</p><p><img src="res2.jpg" alt=""></p><p>可以发现，跟之前的观察结果一样，前两种策略的泛化能力很差，而基于 <code>Circular padding</code> 和 <code>full convolution</code> 的模式效果最好。接着作者为了降低边界的影响，采用了前文介绍卷积平移不变性里面提到的 <code>blur pooling+Tri3</code> 卷积核。然后对比 S<code>-conv+circular padding</code> 和 <code>F-conv</code> 两种策略对于不同的图像对角平移的鲁棒性：</p><p><img src="ana2.jpg" alt=""></p><p><img src="res3.jpg" alt=""></p><p>结果显示 <strong>Full conv 模式效果更好</strong>，在后续实验中还说明了其有助于降低过拟合风险，对于小数据集更有效。</p><p>代码即将开源 <a href="https://link.zhihu.com/?target=https%3A//github.com/oskyhn/CNNs-Without-Borders" target="_blank" rel="noopener">https://link.zhihu.com/?target=https%3A//github.com/oskyhn/CNNs-Without-Borders</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在知乎上看到一篇关于 CNN 的平移不变性和平移等变性以及 CNN 对位置和深度信息预测的文章，觉得很有收获，因此转载在这里。里面也会穿插自己的理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="平移不变性" scheme="https://taosean.github.io/tags/%E5%B9%B3%E7%A7%BB%E4%B8%8D%E5%8F%98%E6%80%A7/"/>
    
      <category term="平移等变性" scheme="https://taosean.github.io/tags/%E5%B9%B3%E7%A7%BB%E7%AD%89%E5%8F%98%E6%80%A7/"/>
    
      <category term="translation invariance" scheme="https://taosean.github.io/tags/translation-invariance/"/>
    
      <category term="translation equivalence" scheme="https://taosean.github.io/tags/translation-equivalence/"/>
    
  </entry>
  
  <entry>
    <title>【转载】图像与滤波</title>
    <link href="https://taosean.github.io//2021/03/18/Image-and-Filtering/"/>
    <id>https://taosean.github.io//2021/03/18/Image-and-Filtering/</id>
    <published>2021-03-18T11:12:50.000Z</published>
    <updated>2021-03-18T12:07:28.727Z</updated>
    
    <content type="html"><![CDATA[<p>看到了一篇关于图像滤波的文章，详细地解释了从波和信号处理的角度来理解图像。</p><p>以下为原文。</p><a id="more"></a><hr><p>前几天读到一篇<a href="https://medium.com/statuscode/filtering-images-using-web-audio-api-276555cca6ad" target="_blank" rel="noopener">文章</a>，它提到<strong>图像其实是一种波，可以用波的算法处理图像</strong>。我顿时有一种醍醐灌顶的感觉，从没想到这两个领域是相关的，图像还可以这样玩！下面我就来详细介绍这篇文章。</p><h1 id="一-为什么图像是波"><a class="markdownIt-Anchor" href="#一-为什么图像是波"></a> 一、为什么图像是波？</h1><p>我们知道，图像由像素组成。下图是一张 400 x 400 的图片，一共包含了 16 万个像素点。<br><img src="pic1.jpg" alt="lena"><br>每个像素的颜色，可以用红、绿、蓝、透明度四个值描述，大小范围都是<code>0 ～ 255</code>，比如黑色是<code>[0, 0, 0, 255]</code>，白色是<code>[255, 255, 255, 255]</code>。通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas" target="_blank" rel="noopener">Canvas API</a> 就可以拿到这些值。</p><p>如果把每一行所有像素（上例是400个）的红、绿、蓝的值，依次画成三条曲线，就得到了下面的图形。<br><img src="wave1.png" alt="RGB像素值变化"><br>可以看到，每条曲线都在不停的上下波动。有些区域的波动比较小，有些区域突然出现了大幅波动（比如 54 和 324 这两点）。</p><p>对比一下图像就能发现，曲线波动较大的地方，也是图像出现突变的地方。<br><img src="wave2.png" alt="原图与曲线波动较大地方的对应"><br>这说明波动与图像是紧密关联的。<strong>图像本质上就是各种色彩波的叠加。</strong></p><h1 id="二-频率"><a class="markdownIt-Anchor" href="#二-频率"></a> 二、频率</h1><p>综上所述，<strong>图像就是色彩的波动：波动大，就是色彩急剧变化；波动小，就是色彩平滑过渡。因此，波的各种指标可以用来描述图像。</strong></p><p>频率（frequency）是波动快慢的指标，单位时间内波动次数越多，频率越高，反之越低。<br><img src="wave3.jpg" alt="正弦波"><br>上图是函数 <code>sin(Θ)</code> 的图形，在 <code>2π</code> 的周期内完成了一次波动，频率就是1。<br><img src="wave4.jpg" alt="2倍频率"><br>上图是函数<code>sin(2Θ)</code>的图形，在<code>2π</code>的周期内完成了两次波动，频率就是2。</p><p>所以，<strong>色彩剧烈变化的地方，就是图像的高频区域；色彩稳定平滑的地方，就是低频区域</strong>。</p><h1 id="三-滤波器"><a class="markdownIt-Anchor" href="#三-滤波器"></a> 三、滤波器</h1><p>物理学对波的研究已经非常深入，提出了很多处理波的方法，其中就有滤波器（filter）：过滤掉某些波，保留另一些波。</p><p>下面是两种常见的滤波器 。</p><blockquote><ul><li>低通滤波器（lowpass）：减弱或阻隔高频信号，保留低频信号</li><li>高通滤波器（highpass）：减弱或阻隔低频信号，保留高频信号</li></ul></blockquote><p>下面是低通滤波的例子。<br><img src="lowpass.png" alt="低通滤波"><br>上图中，蓝线是原始的波形，绿线是低通滤波 <code>lowpass</code> 后的波形。可以看到，绿线的波动比蓝线小很多，非常平滑。</p><p>下面是高通滤波的例子。<br><img src="highpass.png" alt="高通滤波"></p><p>上图中，黄线是原始的波形，蓝线是高通滤波 <code>highpass</code> 后的波形。可以看到，黄线的三个波峰和两个波谷（低频波动），在蓝线上都消失了，而黄线上那些密集的小幅波动（高频波动），则是全部被蓝线保留。</p><p>再看一个例子。<br><img src="examp1.png" alt=""><br>上图有三根曲线，黄线是高频波动，红线是低频波动。它们可以合成为一根曲线，就是绿线<br><img src="examp2.png" alt=""><br>上图中，绿线进行低通滤波和高通滤波后，得到两根黑色的曲线，它们的波形跟原始的黄线和红线是完全一致的。</p><h1 id="四-图像的滤波"><a class="markdownIt-Anchor" href="#四-图像的滤波"></a> 四、图像的滤波</h1><p>浏览器实际上包含了滤波器的实现，因为 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" target="_blank" rel="noopener">Web Audio API</a> 里面定义了<a href="https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode/type" target="_blank" rel="noopener">声波的滤波</a>。这意味着可以通过浏览器，将 <code>lowpass</code> 和 <code>highpass</code> 运用于图像。</p><p><code>lowpass</code> 使得图像的高频区域变成低频，即色彩变化剧烈的区域变得平滑，也就是出现模糊效果。<br><img src="lena2.jpg" alt="低通使图像产生模糊的效果"><br><img src="res1.png" alt="低通后的曲线"><br>上图中，红线是原始的色彩曲线，蓝线是低通滤波后的曲线。</p><p><code>highpass</code> 正好相反，过滤了低频，只保留那些变化最快速最剧烈的区域，也就是图像里面的物体边缘，所以常用于边缘识别。<br><img src="lena3.jpg" alt="高通使图像保留边缘"><br><img src="res2.png" alt="高通后的曲线"></p><p>上图中，红线是原始的色彩曲线，蓝线是高通滤波后的曲线。</p><p>下面这个<a href="http://fellipe.com/demos/lena-js/" target="_blank" rel="noopener">网址</a>，可以将滤波器拖到图像上，产生过滤后的效果。<br><img src="webtool.jpg" alt="网页工具"></p><p>浏览器实现滤波的范例代码，可以看这个<a href="https://github.com/rssilva/web-audio-image-filtering" target="_blank" rel="noopener">仓库</a>。</p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p><a href="http://www.ruanyifeng.com/blog/2017/12/image-and-wave-filters.html" target="_blank" rel="noopener">图像与滤波</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到了一篇关于图像滤波的文章，详细地解释了从波和信号处理的角度来理解图像。&lt;/p&gt;
&lt;p&gt;以下为原文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像" scheme="https://taosean.github.io/tags/%E5%9B%BE%E5%83%8F/"/>
    
      <category term="滤波" scheme="https://taosean.github.io/tags/%E6%BB%A4%E6%B3%A2/"/>
    
      <category term="filter" scheme="https://taosean.github.io/tags/filter/"/>
    
      <category term="高通滤波器" scheme="https://taosean.github.io/tags/%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    
      <category term="低通滤波器" scheme="https://taosean.github.io/tags/%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>匈牙利算法</title>
    <link href="https://taosean.github.io//2021/03/08/Hungarian-algorithm/"/>
    <id>https://taosean.github.io//2021/03/08/Hungarian-algorithm/</id>
    <published>2021-03-08T01:38:17.000Z</published>
    <updated>2021-03-16T13:09:07.992Z</updated>
    
    <content type="html"><![CDATA[<p>一些有关匈牙利算法的文章。</p><a id="more"></a><p><a href="https://blog.csdn.net/u013384984/article/details/90718287" target="_blank" rel="noopener">匈牙利算法-看这篇绝对就够了！</a></p><p><a href="https://blog.csdn.net/C20180630/article/details/70175814" target="_blank" rel="noopener">二分图匹配——匈牙利算法和KM算法</a></p><p><a href="https://blog.csdn.net/u013384984/article/details/90718287" target="_blank" rel="noopener">趣写算法系列之–匈牙利算法</a></p><h3 id="矩阵处理相关代码可以看-sklearn-中的-linear_assignmentpy"><a class="markdownIt-Anchor" href="#矩阵处理相关代码可以看-sklearn-中的-linear_assignmentpy"></a> 矩阵处理相关，代码可以看 sklearn 中的 linear_assignment.py</h3><p><a href="https://www.feiyilin.com/munkres.html" target="_blank" rel="noopener">Munkres Algorithm For Assignment Problem: A Tutorial</a></p><p><a href="https://blog.csdn.net/u014754127/article/details/78086014" target="_blank" rel="noopener">Hungarian Algorithm匈牙利算法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些有关匈牙利算法的文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hungarian algorithm" scheme="https://taosean.github.io/tags/Hungarian-algorithm/"/>
    
      <category term="二分图" scheme="https://taosean.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="最大匹配" scheme="https://taosean.github.io/tags/%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>【转载】进程？线程？小朋友你是否有很多问号？</title>
    <link href="https://taosean.github.io//2021/01/05/Process-and-Thread-1/"/>
    <id>https://taosean.github.io//2021/01/05/Process-and-Thread-1/</id>
    <published>2021-01-05T10:39:55.000Z</published>
    <updated>2021-01-06T03:21:02.047Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自<a href="https://mp.weixin.qq.com/s/4uhfJeYwQgzd6A6nTBj_Gg" target="_blank" rel="noopener">这篇文章</a></p><a id="more"></a><p><img src="menu.jpg" alt="目录"></p><h1 id="什么是进程"><a class="markdownIt-Anchor" href="#什么是进程"></a> 什么是进程？</h1><p><strong>标准定义</strong>：进程是一个具有一定独立功能的程序在一个数据集合上依次动态执行的过程。进程是一个正在执行程序的实例，包括程序计数器、寄存器和程序变量的当前值。</p><p>简单来说<strong>进程就是一个程序的执行流程，内部保存程序运行所需的资源</strong></p><p>在操作系统中可以有多个进程在运行，可对于CPU来说，同一时刻，一个CPU只能运行一个进程，但在某一时间段内，CPU将这一时间段拆分成更短的时间片，CPU不停地在各个进程间游走，这就给人一种并行的错觉，像CPU可以同时运行多个进程一样，这就是伪并行。</p><hr><h1 id="进程和程序有什么联系"><a class="markdownIt-Anchor" href="#进程和程序有什么联系"></a> 进程和程序有什么联系？</h1><p>一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</p><ul><li>程序是产生进程的基础</li><li>程序的每次运行产生不同的进程</li><li>进程是程序功能的体现</li><li>通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序</li></ul><hr><h1 id="进程和程序有什么区别"><a class="markdownIt-Anchor" href="#进程和程序有什么区别"></a> 进程和程序有什么区别？</h1><p><strong>进程是动态的，程序是静态的</strong>：程序是有序代码的集合，进程是程序的执行。</p><p><strong>进程是暂时的，程序是永久的</strong>：进程是一个状态变化的过程，程序可长久保存。</p><p><strong>进程和程序的组成不同</strong>：进程的组成包括程序、数据和进程控制块（进程状态信息）。</p><hr><h1 id="进程有什么特点"><a class="markdownIt-Anchor" href="#进程有什么特点"></a> 进程有什么特点？</h1><p><strong>动态性</strong>：可动态地创建和结束进程</p><p><strong>并发性</strong>：可以被独立的调度并占用处理机并发运行</p><p><strong>独立性</strong>：不同进程的工作不相互影响</p><p><strong>制约性</strong>：因访问共享资源或进程间同步而产生制约</p><hr><h1 id="进程如何创建"><a class="markdownIt-Anchor" href="#进程如何创建"></a> 进程如何创建？</h1><p>有什么事件会触发进程的创建呢？</p><p><strong>系统初始化</strong>：当启动操作系统时，通常会创建很多进程，有些是同用户交互并替他们完成工作的前台进程，其它的都是后台进程，后台进程和特定用户没有关系，但也提供某些专门的功能，例如接收邮件等，这种功能的进程也称为守护进程。计划任务是个典型的守护进程，它每分钟运行一次来检查是否有工作需要它完成。如果有工作要做，它就会完成此工作，然后进入休眠状态，直到下一次检查时刻的到来。</p><p><strong>正在运行的程序执行了创建进程的系统调用</strong>：在一个进程中又创建了一个新的进程，这种情况很常见。</p><p><strong>用户请求创建一个新进程</strong>：这种情况相信每个人都见过，用电脑时双击某个应用图标，就会有至少一个进程被创建。</p><p><strong>一个批处理作业的初始化</strong>：这种情形不常见，仅在大型机的批处理系统中应用，用户在这种系统中提交批处理作业，在操作系统认为有资源可运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。</p><p>归根到底：在UNIX系统中，只有fork系统调用才可以创建新进程，使用方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"父进程\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程创建之后，父子进程都有<strong>各自不同的地址空间</strong>，其中一个进程在其地址空间的修改对另一个进程不可见。子进程的初始化空间是父进程的一个副本，这里涉及两个不同地址空间，不可写的内存区是共享的，某些UNIX的实现使程序正文在两者间共享，因为它是不可修改的。</p><p>还有一种<strong>写时复制</strong>共享技术，子进程共享父进程的所有内存，一旦两者之一想要修改部分内存，则这块内存被复制确保修改发生在当前进程的私有内存区域。</p><hr><h1 id="进程为何终止"><a class="markdownIt-Anchor" href="#进程为何终止"></a> 进程为何终止？</h1><p>有什么事件会触发进程的终止呢？</p><p><strong>正常退出</strong>（自愿）：进程完成了工作正常终止，UNIX中退出进程的系统调用是exit。</p><p><strong>出错退出</strong>（自愿）：进程发现了错误而退出。可以看如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123; <span class="comment">// 有错误就退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>严重错误</strong>（非自愿）：进程发生了严重的错误而不得不退出，通常是程序的错误导致，例如执行了一条非法指令，引用不存在的内存，或者除数是0等，出现这些错误时进程默认会退出。而有些时候如果用户想自行处理某种类型的错误，发生不同类型错误时进程会收到不同类型的信号，用户注册处理不同信号的函数即可。</p><p><strong>被其它进程杀死</strong>（非自愿）：其它进程执行kill系统调用通知操作系统杀死某个进程。</p><hr><h1 id="操作系统如何进行进程管理"><a class="markdownIt-Anchor" href="#操作系统如何进行进程管理"></a> 操作系统如何进行进程管理？</h1><p>这里就不得不提到一个数据结构：进程控制块（PCB），<strong>操作系统为每个进程都维护一个PCB</strong>，用来保存与该进程有关的各种状态信息。进程可以抽象理解为就是一个PCB，<strong>PCB是进程存在的唯一标志</strong>，操作系统用PCB来描述进程的基本情况以及运行变化的过程，进程的任何状态变化都会通过PCB来体现。</p><p><strong>PCB包含进程状态的重要信息</strong>，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其它在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未中断过一样。后一小节会具体介绍PCB。</p><p>提到进程管理，有一个概念我们必须要知道，就是<strong>中断向量</strong>，中断向量是指中断服务程序的入口地址。一个进程在执行过程中可能会被中断无数次，但是每次中断后，被中断的进程都要返回到与中断发生前完全相同的状态。</p><p>中断发生后操作系统最底层做了什么呢？</p><blockquote><p>1）硬件压入堆栈程序计数器等；<br>2）硬件从中断向量装入新的程序计数器；<br>3）汇编语言过程保存寄存器值；<br>4）汇编语言过程设置新的堆栈；<br>5）C中断服务例程运行（典型的读和缓冲输入）；<br>6）调度程序决定下一个将运行的进程；<br>7）C过程返回到汇编代码；<br>8）汇编语言过程开始运行新的当前进程。</p></blockquote><hr><h1 id="进程控制块中存储了什么信息"><a class="markdownIt-Anchor" href="#进程控制块中存储了什么信息"></a> 进程控制块中存储了什么信息？</h1><p><strong>进程标识信息</strong>：如本进程的标识，本进程的父进程标识，用户标识等。</p><p><strong>处理机状态信息保护区</strong>：用于保存进程的运行现场信息。</p><ul><li>用户可见寄存器：用户程序可以使用的数据、地址等寄存器。</li><li>控制和状态寄存器：程序计数器，程序状态字。</li><li>栈指针：过程调用、系统调用、中断处理和返回时需要用到它。</li></ul><p><strong>进程控制信息</strong>：</p><ul><li>调度和状态信息：用于操作系统调度进程使用。</li><li>进程间通信信息：为支持进程间与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中。</li><li>存储管理信息：包含有指向本进程映像存储空间的数据结构。</li><li>进程所用资源：说明由进程打开使用的系统资源，如打开的文件等。</li><li>有关数据结构连接信息：进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。</li></ul><hr><h1 id="进程如何进行生命周期管理"><a class="markdownIt-Anchor" href="#进程如何进行生命周期管理"></a> 进程如何进行生命周期管理？</h1><p><strong>进程创建</strong>：</p><p>创建进程有三个主要事件：</p><ul><li>系统初始化</li><li>用户请求创建一个新进程</li><li>一个正在运行的进程执行创建进程的系统调用</li></ul><p><strong>进程运行</strong>：内核选择一个就绪的进程，让它占用处理机并运行，这里就涉及到了进程的调度策略，选择哪个进程调度？为什么选择调度这个进程呢？（莫慌，下面会介绍哈）</p><p><strong>进程等待</strong>：</p><ul><li>在以下情况下进程会等待（阻塞）：</li><li>请求并等待系统服务，无法马上完成</li><li>启动某种操作，无法马上完成</li><li>需要的数据没有到达</li></ul><p><strong>注意：进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生</strong>。</p><p><strong>进程唤醒</strong>：<br>进程只能被别的进程或操作系统唤醒，唤醒进程的原因有：</p><ul><li>被阻塞进程需要的资源可被满足</li><li>被阻塞进程等待的事件到达</li><li>将该进程的PCB插入到就绪队列</li></ul><p><strong>进程结束</strong>：<br>在以下四种情况下进程会结束：</p><ul><li>自愿型正常退出</li><li>自愿型错误退出</li><li>强制型致命错误退出</li><li>强制型被其它进程杀死退出</li></ul><hr><h1 id="进程都有什么状态"><a class="markdownIt-Anchor" href="#进程都有什么状态"></a> 进程都有什么状态？</h1><p>不同系统设置的进程状态是不同的，多数系统中的进程在生命结束前有三种基本状态，进程只会处于三种基本状态之一：</p><p><strong>运行状态</strong>：进程正在处理机上运行时就处在运行状态，该时刻进程时钟占用着CPU；</p><p><strong>就绪状态</strong>：万事俱备，只欠东风，进程已经获得了除处理机之外的一切所需资源，一旦得到处理机就可以运行；就绪态中的进程其实可以运行，但因为其它进程正在占用着CPU而暂时停止运行；</p><p><strong>等待状态（阻塞状态）</strong>：进程正在等待某一事件而暂停运行，等待某个资源或者等待输入输出完成。除非某种外部事件发生，否则阻塞态的进程不能运行；</p><p>进程状态变化图如下：<br><img src="status.jpg" alt="进程状态变化图"></p><p>在操作系统发现进程不能继续运行下去时，进程因为等待输入而被阻塞，进程从<strong>运行态转换到阻塞态</strong>！</p><p>调度程序选择了另一个进程执行时，当前程序就会从<strong>运行态转换到就绪态</strong>！</p><p>被调度程序选择的程序会从<strong>就绪态转换到运行态</strong>！</p><p>当阻塞态的进程等待的一个外部事件发生时，就会从<strong>阻塞态转换到就绪态</strong>，此时如果没有其他进程运行时，则立刻从<strong>就绪态转换到运行态</strong>！</p><p>有些与进程管理相关的系统调用读者有必要了解一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pid=fork(); // 创建一个与父进程一样的子进程</span><br><span class="line"></span><br><span class="line">pid=waitpid(); // 等待子进程终止</span><br><span class="line"></span><br><span class="line">s=execve(); // 替换进程的核心映像</span><br><span class="line"></span><br><span class="line">exit(); // 终止进程运行并返回状态值</span><br><span class="line"></span><br><span class="line">s=sigaction(); // 定义信号处理的动作</span><br><span class="line"></span><br><span class="line">s=sigprocmask(); // 检查或更换信号掩码</span><br><span class="line"></span><br><span class="line">s=sigpending(); // 获得阻塞信号集合</span><br><span class="line"></span><br><span class="line">s=sigsuspend(); // 替换信号掩码或挂起进程</span><br><span class="line"></span><br><span class="line">alarm(); // 设置定时器</span><br><span class="line"></span><br><span class="line">pause(); // 挂起调用程序直到下一个信号出现</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>某些系统设置下进程还会有其它状态：<br>创建状态：进程正在被创建还没被转到就绪状态之前的状态；<br>结束状态：进程正在从系统中消失时的状态。</p><hr><h1 id="什么是进程挂起为什么会出现进程挂起"><a class="markdownIt-Anchor" href="#什么是进程挂起为什么会出现进程挂起"></a> 什么是进程挂起？为什么会出现进程挂起？</h1><p>进程挂起就是为了合理且充分的利用系统资源，把一个进程从内存转到外存。进程在挂起状态时，意味着进程没有占用内存空间，处在挂起状态的进程映射在磁盘上。进程挂起通常有两种状态：</p><ul><li><p>阻塞挂起状态：进程在外存并等待某事件的出现；</p></li><li><p>就绪挂起状态：进程在外存，但只要进入内存即可运行。</p></li></ul><p>有什么与进程挂起相关的状态转换？</p><p>进程挂起可能有以下几种情况：</p><p><strong>阻塞到阻塞挂起</strong>：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程；</p><p><strong>就绪到就绪挂起</strong>：当有高优先级阻塞进程或低优先级就绪进程时，系统会选择挂起低优先级就绪进程；</p><p><strong>运行到就绪挂起</strong>：对于抢占式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；</p><p><strong>阻塞挂起到就绪挂起</strong>：当有阻塞挂起进程有相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。</p><p><strong>有进程挂起那就有进程解挂：指一个进程从外存转到内存，相关状态有</strong>：</p><p><strong>就绪挂起到就绪</strong>：没有就绪进程或就绪挂起进程优先级高于就绪进程时，就会进行这种转换；</p><p><strong>阻塞挂起到阻塞</strong>：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起进程转换为阻塞进程。</p><hr><h1 id="什么是进程调度操作系统对于进程调度都有什么策略"><a class="markdownIt-Anchor" href="#什么是进程调度操作系统对于进程调度都有什么策略"></a> 什么是进程调度？操作系统对于进程调度都有什么策略？</h1><p>当系统中有多个进程同时竞争CPU，如果只有一个CPU可用，那同一时刻只会有一个进程处于运行状态，操作系统必须要选择下一个要运行的是哪个进程，在操作系统中，完成选择工作的这部分称为调度程序，该程序使用的算法称作<strong>调度算法</strong>。</p><p><strong>什么时候进行调度？</strong></p><ol><li>系统调用创建一个新进程后，需要决定是运行父进程还是运行子进程。</li><li>一个进程退出时需要做出调度决策，需要决定下一个运行的是哪个进程。</li><li>当一个进程阻塞在I/O和信号量或者由于其它原因阻塞时，必须选择另一个进程运行。</li><li>当一个I/O中断发生时，如果中断来自IO设备，而该设备现在完成了工作，某些被阻塞的等待该IO的进程就成为可运行的就绪进程了，是否让新就绪的进程运行，或者让中断发生时运行的进程继续运行，或者让某个其它进程运行，这就取决于调度程序的抉择了。</li></ol><p><strong>调度算法分类</strong>：</p><p><strong>非抢占式调度算法</strong>：挑选一个进程，然后让该进程运行直至被阻塞，或者直到该进程自动释放CPU，即使该进程运行了若干个小时，它也不会被强迫挂起。这样做的结果是，在时钟中断发生时不会进行调度，在处理完时钟中断后，如果没有更高优先级的进程等待，则被中断的进程会继续执行。简单来说，<strong>调度程序必须等待事件结束</strong>。</p><p>非抢占方式引起进程调度的条件：</p><ul><li>进程执行结束，或发生某个事件而不能继续执行</li><li>正在运行的进程因有I/O请求而暂停执行</li><li>进程通信或同步过程中执行了某些原语操作（wait、block等）</li></ul><p><strong>抢占式调度算法</strong>：挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行，进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便CPU控制返回给调度程序，如果没有可用的时钟，那么非抢占式调度就是唯一的选择。简单来说，<strong>就是当前运行的进程在事件没结束时就可以被换出，防止单一进程长时间独占CPU资源</strong>。下面会介绍很多抢占式调度算法：优先级算法、短作业优先算法、轮转算法等。</p><p><strong>调度策略</strong>：不同系统环境下有不同的调度策略算法。调度算法也是有KPI的，对调度算法首先提的需求就是：</p><ul><li><strong>公平</strong>：调度算法需要给每个进程公平的CPU份额，相似的进程应该得到相似的服务，对一个进程给予较其它等价的进程更多的CPU时间是不公平的，被普通水平的应届生工资倒挂也是不公平的！</li><li><strong>执行力</strong>：每一个策略必须强制执行，需要保证规定的策略一定要被执行。</li><li><strong>平衡</strong>：需要保证系统的所有部分尽可能都忙碌。</li></ul><p>但是因为不同的应用有不同的目标，不同的系统中，调度程序的优化也是不同的，大体可以分为三种环境：</p><br><p><strong>批处理系统</strong></p><blockquote><p>批处理系统的管理者为了掌握系统的工作状态，主要关注三个指标：</p><ul><li>吞吐量：是系统每小时完成的作业数量</li><li>周转时间：指从一个作业提交到完成的平均时间</li><li>CPU利用率：尽可能让CPU忙碌，但又不能过量</li></ul><p><strong>调度算法</strong>：</p><p><strong>先来先服务</strong><br>先来后到嘛，就像平时去商店买东西需要排队一样，使用该算法，进程按照它们请求CPU的顺序来使用CPU，该算法最大的优点就是简单易于实现，太容易的不一定是好的，该算法也有很大的<strong>缺点</strong>：平均等待时间波动较大，时间短的任务可能排队排在了时间长的任务后面。举个生活中的例子，排着队去取快递，如果每个人都很快取出来快递还好，如果前面有几个人磨磨唧唧到快递柜前才拿出手机打开app，再找半分钟它的取件码，就会严重拖慢后面的人取快递的速度，同理排着队的进程如果每个进程都很快就运行完还好，如果其中有一个得到了CPU的进程运行时候磨磨唧唧很长时间都运行不完，那后面的进程基本上就没有机会运行了！</p><p><strong>最短作业优先</strong><br>该调度算法是非抢占式的算法，每个进程执行期间不会被打断，每次都选择执行时间最短的进程来调度，但问题来了，操作系统怎么可能知道进程具体的执行时间呢，所以该算法注定是基于预测性质的理想化算法，而且有违公平性，而且可能导致运行时间长的任务得不到调度。</p><p><strong>最短剩余时间优先</strong><br>该调度算法是抢占式的算法，是最短作业优先的抢占版本，在进程运行期间，如果来了个更短时间的进程，那就转而去把CPU时间调度给这个更短时间的进程，它的缺点和最短作业优先算法类似。</p></blockquote><br><p><strong>交互式系统</strong></p><blockquote><p>对于交互系统最重要的指标就是响应时间和均衡性啦：</p><ul><li>响应时间：一个请求被提交到产生第一次响应所花费的时间。你给别人发微信别人看后不回复你或者几个小时后才回复你，你是什么感受，这还是交互式吗？</li><li>均衡性：减少平均响应时间的波动。需要符合固有期望和预期，你给别人发微信，他有时候秒回复，有时候几个小时后才回复。在交互式系统中，可预测性比高差异低平均更重要。</li></ul><p><strong>调度算法：</strong></p><p><strong>轮转调度</strong><br>每个进程被分配一个时间段，称为时间片，即CPU做到雨露均沾，轮流翻各个进程的牌子，这段时间宠幸进程A，下一段时间宠幸进程B，再下一段时间宠幸进程C，确保每个进程都可以获得CPU时间，如果CPU时间特别短的话，在外部看来像是同时宠幸了所有进程一样。那么问题来了，这个时间片究竟多长时间好呢？如果时间片设的太短会导致过多的进程切换，频繁的上下文切换会降低CPU效率，而如果时间片设的太长又可能对短的交互请求的响应时间变长，通常将时间片设为20-50ms是个比较合理的折中，大佬们的经验规则时维持上下文切换的开销处于1%以内。</p><p><strong>优先级调度</strong><br>上面的轮转调度算法是默认每个进程都同等重要，都有相同优先级，然而有时候进程需要设置优先级，例如某些播放视频的前台进程可以优先于某些收发邮件的后台守护进程被调度，在优先级调度算法中，每个优先级都有相应的队列，队列里面装着对应优先级的进程，首先在高优先级队列中进行轮转调度，当高优先级队列为空时，转而去低优先级队列中进行轮转调度，如果高优先级队列始终不为空，那么低优先级的进程很可能就会饥饿到很久不能被调度。</p><p><strong>多级队列</strong><br>多级队列算法与优先级调度算法不同，优先级算法中每个进程分配的是相同的时间片，而在多级队列算法中，不同队列中的进程分配给不同的时间片，当一个进程用完分配的时间片后就移动到下一个队列中，这样可以更好的避免上下文频繁切换。举例：有一个进程需要100个时间片，如果每次调度都给分配一个时间片，则需要100次上下文切换，这样CPU运行效率较低，通过多级队列算法，可以考虑最开始给这个进程分配1个时间片，然后被换出，下次分给它2个时间片，再换出，之后分给它4、8、16、64个时间片，这样分配的话，该进程只需要7次交换就可以运行完成，相比100次上下文切换运行效率高了不少，但顾此就会失彼，那些需要交互的进程得到响应的速度就会下降。</p><p><strong>最短进程优先</strong><br>交互式系统中应用最短进程优先算法其实是非常适合的，每次都选择执行时间最短的进程进行调度，这样可以使任务的响应时间最短，但这里有个任务，还没有运行呢，我怎么知道进程的运行时间呢？根本没办法非常准确的再当前可运行进程中找出最短的那个进程。有一种办法就是根据进程过去的行为进行预测，但这能证明是个好办法吗？</p><p><strong>保证调度</strong><br>这种调度算法就是向用户做出明确的可行的性能保证，然后去实现它。一种很实际的可实现的保证就是确保N个用户中每个用户都获得CPU处理能力的1/N，类似的，保证N个进程中每个进程都获得1/N的CPU时间。</p><p><strong>彩票调度</strong><br>彩票调度算法基本思想是为进程提供各种资源（CPU时间）的彩票，一旦需要做出调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源，很明显，拥有彩票越多的进程，获得资源的可能性越大。该算法在程序喵看来可以理解为股票算法，将CPU的使用权分成若干股，假设共100股分给了3个进程，给这些进程分别分配20、30、50股，那么它们大体上会按照股权比例（20：30：50）划分CPU的使用。</p><p><strong>公平分享调度</strong><br>假设有系统两个用户，用户1启动了1个进程，用户2启动了9个进程，如果使用轮转调度算法，那么用户1将获得10%的CPU时间，用户2将获得90%的CPU时间，这对用户来说公平吗？如果给每个用户分配50%的CPU时间，那么用户2中的进程获得的CPU时间明显比用户1中的进程短，这对进程来说公平吗？这就取决于怎么定义公平啦？</p></blockquote><br><p><strong>实时系统</strong></p><blockquote><p>实时系统顾名思义，最关键的指标当然是实时啦：</p><ul><li>满足截止时间：需要在规定deadline前完成作业；</li><li>可预测性：可预测性是指在系统运行的任何时刻，在任何情况下，实时系统的资源调配策略都能为争夺资源的任务合理的分配资源，使每个实时任务都能得到满足。</li></ul><p><strong>调度算法分类</strong>：</p><p><strong>硬实时</strong><br>必须在deadline之前完成工作，如果delay，可能会发生灾难性或发生严重的后果；</p><p><strong>软实时</strong><br>必须在deadline之前完成工作，但如果偶尔delay了，也可以容忍。</p><p><strong>调度算法</strong>：</p><p><strong>单调速率调度</strong><br>采用抢占式、静态优先级的策略，调度周期性任务。<br>每个任务最开始都被配置好了优先级，当较低优先级的进程正在运行并且有较高优先级的进程可以运行时，较高优先级的进程将会抢占低优先级的进程。在进入系统时，每个周期性任务都会分配一个优先级，周期越短，优先级越高。这种策略的理由是：更频繁的需要CPU的任务应该被分配更高的优先级。</p><p><strong>最早截止时间调度</strong><br>根据截止时间动态分配优先级，截止时间越早的进程优先级越高。</p><p>该算法中，当一个进程可以运行时，它应该向操作系统通知截止时间，根据截止时间的早晚，系统会为该进程调整优先级，以便满足可运行进程的截止时间要求。它与单调速率调度算法的区别就是一个是静态优先级，一个是动态优先级。</p></blockquote><p><strong>如何配置调度策略</strong>？<br>调度算法有很多种，各有优缺点，操作系统自己很少能做出最优的选择，那么可以把选择权交给用户，由用户根据实际情况来选择适合的调度算法，这就叫策略与机制分离，调度机制位于内核，调度策略由用户进程决定，将调度算法以某种形式参数化，由用户进程来选择参数从而决定内核使用哪种调度算法。</p><hr><h1 id="操作系统怎么完成进程调度"><a class="markdownIt-Anchor" href="#操作系统怎么完成进程调度"></a> 操作系统怎么完成进程调度？</h1><p>进程的每次变化都会有相应的状态，而操作系统维护了一组状态队列，表示系统中所有进程的当前状态；不同的状态有不同的队列，有就绪队列阻塞队列等，每个进程的PCB都根据它的状态加入到相应的队列中，当一个进程的状态发生变化时，它的PCB会从一个状态队列中脱离出来加入到另一个状态队列。</p><p><img src="scheduling.jpg" alt="进程调度"></p><p>注意图中同一种状态为什么有多个队列呢？因为进程有优先级概念，相同状态的不同队列的优先级不同。</p><hr><h1 id="什么是线程"><a class="markdownIt-Anchor" href="#什么是线程"></a> 什么是线程？</h1><p>线程是进程当中的一条执行流程，这几乎就是进程的定义，一个进程内可以有多个子执行流程，即线程。可以从两个方面重新理解进程：</p><ul><li>从资源组合的角度：进程把一组相关的资源组合起来，构成一个资源平台环境，包括地址空间（代码段、数据段），打开的文件等各种资源</li><li>从运行的角度：代码在这个资源平台上的执行流程，然而线程貌似也是这样，但是进程比线程多了资源内容列表样式：那就有一个公式：进程 = 线程 + 共享资源</li></ul><hr><h1 id="为什么使用线程"><a class="markdownIt-Anchor" href="#为什么使用线程"></a> 为什么使用线程？</h1><p>因为要并发编程，在许多情形中同时发生着许多活动，而某些活动有时候会被阻塞，通过将这些活动分解成可以准并行运行的多个顺序流程是必须的，而如果使用多进程方式进行并发编程，进程间的通信也很复杂，并且<strong>维护进程的系统开销较大</strong>：创建进程时分配资源建立PCB，撤销进程时回收资源撤销PCB，进程切换时保存当前进程的状态信息。所以为了使并发编程的开销尽量小，所以引入多线程编程，可以并发执行也可以<strong>共享相同的地址空间</strong>。并行实体拥有共享同一地址空间和所有可用数据的能力，这是多进程模型所不具备的能力。</p><p>使用线程有如下优点：</p><ul><li>可以多个线程存在于同一个进程中</li><li>各个线程之间可以并发的执行</li><li>各个线程之间可以共享地址空间和文件等资源</li><li>线程比进程更轻量级，创建线程撤销线程比创建撤销进程要快的多，在许多系统中，创建一个线程速度是创建一个进程速度的10-100倍。</li><li>如果多个线程是CPU密集型的，并不能很好的获得更好的性能，但如果多个线程是IO密集型的，线程存在着大量的计算和大量的IO处理，有多个线程允许这些活动彼此重叠进行，从而会加快整体程序的执行速度。</li></ul><p>但也有<strong>缺点</strong>：</p><ul><li>一旦一个线程崩溃，会导致其所属进程的所有线程崩溃。</li><li>由于各个线程共享相同的地址空间，那么读写数据可能会导致竞争关系，因此对同一块数据的读写需要采取某些同步机制来避免线程不安全问题。</li></ul><hr><h1 id="什么时候用进程-线程"><a class="markdownIt-Anchor" href="#什么时候用进程-线程"></a> 什么时候用进程、线程？</h1><ol><li>进程是资源分配单位，线程是CPU调度单位；</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li><li>线程同样具有就绪阻塞和执行三种基本状态，同样具有状态之间的转换关系；</li><li>线程能减少并发执行的时间和空间开销：<ul><li>线程的创建时间比进程短</li><li>线程的终止时间比进程短</li><li>同一进程内的线程切换时间比进程短</li><li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信</li></ul></li></ol><p><strong>结论</strong>：可以在强调性能时候使用线程，如果追求更好的容错性可以考虑使用多进程，google浏览器据说就是用的多进程编程。在多CPU系统中，多线程是有益的，在这样的系统中，通常情况下可以做到真正的并行。</p><p><strong>C/C++中如何使用多线程编程？</strong></p><p>POSIX使用如下线程封装函数来操作线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_create               创建一个新线程</span><br><span class="line">pthread_exit                 结束调用的线程</span><br><span class="line">pthread_join                 等待一个特定的线程退出</span><br><span class="line">pthread_yield                释放CPU来运行另外一个线程</span><br><span class="line">pthread_attr_init            创建并初始化一个线程的属性结构</span><br><span class="line">pthread_attr_destroy         删除一个线程的属性结构</span><br></pre></td></tr></table></figure><p>后两个函数是有关线程属性的调用。pthread_attr_init建立关联一个线程的属性结构并初始化成默认值，这些值（优先级等）可以通过修改属性结构中的对应值来改变；pthread_attr_destroy会删除一个线程的属性结构，释放它占用的内存，它不会影响调用它的线程，线程依然会继续存在。</p><p>C++中有std::thread和async，可以很方便地操作多线程，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">r</span><span class="params">(F)</span></span>;</span><br><span class="line">    r.detach();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">20</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="线程是如何实现的"><a class="markdownIt-Anchor" href="#线程是如何实现的"></a> 线程是如何实现的？</h1><p>线程的实现可分为用户线程和内核线程：</p><p><strong>用户线程</strong>：在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建终止同步和调度等。</p><p><img src="user_thread.jpg" alt="用户线程"></p><p>用户线程有如下优点：</p><ul><li>由于用户线程的维护由相应进程来完成（通过线程库函数），不需要操作系统内核了解内核了解用户线程的存在，可用于不支持线程技术的多进程操作系统。</li><li>每个进程都需要它自己私有的线程控制块列表，用来跟踪记录它的各个线程的状态信息（PC，栈指针，寄存器），TCB由线程库函数来维护；</li><li>用户线程的切换也是由线程库函数来完成，无需用户态/核心态切换，所以速度特别快；</li><li>允许每个进程拥有自定义的线程调度算法；</li></ul><p>但用户线程也有<strong>缺点</strong>：</p><ul><li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待。</li><li>当一个线程开始运行后，除非它主动交出CPU的使用权，否则它所在进程当中的其它线程将无法运行；</li><li>由于时间片分配给进程，与其它进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢</li></ul><p><strong>内核线程</strong>：是指在操作系统的内核中实现的一种线程机制，由操作系统的内核来完成线程的创建终止和管理。</p><p><img src="kernel_thread.jpg" alt="内核线程"></p><p><strong>特点：</strong></p><ul><li>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB TCB）；</li><li>线程的创建终止和切换都是通过系统调用内核函数的方式来进行，由内核来完成，因此系统开销较大；</li><li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其它内核线程的运行；</li><li>时间片分配给线程，多线程的进程获得更多CPU时间；</li></ul><p><em><strong>tips</strong></em><br>由于在内核中创建或撤销线程的代价比较大，某些系统采取复用的方式回收线程，当某个线程被撤销时，就把它标记不可运行，但是内核数据结构没有受到任何影响，如果后续又需要创建一个新线程时，就重新启动被标记为不可运行的旧线程，从而节省一些开销。</p><p><strong>注意</strong><br>尽管使用内核线程可以解决很多问题，但还有些问题，例如：当一个多线程的进程创建一个新的进程时会发生什么？新进程是拥有与原进程相同数量的线程还是只有一个线程？在很多情况下，最好的选择取决于进程计划下一步做什么？如果它要调用exec启动一个新程序，或许一个线程正合适，但如果它继续运行，那么最好复制所有的线程。</p><p><strong>轻量级进程</strong>：它是内核支持的用户线程模型，一个进程可以有多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。</p><p><img src="LWP.jpg" alt="轻量级进程"></p><p>在Linux下是没有真正的线程的，它所谓的线程其实就是使用进程来实现的，就是所谓的轻量级进程，其实就是进程，都是通过clone接口调用创建的，只不过两者传递的参数不同，通过参数决定子进程和父进程共享的资源种类和数量，进而有了普通进程和轻量级进程的区别。</p><hr><h1 id="什么是上下文切换"><a class="markdownIt-Anchor" href="#什么是上下文切换"></a> 什么是上下文切换？</h1><p>上下文切换指的是操作系统停止当前运行进程（从运行状态改变成其它状态）并且调度其它进程（就绪态转变成运行状态）。操作系统必须在切换之前存储许多部分的进程上下文，必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过，同时切换上下文这个过程必须快速，因为上下文切换操作是非常频繁的。那<strong>上下文指的是什么呢</strong>？指的是任务所有共享资源的工作现场，每一个共享资源都有一个<strong>工作现场</strong>，包括用于处理函数调用、局部变量分配以及工作现场保护的栈顶指针，和用于指令执行等功能的各种寄存器。</p><p><strong>注意</strong><br>这里所说的进程切换导致上下文切换其实不太准确，准确的说应该是任务的切换导致上下文切换，这里的任务可以是进程也可以是线程，准确的说线程才是CPU调度的基本单位，但是因为各个资料都这么解释上下文切换，所以上面也暂时这么介绍，只要读者心里有这个概念就好。</p><p><img src="context.png" alt="上下文切换"></p><hr><h1 id="进程间通信有几种方式"><a class="markdownIt-Anchor" href="#进程间通信有几种方式"></a> 进程间通信有几种方式？</h1><p>由于各个进程不共享相同的地址空间，任何一个进程的全局变量在另一个进程中都不可见，所以如果想要在进程之间传递数据就需要通过内核，在内核中开辟出一块区域，该区域对多个进程都可见，即可用于进程间通信。有读者可能有疑问了，文件方式也是进程间通信啊，也要在内核开辟区域吗？这里说的内核区域其实是一段缓冲区，文件方式传输数据也有内核缓冲区的参与（零拷贝除外）。</p><p><img src="IPC.jpg" alt="进程间通信"></p><p>如何开辟这种公共区域来进行进程间通信呢？</p><p><strong>匿名管道</strong></p><p>匿名管道就是<strong>pipe</strong>，pipe只能在父子进程间通信，而且数据只能<strong>单向流动</strong>（半双工通信）。</p><p><strong>使用方式</strong>：<br>1）父进程创建管道，会得到两个文件描述符，分别指向管道的两端；<br>2）父进程创建子进程，从而子进程也有两个文件描述符指向同一管道；<br>3）父进程可写数据到管道，子进程就可从管道中读出数据，从而实现进程间通信，下面的示例代码中通过pipe实现了每秒钟父进程向子进程都发送消息的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(_pipe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pipe\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        close(_pipe[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> _mesg[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(_mesg, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(_mesg));</span><br><span class="line">            read(_pipe[<span class="number">0</span>], _mesg, <span class="keyword">sizeof</span>(_mesg));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, _mesg);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">        close(_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> *mesg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            mesg = <span class="string">"父进程来写消息了"</span>;</span><br><span class="line">            write(_pipe[<span class="number">1</span>], mesg, <span class="built_in">strlen</span>(mesg) + <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们平时也经常使用关于管道的命令行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | less</span><br></pre></td></tr></table></figure><p>该命令行的流向图如下：</p><p><img src="unnamed_pipe.jpg" alt="命令行流向图"></p><p>1：创建管道<br>2：为ls创建一个进程，设置stdout为管理写端<br>3：为less创建一个进程，设置stdin为管道读端</p><p><strong>高级管道</strong><br>通过<strong>popen</strong>将另一个程序当作一个新的进程在当前进程中启动，它算作当前进程的子进程，高级管道只能用在有亲缘关系的进程间通信，这种亲缘关系通常指父子进程，下面的GetCmdResult函数可以获取某个Linux命令执行的结果，实现方式就是通过popen。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetCmdResult</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;cmd, <span class="keyword">int</span> max_size = <span class="number">10240</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *data = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(max_size);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"malloc fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, max_size);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_buffer = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[max_buffer];</span><br><span class="line">    <span class="comment">// 将标准错误重定向到标准输出</span></span><br><span class="line">    FILE *fdp = popen((cmd + <span class="string">" 2&gt;&amp;1"</span>).c_str(), <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">int</span> data_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fdp) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!feof(fdp)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fgets(buffer, max_buffer, fdp)) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buffer);</span><br><span class="line">                <span class="keyword">if</span> (data_len + len &gt; max_size) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"data size larger than "</span> &lt;&lt; max_size;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(data + data_len, buffer, len);</span><br><span class="line">                data_len += len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pclose(fdp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">ret</span><span class="params">(data, data_len)</span></span>;</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命名管道</strong><br>匿名管道有个缺点就是通信的进程一定要有亲缘关系，而命名管道就不需要这种限制。</p><p>命名管道其实就是一种特殊类型的文件，所谓的命名其实就是文件名，文件对各个进程都可见，通过命名管道创建好特殊文件后，就可以实现进程间通信。</p><p>可以通过mkfifo创建一个特殊的类型的文件，参数读者看名字应该就了解，一个是文件名，一个是文件的读写权限：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>当返回值为0时，表示该命名管道创建成功，至于如何通信，其实就是个读写文件的问题！</p><p><strong>消息队列</strong><br>队列想必大家都知道，像FIFO一样，这里可以有多个进程写入数据，也可以有多个进程从队列里读出数据，但消息队列有一点比FIFO还更高级，它读消息不一定要使用先进先出的顺序，每个消息可以赋予类型，可以按消息的类型读取，不是指定类型的数据还存在队列中。本质上MessageQueue是存放在内核中的消息链表，每个消息队列链表会由消息队列标识符表示，这个消息队列存于内核中，只有主动的删除该消息队列或者内核重启时，消息队列才会被删除。</p><p>在Linux中消息队列相关的函数调用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建和访问一个消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span>, key, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 用来把消息添加到消息队列中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsend</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">const</span> <span class="keyword">void</span> *msg_ptr, <span class="keyword">size_t</span> msg_sz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// msg_ptr是结构体数据的指针，结构第一个字段要有个类型：struct Msg &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> message_type;</span><br><span class="line">    <span class="comment">// 想要传输的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 从消息队列中获取消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">void</span> *msg_ptr, <span class="keyword">size_t</span> msg_st, <span class="keyword">long</span> <span class="keyword">int</span> msgtype, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 用来控制消息队列，不同的command参数有不同的控制方式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">int</span> command, struct msgid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZ 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msg_type;</span><br><span class="line">    <span class="keyword">char</span> text[BUFFER_SIZ];</span><br><span class="line">&#125; MsgWrapper;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MsgWrapper data;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msgtype = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1024</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (msgid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgget error \n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msgid, (<span class="keyword">void</span> *)&amp;data, BUFFER_SIZ, msgtype, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"error "</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"read data "</span> &lt;&lt; data.text &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(data.text) &gt; <span class="number">6</span>) &#123;  <span class="comment">// 发送超过6个字符的数据，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgctl(msgid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgctl error \n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Receive ok \n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MsgWrapper data;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> msgtype = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1024</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (msgid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgget error \n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data.msg_type = msgtype;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(data.text, <span class="number">0</span>, BUFFER_SIZ);</span><br><span class="line">        <span class="keyword">char</span> a = <span class="string">'a'</span> + i;</span><br><span class="line">        <span class="built_in">memset</span>(data.text, a, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msgid, (<span class="keyword">void</span> *)&amp;data, BUFFER_SIZ, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgsnd error \n"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(data.text, <span class="string">"1234567"</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgsnd(msgid, (<span class="keyword">void</span> *)&amp;data, BUFFER_SIZ, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msgsnd error \n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">r</span><span class="params">(Receive)</span></span>;</span><br><span class="line">    r.detach();</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">s</span><span class="params">(Send)</span></span>;</span><br><span class="line">    s.detach();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">20</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：root@iZuf64idor3ej648ciairaZ:~# ./a.out</span><br><span class="line">read data a</span><br><span class="line">read data b</span><br><span class="line">read data c</span><br><span class="line">read data d</span><br><span class="line">read data e</span><br><span class="line">read data f</span><br><span class="line">read data g</span><br><span class="line">read data h</span><br><span class="line">read data i</span><br><span class="line">read data j</span><br><span class="line">read data <span class="number">1234567</span></span><br><span class="line">Receive ok</span><br></pre></td></tr></table></figure><p>代码中为了演示方便使用消息队列进行的线程间通信，该代码同样用于进程间通信，消息队列的实现依赖于内核的支持，上述代码可能在某些系统（WSL）上不能运行，在正常的Ubuntu上可以正常运行。</p><p><strong>消息队列VS命名管道</strong></p><p><strong>消息队列&gt;命名管道</strong></p><p>1）消息队列收发消息自动保证了同步，不需要由进程自己来提供同步方法，而命名管道需要自行处理同步问题；<br>2）消息队列接收数据可以根据消息类型有选择的接收特定类型的数据，不需要像命名管道一样默认接收数据。</p><p><strong>消息队列&lt;命名管道</strong><br>消息队列有一个缺点就是发送和接收的每个数据都有最大长度的限制。</p><p><strong>共享内存</strong><br>可开辟中一块内存，用于各个进程间共享，使得各个进程可以直接读写同一块内存空间，就像线程共享同一块地址空间一样，该方式基本上是最快的进程间通信方式，因为没有系统调用干预，也没有数据的拷贝操作，但由于共享同一块地址空间，数据竞争的问题就会出现，需要自己引入同步机制解决数据竞争问题。</p><p>共享内存只是一种方式，它的实现方式有很多种，主要的有mmap系统调用、Posix共享内存以及System V共享内存等。通过这三种“工具”共享地址空间后，通信的目的自然就会达到。</p><p><strong>信号</strong><br>信号也是进程间通信的一种方式，信号可以在任何时候发送给某一个进程，如果进程当前并未处于执行状态，内核将信号保存，直到进程恢复到执行态再发送给进程，进程可以对信号设置预处理方式，如果对信号设置了阻塞处理，则信号的传递会被延迟直到阻塞被取消，如果进程结束，那信号就被丢弃。我们常用的CTRL+C和kill等就是信号的一种，也达到了进程间通信的目的，进程也可以对信号设置signal捕获函数自定义处理逻辑。这种方式有很大的<strong>缺点</strong>：只有通知的作用，通知了一下消息的类型，但不能传输要交换的任何数据。</p><p>Linux系统中常见的信号有：</p><ul><li>SIGHUP：该信号在用户终端结束时发出，通常在中断的控制进程结束时，所有进程组都将收到该信号，该信号的默认操作是终止进程；</li><li>SIGINT：程序终止信号，通常的CTRL+C产生该信号来通知终止进程；</li><li>SIGQUIT：类似于程序错误信号，通常的CTRL+\产生该信号通知进程退出时产生core文件；</li><li>SIGILL：执行了非法指令，通常数据段或者堆栈溢出可能产生该信号；</li><li>SIGTRAP：供调试器使用，由断电指令或其它陷阱指令产生；</li><li>SIGABRT：使程序非正常结束，调用abort函数会产生该信号；</li><li>SIGBUS：非法地址，通常是地址对齐问题导致，比如访问一个4字节长的整数，但其地址不是4的倍数；</li><li>SIGSEGV：合理地址的非法访问，访问了未分配的内存或者没有权限的内存区域；</li><li>SIGPIPE：管道破裂信号，socket通信时经常会遇到，进程写入了一个无读者的管道；</li><li>SIGALRM：时钟定时信号，由alarm函数设置的时间终止时产生；</li><li>SIGFPE：出现浮点错误（比如除0操作）；</li><li>SIGKILL：杀死进程（不能被捕捉和忽略）；</li></ul><p><strong>信号量</strong><br>想必大家都听过信号量，信号量就是一个特殊的变量，程序对其访问都是原子操作，每个信号量开始都有个初始值。最简单最常见的信号量是只能取0和1的变量，也叫二值信号量。</p><p>信号量有两个操作，P和V：</p><p>P：如果信号量变量值大于0，则变量值减1，如果值为0，则阻塞进程；<br>V：如果有进程阻塞在该信号量上，则唤醒阻塞的进程，如果没有进程阻塞，则变量值加1</p><blockquote><p>Q: 信号量和信号有什么关系？<br>A: 没有任何关系，完全是不同的东西。</p></blockquote><blockquote><p>Q: 信号量与互斥量有什么区别？<br>A: 互斥量用于<strong>互斥</strong>，信号量用于<strong>同步</strong>，互斥指的是某一资源同一时间只允许一个访问者访问，但无法限制访问顺序，访问是无序的，而同步在互斥的基础上可以控制访问者对资源的顺序。</p></blockquote><p><strong>套接字</strong>：就是网络传输，不用多说，网络通信都可以多机通信呢，更不用说进程间通信啦，你能看到程序喵的文章也是套接字的功劳。</p><p><strong>文件</strong>：显而易见，多个进程可以操作同一个文件，所以也可以通过文件来进行进程间通信。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自&lt;a href=&quot;https://mp.weixin.qq.com/s/4uhfJeYwQgzd6A6nTBj_Gg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="线程" scheme="https://taosean.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程" scheme="https://taosean.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="Process" scheme="https://taosean.github.io/tags/Process/"/>
    
      <category term="Thread" scheme="https://taosean.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>【转载】5万字、97 张图总结操作系统核心知识点</title>
    <link href="https://taosean.github.io//2020/12/10/OS/"/>
    <id>https://taosean.github.io//2020/12/10/OS/</id>
    <published>2020-12-10T11:37:30.000Z</published>
    <updated>2020-12-10T12:24:22.161Z</updated>
    
    <content type="html"><![CDATA[<p>本文章介绍了操作系统的一些核心知识点。</p><h2 id="文章地址"><a class="markdownIt-Anchor" href="#文章地址"></a> <a href="https://mp.weixin.qq.com/s/G4Xs8BDYo8YK4qHuGdB7DA" target="_blank" rel="noopener">文章地址</a></h2><a id="more"></a><p>文章从以下几个方面对操作系统进行了介绍:</p><ol><li><strong>计算机硬件</strong><br><img src="hardware.png" alt="计算机硬件"></li><li><strong>进程和线程</strong><ul><li>进程</li><li>线程</li><li>进程间通信</li><li>调度<br><img src="process.jpg" alt="进程和线程"></li></ul></li><li><strong>内存管理</strong><ul><li>地址空间</li><li>虚拟内存</li><li>页表置换算法<br><img src="memory.png" alt="内存管理"></li></ul></li><li><strong>文件系统的实现</strong><ul><li>文件</li><li>目录</li><li>文件系统的实现</li><li>文件系统的管理和优化<br><img src="filesystem.png" alt="文件系统"></li></ul></li><li><strong>I/O 流程</strong><ul><li>I/O 设备</li><li>I/O 软件原理</li><li>I/O 层次结构</li><li>盘</li><li>时钟<br><img src="IO.png" alt="I/O 流程"></li></ul></li><li><strong>资源</strong><br><img src="resource.png" alt="资源"></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文章介绍了操作系统的一些核心知识点。&lt;/p&gt;
&lt;h2 id=&quot;文章地址&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#文章地址&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://mp.weixin.qq.com/s/G4Xs8BDYo8YK4qHuGdB7DA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章地址&lt;/a&gt;&lt;/h2&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://taosean.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="OS" scheme="https://taosean.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>理解 Non-local</title>
    <link href="https://taosean.github.io//2020/11/05/Understanding-Non-local/"/>
    <id>https://taosean.github.io//2020/11/05/Understanding-Non-local/</id>
    <published>2020-11-05T09:06:59.000Z</published>
    <updated>2020-12-10T11:35:58.355Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直没有深入地了解 Non-local 的来源，以为只是同名论文中提出的一个 Block 设计，最近阅读 AlphAction 论文时，突然发现其是来自于 Attention is all you need 中 self-attention 的思想。虽然 Attention 此文是针对 NLP 领域的，但是其思想逐渐被延伸到了视觉领域。在阅读关于 Transformer 中 self-attention 的文章后，在这里记录下对 Non-local 的理解。</p><a id="more"></a><p>首先介绍 Self-Attention</p><h1 id="self-attention-模块"><a class="markdownIt-Anchor" href="#self-attention-模块"></a> Self-attention 模块</h1><h2 id="公式"><a class="markdownIt-Anchor" href="#公式"></a> 公式</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mfrac><mrow><mi>A</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac><mo stretchy="false">)</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">Attention(Q,K,V)=softmax({AK^T\over\sqrt{d_k}})V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.448331em;vertical-align:-0.93em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span></span></p><blockquote><p>在 self-attention 中，每个单词有 3 个不同的向量，它们分别是 Query 向量（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> ），Key 向量（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> ）和 Value 向量（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> ），长度均是 64。<strong>它们是通过3个不同的权值矩阵由嵌入向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 乘以三个不同的权值矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>W</mi><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">W^Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>W</mi><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">W^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>W</mi><mi>V</mi></msup></mrow><annotation encoding="application/x-tex">W^V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span></span></span></span></span></span></span> 得到，其中三个矩阵的尺寸也是相同的</strong>。均是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>512</mn><mo>×</mo><mn>416</mn></mrow><annotation encoding="application/x-tex">512\times416</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mord">6</span></span></span></span> 。</p></blockquote><br><p><img src="QKV.jpg" alt="Q, K, V的计算示例图"></p><h2 id="attention-的计算方法"><a class="markdownIt-Anchor" href="#attention-的计算方法"></a> Attention 的计算方法</h2><ol><li>将输入单词转化成嵌入向量;</li><li>根据嵌入向量得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 三个向量;</li><li>为每个向量计算一个 score: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>=</mo><mi>q</mi><mo>⋅</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">score=q\cdot{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span>;</li><li>为了梯度的稳定，Transformer 使用了 score 归一化，即除以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.18278000000000005em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span></span>;</li><li>对 score 施以 softmax 激活函数;</li><li>softmax 点乘 Value 值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，得到加权的每个输入向量的评分 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>;</li><li>相加之后得到最终的输出结果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mo>∑</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">z=\sum{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span></span></li></ol><p>以上步骤可以表示成下图</p><p><img src="self-attention.jpg" alt="Self-Attention计算示例图"></p><p>实际计算过程中是采用基于矩阵的计算方式，那么论文中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 的计算方式如下图<br><img src="QKV-M.jpg" alt="Q, K, V的矩阵表示"></p><p>Self-Attention 的计算示例图可以总结为下图所示的矩阵形式<br><img src="self-attention-M.jpg" alt="Selef-Attention的矩阵表示"><br>而这，也是公式的计算方式。</p><hr><p>接下来看 Non-local 模块</p><h1 id="non-local-的图像"><a class="markdownIt-Anchor" href="#non-local-的图像"></a> Non-local 的图像</h1><p><img src="original-nonlocal.jpg" alt="原始的 Non-local"></p><p><img src="lfb-nonlocal.jpg" alt="lfb 中的 Non-local"></p><p><img src="alphaction-nonlocal.jpg" alt="AlphAction 中的 Non-local"></p><p>从 AlphAction 的 Non-local 可以看出，<br><code>Q</code> 的尺寸是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">N\times{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span></span>, <code>K</code> 的尺寸是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>×</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">N^{&#x27;}\times{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0258099999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span></span>, <code>Q</code> 与 <code>K转置</code>进行矩阵乘法，对应的就是第三步 <strong>计算 score</strong> 的过程(<code>Q</code>的每一行与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">K^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>的每一列点乘)。<br>接下来的 <code>Scale</code> 操作对应第四步 <strong>score 归一化</strong> 的过程。<br>再接下来，Softmax 的输出结果（尺寸 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">N\times{N^{&#x27;}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>）与 <code>V</code> 进行矩阵乘法，得到最后尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">N\times{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span></span> 的矩阵。这里，可以看作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">N\times{N^{&#x27;}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 矩阵的每一行分别与 <code>V</code> 相乘，即 <code>V</code> 的每一行的加权和。<br>其实，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mo>×</mo><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">Q\times{K^{T}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></span> 结果的每一行，来自于 <code>Q</code> 的每一行与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">K^{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span> 进行矩阵相乘，即 <code>Q</code> 的一个向量与 <code>K</code> 所有向量的点积。而<strong>最后计算 <code>V</code> 矩阵每一行的加权和时的权重就来自这里</strong>。</p><p>所以，整个 Non-local 的流程，整体感觉就是通过对 <code>Q</code>, <code>K</code> 的处理，得到了 <code>N</code> 组长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">N^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 的权重，并对 <code>V</code> 的每一行进行加权和。</p><p><strong>补充解释</strong>: Self-Attention 真实的意图是，通过 <code>Q</code> 与 <code>K</code> 进行 <code>score</code> 的计算，并以 <code>score</code> 作为 <code>V</code> 被 <code>Q</code> 所激活的程度的度量，并因此选择出激活程度最高的 <code>V</code> 中的特征向量，计算加权和。最后，将加权和与原始的 <code>Q</code> 进行相加，得到更新后的 <code>Q</code>。而这个更新后的 <code>Q</code>，就是获得了 attention 的 <code>Q</code>。在视频理解领域，目的就是通过 Self-attention 将来自其他人和物体的上下文信息加到 <code>Q</code> 所代表的人身上，以辅助后续分类。</p><p>AlphAction 中 3.2 节的解释如下</p><blockquote><p>Through the dot-product attention, which is the output of the softmax layer in Figure 3 a, the block is able to select value features that are highly activated to the query features and merge them to enhance the query features.</p></blockquote><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://zhuanlan.zhihu.com/p/48508221" target="_blank" rel="noopener">详解Transformer （Attention Is All You Need）</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直没有深入地了解 Non-local 的来源，以为只是同名论文中提出的一个 Block 设计，最近阅读 AlphAction 论文时，突然发现其是来自于 Attention is all you need 中 self-attention 的思想。虽然 Attention 此文是针对 NLP 领域的，但是其思想逐渐被延伸到了视觉领域。在阅读关于 Transformer 中 self-attention 的文章后，在这里记录下对 Non-local 的理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Non-local" scheme="https://taosean.github.io/tags/Non-local/"/>
    
      <category term="attention" scheme="https://taosean.github.io/tags/attention/"/>
    
      <category term="Transformer" scheme="https://taosean.github.io/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>打包 Python 工程</title>
    <link href="https://taosean.github.io//2019/10/29/Packaging-Python/"/>
    <id>https://taosean.github.io//2019/10/29/Packaging-Python/</id>
    <published>2019-10-29T09:00:59.000Z</published>
    <updated>2020-10-16T07:54:17.490Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了两个用来将 Python 工程的依赖进行打包以便于部署的 Python 库。</p><a id="more"></a><ol><li>PEX <a href="https://github.com/pantsbuild/pex" target="_blank" rel="noopener">github</a> <a href="https://pex.readthedocs.io/" target="_blank" rel="noopener">文档</a> <a href="https://medium.com/ovni/pex-python-executables-c0ea39cee7f1" target="_blank" rel="noopener">博客</a></li><li>shiv <a href="https://github.com/linkedin/shiv" target="_blank" rel="noopener">github</a> <a href="https://shiv.readthedocs.io/en/latest/" target="_blank" rel="noopener">文档</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了两个用来将 Python 工程的依赖进行打包以便于部署的 Python 库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PEX" scheme="https://taosean.github.io/tags/PEX/"/>
    
      <category term="shiv" scheme="https://taosean.github.io/tags/shiv/"/>
    
      <category term="dependencies" scheme="https://taosean.github.io/tags/dependencies/"/>
    
      <category term="依赖" scheme="https://taosean.github.io/tags/%E4%BE%9D%E8%B5%96/"/>
    
      <category term="python" scheme="https://taosean.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>将 Tensorflow 模型移植到 Caffe 上</title>
    <link href="https://taosean.github.io//2019/10/22/Convert-Tensorflow-Model-to-Caffe/"/>
    <id>https://taosean.github.io//2019/10/22/Convert-Tensorflow-Model-to-Caffe/</id>
    <published>2019-10-22T07:32:49.000Z</published>
    <updated>2020-10-16T08:49:35.786Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要以 cosine metric learning 工程为例，记录了如何将一个 Tensorflow 模型 (包含 ckpt 文件) 移植到 Caffe 框架下。</p><a id="more"></a><h1 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h1><blockquote><ol><li>根据 Tensorflow 的网络定义源码，手动编写 Caffe 的网络定义文件 *.prototxt.</li><li>将训练好的 ckpt 文件中的参数 dump 到磁盘，存为 npy 文件。</li><li>使用 pycaffe API, 加载 prototxt 文件，生成 Net 对象。</li><li>根据 npy 文件与 Net 对象中网络层的对应关系，将 npy 文件中的值赋给 Net 对象中的参数。</li><li>将 Net 对象保存为 caffemodel 文件到磁盘。</li></ol></blockquote><br><h1 id="一些应该注意的点"><a class="markdownIt-Anchor" href="#一些应该注意的点"></a> 一些应该注意的点</h1><blockquote><p><strong>1</strong>. Tensorflow 中的 BN 层对应 Caffe 中的两个层，BatchNorm + Scale. 这是因为 Batch Normalization 算法最后有一个 缩放+偏置 的操作，这就对应 Caffe 中的 Scale 层。通常 Scale 层的缩放参数记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>, 偏置参数记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>. 有时候，从 ckpt 模型中 dump 出的 npy 文件没有 BN 层对应的 gamma 值，这可能是因为其在训练时没有使用缩放（batch_norm 函数的 scale 参数设为了 None ），也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\gamma=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。因此在流程第 4 步时，将相应 shape 的值全为 1 的 ndarray 赋给 Net 对象中 Scale 层对应的 gamma 即可，即 <code>net.params[conv1_scale][0].data[...] = np.ones(bn_beta)</code>. 此外，若 npy 文件中有 BN 层对应的 beta 值，则在 prototxt 文件中对应的 Scale 层应设置 <code>bias_term: true</code>，因为这里的 beta 值就是 bias term. <a href="https://blog.csdn.net/zziahgf/article/details/78843350" target="_blank" rel="noopener">参考1</a> <a href="https://www.cnblogs.com/LaplaceAkuir/p/7811383.html" target="_blank" rel="noopener">参考2</a></p></blockquote><hr><blockquote><p><strong>2</strong>. ckpt 中 dump 出的 npy 文件中可能没有某些 Convolution 层的 bias 权重。因此，在 prototxt 文件中，为此 Convolution 层设置 <code>bias_term: false</code>.</p></blockquote><hr><blockquote><p><strong>3</strong>. 在从 ckpt 中 dump 出来的参数里，有些可能名如 <code>*/Adam</code>, <code>*/Adam_1</code>，这个是因为模型使用了 Adam 优化器，这两个是对某个参数更新的时候使用的，如果只是在测试阶段进行前向推导，则不需要这两个参数。<a href="https://www.jianshu.com/p/75d8df8511bc" target="_blank" rel="noopener">参考</a><br>但是如果是需要对模型进行 Finetune, 出现大量 Adam 变量丢失的错误，则有可能是 <strong>要恢复的变量的位置</strong> 和 <strong>Adam 优化器的位置</strong> 出错造成的。<a href="https://blog.csdn.net/shwan_ma/article/details/82868751" target="_blank" rel="noopener">【tensorflow】加载pretrained model出现的大量adam变量丢失</a></p></blockquote><hr><blockquote><p><strong>4</strong>. 一些 Tensorflow 的项目使用 <code>tf.image.decode_jpeg()</code> 函数来读取 jpg 图像，要注意的是，如果直接使用此函数的默认 <code>dct_method</code> 的话，此函数读取到的值将会跟 <code>cv2.imread()</code> 读取的值不一致。这是因为 <code>tf.image.decode_jpeg()</code> 函数默认会为了解码速度而牺牲一些解码精度。如果想要获得跟 <code>cv2.imread()</code> 相同的结果的话，设置参数 <code>dct_method='INTEGER_ACCURATE'</code>。<a href="https://github.com/tensorflow/tensorflow/issues/24893#issuecomment-454911098" target="_blank" rel="noopener">参考1</a> <a href="https://stackoverflow.com/a/45520846/8149027" target="_blank" rel="noopener">参考2</a><br>此外，<code>tf.image.decode_jpeg()</code> 函数返回的图像是 <code>RGB</code> 通道的，<code>cv2.imread()</code> 是 <code>BGR</code> 通道。</p></blockquote><hr><blockquote><p><strong>5</strong>. <strong>Tensorflow 和 Caffe 在某些操作上的区别</strong><br>  <strong>5-1</strong>. <strong>Feature map 以及 卷积核 维度顺序的区别</strong><br>在 Tensorflow 中，feature map 的默认索引顺序是 <code>NHWC</code>, 卷积核是 <code>HWIO</code>，而 Caffe 中两者的索引顺序是 <code>NCHW</code> 和 <code>OIHW</code>.<br>需要说明的是，如果输入是完全一样的图片，在将图像以及卷积核按各自索引顺序 transpose 好后，后续生成的 feature map 在理论上来说应是完全一样的，它们只是索引的顺序不一样而已(feature map 内部各元素之间的相对顺序是一致的)。</p></blockquote><blockquote><p>  <strong>5-2</strong>. <strong>Flatten 操作的区别</strong><br>据上文所述，同样的输入以及卷积核在不同框架中计算得到的 feature map 是一致的。但是如果要对 feature map (4D) 进行 flatten 操作的话，则此结论可能不成立。因为 flatten 是将 3D 的 feature map 拉伸成 1D, 那么不同的顺序可能就会产生不同的 1D 向量 (内部元素的相对位置可能发生了改变).<br>对同一个 feature map, 若其 shape 为 <code>NHWC</code> （这里的 NHWC 与上文所说的 NHWC 意义不一样，针对某个特定的 feature map, 其 NHWC 的值是固定的）, Tensorflow 的顺序是沿着 <code>C -&gt; W -&gt; H</code>，而 Caffe 的顺序是沿着 <code>W -&gt; H -&gt; C</code>。两者 flatten 的顺序在其各自的输入 feature map 索引顺序中都是 <code>3 -&gt; 2 -&gt; 1</code><br>例如，一个 <code>1x3x3x2</code> 的 feature map.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data =  [[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],   | H</span><br><span class="line">          [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],   |</span><br><span class="line">          [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],  |</span><br><span class="line">      W  -------------</span><br><span class="line">         [[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],</span><br><span class="line">          [<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>],</span><br><span class="line">          [<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>]]]</span><br><span class="line"></span><br><span class="line">Tensorflow: [<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, ... ]</span><br><span class="line">Caffe: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, ...]</span><br></pre></td></tr></table></figure><blockquote><p>由于 两者 flatten 的顺序在其各自的输入 feature map 索引顺序中都是 <code>3 -&gt; 2 -&gt; 1</code>，因此若这两个 flatten 的输入是一样的话，则它们的输出也是一样的。由于 Caffe 中没有类似 Transpose 这样的层，因此我采取使用 pycaffe 将前向 inference 后 Flatten 层的输入取出，用 numpy 进行 transpose 后，再重新赋给 Flatten 层当输入，然后再次调用 pycaffe 的接口 <code>net.forward(start='', end='')</code> 指定从某个层开始前向传播，这里就指定 start 参数为 Flatten 层的 name. 这样，即可在 Caffe 中得到与 Tensorflow 中同样的 Flatten 层输出。<a href="https://github.com/BVLC/caffe/issues/2725#issue-93930312" target="_blank" rel="noopener">net.forward 指定起点</a><br>Caffe 的 Flatten 层有 <code>axis</code>, <code>end_axis</code> 两个参数，但是我无论如何设置都无法在不对输入进行 transpose 的情况下得到与 Tensorflow 一样的结果。也许是我没理解对这两个参数的意义。<a href="https://caffe.berkeleyvision.org/tutorial/layers/flatten.html" target="_blank" rel="noopener">参考1</a> <a href="https://stackoverflow.com/a/40401460/8149027" target="_blank" rel="noopener">参考2</a></p></blockquote><blockquote><p>  <strong>5-3</strong>. <strong>Padding 操作的区别</strong><br>Caffe 中的所有 padding 操作都是对称的，也就是说如果设置 <code>pad_w=1</code> 则会在 feature map 的左右两边都 pad 一个像素。但是 Tensorflow 不是如此，有可能出现左边 pad 1, 右边 pad 2，或者上边 pad 1,下边 pad 2 的情况。因此，在移植时，要保持在 Tensorflow 和 Caffe 中的 padding 方式都一样，这样才能得到相同的结果。<br>下面讨论 Caffe 的 padding 与 Tensorflow 中 <code>SAME</code> padding 方式的差异。<br>正常情况下，如果 <code>kernel_size=3, stride=1</code> 那么 <code>SAME</code> padding 模式会保持输入输出的尺寸相同，因此，需要在输入的上下左右各 pad 1 个像素。这时，在 Caffe 里只要设置 <code>pad: 1</code> 就行，这样两者 pad 的结果就是一样的了。<br>但是，如果遇到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">≠</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">stride\neq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的情况，情况就变得复杂。有可能两个框架某个 Convolution 或者 Pooling 操作的输入输出尺寸都一样，但是数值却不同。如下图所示 <a href="https://github.com/Microsoft/MMdnn/wiki/Error-in-mobilenet-conversion-from-Tensorflow-to-Caffe-Different-way-of-padding#the-reason-of-the-inconsistent-shapes-is-due-to-symmetric-padding-in-caffe" target="_blank" rel="noopener">来源</a><br><img src="padding_1.png" alt=""><br><img src="padding_2.png" alt=""><br>在 Tensorflow 中, <code>SAME</code> padding 模式的策略是: <a href="https://stackoverflow.com/a/53820765/8149027" target="_blank" rel="noopener">来源</a></p><blockquote><p>First, consider the <code>SAME</code> padding scheme. A detailed explanation of the reasoning behind it is given in these notes. Here, we summarize the mechanics of this padding scheme. When using ‘SAME’, the output height and width are computed as:</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out_height = ceil(float(in_height) / float(strides[<span class="number">1</span>]))</span><br><span class="line">out_width  = ceil(float(in_width) / float(strides[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>The total padding applied along the height and width is computed as:</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SAME padding 长度计算</span></span><br><span class="line"><span class="keyword">if</span> (in_height % strides[<span class="number">1</span>] == <span class="number">0</span>):</span><br><span class="line">  pad_along_height = max(filter_height - strides[<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  pad_along_height = max(filter_height - (in_height % strides[<span class="number">1</span>]), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_width % strides[<span class="number">2</span>] == <span class="number">0</span>):</span><br><span class="line">  pad_along_width = max(filter_width - strides[<span class="number">2</span>], <span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  pad_along_width = max(filter_width - (in_width % strides[<span class="number">2</span>]), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>Finally, the padding on the top, bottom, left and right are:</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pad_top = pad_along_height // <span class="number">2</span></span><br><span class="line">pad_bottom = pad_along_height - pad_top</span><br><span class="line">pad_left = pad_along_width // <span class="number">2</span></span><br><span class="line">pad_right = pad_along_width - pad_left</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>Note that the division by 2 means that there might be cases when the padding on both sides (top vs bottom, right vs left) are off by one. In this case, the bottom and right sides always get the one additional padded pixel. For example, when pad_along_height is 5, we pad 2 pixels at the top and 3 pixels at the bottom. Note that this is different from existing libraries such as cuDNN and Caffe, which explicitly specify the number of padded pixels and always pad the same number of pixels on both sides.</p></blockquote></blockquote><blockquote><blockquote><p>For the <code>VALID</code> scheme, the output height and width are computed as:</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out_height = ceil(float(in_height - filter_height + <span class="number">1</span>) / float(strides[<span class="number">1</span>]))</span><br><span class="line">out_width  = ceil(float(in_width - filter_width + <span class="number">1</span>) / float(strides[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>and no padding is used.</p></blockquote></blockquote><blockquote><p>在我的实例中，由于最后进入 Flatten 层的 feature map 需要是 <code>13x13</code> 的，而输入图像此前一共经过了 3 次下采样，一次 MAX Pool, 两次 Convolution, 都是 <code>kernel_size=3, stride=2</code>。因此，如何使这三次操作的 padding 操作在两个框架中一致就成了关键问题。由于在 SAME padding 中，<br>                           <code>out_height = ceil(float(in_height) / float(strides[1])),</code><br>                           <code>out_width = ceil(float(in_width) / float(strides[2]))</code><br>因此，这三次下采样操作的输入尺寸存在这些可能性</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">              13                      &lt;-  经过第二次 Conv, stride=2</span><br><span class="line">          /         \</span><br><span class="line">         /           \</span><br><span class="line">       25            26               &lt;-  经过第一次 Conv, stride=2</span><br><span class="line">    /     \       /     \</span><br><span class="line">   49     50     51      52           &lt;-   经过 MAX Pooling</span><br><span class="line">  /  \   /  \   /   \   /   \</span><br><span class="line">97   98 99 100 101 102 103 104        &lt;-      输入图像</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>由于 Caffe 只能进行对称 padding，因此要选择一个合适的输入图像尺寸，使得在这三次操作时 Tensorflow 不会出现 padding 不对称的情况 (因为这在 Caffe 中无法实现)。<br>根据上段 <code>SAME padding 长度计算部分的公式</code>，我们要使得 <code>pad_along_width，pad_along_height</code> 的数值为 <strong>偶数</strong>，这样才能对称。因此，要使得 <strong><code>in_height % strides[1] != 0, in_width % strides[2] != 0</code></strong>。由于 <code>strides[1]=2</code>，因此，<code>in_height, in_width</code> 必须是 <strong>奇数</strong>。这样，就可以得到每次操作前的输入尺寸分别是 <code>97 -&gt; 49 -&gt; 25 -&gt; 13</code>。这样，在每次操作时，SAME padding 都会为 feature map 在空间维度上四周各 pad 一个像素。而在 Caffe 的对应层的定义里，只要设置 <code>pad: 1</code> 即可。</p></blockquote><hr><blockquote><p><strong>6</strong>. 关于 Tensorflow 中获取 Graph 中所有节点名称以及 ckpt 文件中的变量。<br>  <strong>6.1</strong>.<strong>读取 ckpt 中的变量</strong> <a href="https://www.jianshu.com/p/75d8df8511bc" target="_blank" rel="noopener">参考</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf;</span><br><span class="line"></span><br><span class="line"> reader = tf.train.NewCheckpointReader(<span class="string">"/path/to/model.ckpt"</span>)</span><br><span class="line"> variables = reader.get_variable_to_shape_map()</span><br><span class="line"> <span class="keyword">for</span> key <span class="keyword">in</span> variables:</span><br><span class="line">      w = reader.get_tensor(key)</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>6.2</strong>. <strong>获取 Graph 中的所有结点名称，并计算得到某节点的值</strong> <a href="https://www.jianshu.com/p/3cee7ca5ebd8" target="_blank" rel="noopener">参考</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all_op_names = [n.name <span class="keyword">for</span> n <span class="keyword">in</span> tf.get_default_graph().as_graph_def().node]</span><br><span class="line">conv1_op = tf.get_default_graph.get_tensor_by_name(<span class="string">'a_tensor_name_from_above_line:0'</span>)  <span class="comment"># 注意要在名称后面加 :0</span></span><br><span class="line">conv1_value = sess.run(conv1_op, feed_dict=&#123;...&#125;)</span><br></pre></td></tr></table></figure><br><h2 id="dump-ckpt-中的参数以及生成-caffemodel-的两个脚本"><a class="markdownIt-Anchor" href="#dump-ckpt-中的参数以及生成-caffemodel-的两个脚本"></a> dump ckpt 中的参数以及生成 caffemodel 的两个脚本</h2><p><a href="dump.py">dump ckpt</a><br><a href="tf2caffe.py">生成 caffemodel</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要以 cosine metric learning 工程为例，记录了如何将一个 Tensorflow 模型 (包含 ckpt 文件) 移植到 Caffe 框架下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Caffe" scheme="https://taosean.github.io/tags/Caffe/"/>
    
      <category term="Tensorflow" scheme="https://taosean.github.io/tags/Tensorflow/"/>
    
      <category term="Porting" scheme="https://taosean.github.io/tags/Porting/"/>
    
      <category term="移植" scheme="https://taosean.github.io/tags/%E7%A7%BB%E6%A4%8D/"/>
    
      <category term="padding" scheme="https://taosean.github.io/tags/padding/"/>
    
      <category term="flatten" scheme="https://taosean.github.io/tags/flatten/"/>
    
  </entry>
  
  <entry>
    <title>卡尔曼滤波</title>
    <link href="https://taosean.github.io//2019/07/04/Kalman-Filter/"/>
    <id>https://taosean.github.io//2019/07/04/Kalman-Filter/</id>
    <published>2019-07-04T05:29:47.000Z</published>
    <updated>2021-03-25T07:51:58.867Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要关注卡尔曼滤波的流程和 5 个公式。</p><a id="more"></a><p><strong>卡尔曼滤波的主要思想</strong>：首先，根据时间步 <code>t-1</code> 的状态空间，通过<strong>状态转移矩阵</strong>和<strong>控制矩阵</strong>(控制量)，预测 <code>t</code> 时间步时的状态空间。由于 <code>t-1</code> 时间步的状态空间本身就不是准确的，含有噪声，且状态转移的过程也引入噪声，因此预测得到的 <code>t</code> 时间步的状态空间是不准确的。这时，我们在 <code>t</code> 时间步进行实际的测量，使用得到的<strong>测量结果</strong>去修正预测得到的状态空间。其实就是对 <strong>预测的结果</strong> 和 <strong>测量的结果</strong> 根据其不准确度(用协方差矩阵表示)来计算权重(即卡尔曼增益)，对两个结果进行<font color="purple" size="4"> <strong>加权平均</strong></font>，并依此得到 <code>t</code> 时间步最优的结果。</p><blockquote><p>虽然叫 kalman 滤波器，但个人觉得也可以叫状态观测器，因为就是根据<strong>测量值的协方差矩阵</strong>和<strong>预测值的协方差矩阵</strong>权衡出一个更为准确的系统当前状态嘛。(<font color="blue">TAO: 就是根据这两个协方差矩阵算出卡尔曼增益，充当加权的权重。</font>)如果从噪声的角度上理解，最终也确实起到了一个降噪的效果，叫滤波器也合适。</p></blockquote><br><h1 id="卡尔曼滤波的五个公式"><a class="markdownIt-Anchor" href="#卡尔曼滤波的五个公式"></a> 卡尔曼滤波的五个公式</h1><p><img src="format.jpg" alt="卡尔曼公式"></p><br><h1 id="卡尔曼滤波模型"><a class="markdownIt-Anchor" href="#卡尔曼滤波模型"></a> 卡尔曼滤波模型</h1><p><img src="Kalman_filter_model.png" alt="卡尔曼滤波模型"></p><h1 id="博客"><a class="markdownIt-Anchor" href="#博客"></a> 博客</h1><h2 id="第一篇"><a class="markdownIt-Anchor" href="#第一篇"></a> 第一篇</h2><p>在网上看了一些有关卡尔曼滤波的博客，其中有一篇英文的博客讲得很好。知乎上也有很多翻译版本。<br><a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/" target="_blank" rel="noopener"><font color="purple">英文原版</font></a><br><a href="https://zhuanlan.zhihu.com/p/39912633?utm_source=zhihu&amp;utm_medium=social&amp;utm_oi=846674040629395456" target="_blank" rel="noopener"><font color="purple">中文翻译版</font></a></p><blockquote><p>这个翻译版有很多错误，我结合原文和其他翻译版对有些段落进行了修正。</p></blockquote><p><img src="1.jpeg" alt=""><br><img src="2.jpeg" alt=""><br><img src="3.jpeg" alt=""><br><img src="4.jpeg" alt=""><br><img src="5.1.jpeg" alt=""><br><img src="5.2.png" alt=""><br><img src="5.3.png" alt=""><br><img src="6.jpeg" alt=""><br><img src="7.jpeg" alt=""></p><br><h2 id="第二篇"><a class="markdownIt-Anchor" href="#第二篇"></a> 第二篇</h2><p>还有一篇 CSDN 上的博客，<a href="https://blog.csdn.net/weixin_39632524/article/details/111362311" target="_blank" rel="noopener"><font color="purple">卡尔曼滤波五个公式_仔细看完你就懂卡尔曼滤波（Kalman Filter）</font></a><br><img src="1-2.jpeg" alt=""><br><img src="3-4.jpeg" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要关注卡尔曼滤波的流程和 5 个公式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kalman" scheme="https://taosean.github.io/tags/Kalman/"/>
    
      <category term="tracking" scheme="https://taosean.github.io/tags/tracking/"/>
    
      <category term="卡尔曼" scheme="https://taosean.github.io/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC/"/>
    
      <category term="卡尔曼滤波" scheme="https://taosean.github.io/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>【转载】 浅谈多节点 CPU+GPU 协同计算负载均衡性设计</title>
    <link href="https://taosean.github.io//2019/06/26/Heterogeneous-Computing/"/>
    <id>https://taosean.github.io//2019/06/26/Heterogeneous-Computing/</id>
    <published>2019-06-26T07:34:27.000Z</published>
    <updated>2020-12-10T12:08:35.631Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自<a href="https://blog.csdn.net/zhang0311/article/details/8224093" target="_blank" rel="noopener">这里</a>，主要讲述了关于基于 CPU+GPU 的混合异构计算系统的内容。</p><a id="more"></a><p>近年来，基于 CPU+GPU 的混合异构计算系统开始逐渐成为国内外高性能计算领域的热点研究方向。在实际应用中，许多基于 CPU+GPU 的混合异构计算机系统表现出了良好的性能。但是，由于各种历史和现实原因的制约，异构计算仍然面临着诸多方面的问题，其中最突出的问题是程序开发困难，尤其是扩展到集群规模级别时这个问题更为突出。主要表现在扩展性、负载均衡、自适应性、通信、内存等方面。</p><h1 id="一-cpugpu协同计算模式"><a class="markdownIt-Anchor" href="#一-cpugpu协同计算模式"></a> 一、 CPU+GPU协同计算模式</h1><p>CPU+GPU异构协同计算集群如图1所示，CPU+GPU 异构集群可以划分成三个并行层次：节点间并行、节点内 CPU 与 GPU 异构并行、设备（CPU 或 GPU）内并行。根据这三个层次我们可以得到 CPU+GPU 异构协同计算模式为：<font color="orange">节点间分布式+节点内异构式+设备内共享式</font>。</p><p><strong>1 节点间分布式</strong><br>CPU+GPU 异构协同计算集群中，各个节点之间的连接与传统 CPU 集群一样，采用网络连接，因此，节点间采用了分布式的计算方式，可以采用 MPI 消息通信的并行编程语言。</p><p><strong>2 节点内异构式</strong><br>CPU+GPU 异构协同计算集群中，每个节点上包含多核 CPU 和一块或多块 GPU 卡，节点内采用了异构的架构，采用主从式的编程模型，即每个 GPU 卡需要由 CPU 进程/线程调用。</p><p>由于每个节点上，CPU 核数也比较多，计算能力也很大，因此，在多数情况下，CPU 也会参与部分并行计算，根据 CPU 是否参与并行计算，我们可以把 CPU+GPU 异构协同计算划分成两种计算模式：</p><p> 1) CPU/GPU 协同计算：CPU 只负责复杂逻辑和事务处理等串行计算，GPU 进行大规模并行计算；<br> 2) CPU+GPU 共同计算：由一个 CPU 进程/线程负责复杂逻辑和事务处理等串行计算，其它 CPU 进程/线程负责小部分并行计算，GPU 负责大部分并行计算。</p><p>由于 CPU/GPU 协同计算模式比 CPU+GPU 共同计算模式简单，下面的介绍中，我们以 CPU+GPU 共同计算模式为例进行展开介绍各种编程模式。</p><p>在 CPU+GPU 共同计算模式下，我们把所有的 CPU 统称为一个设备（device），如双路 8 核 CPU 共有 16 个核，我们把这 16 个核统称成一个设备；每个 GPU 卡成为一个设备。根据这种划分方式，我们可以采用 MPI 进程或 OpenMP 线程控制节点内的各设备之间的通信和数据划分。</p><p><strong>3 设备内共享式</strong><br> 1) CPU 设备：每个节点内的所有多核 CPU 采用了共享存储模型，因此，把节点内的所有多核 CPU 看作一个设备， 可以采用 MPI 进程或 OpenMP 线程、pThread 线程控制这些 CPU 核的并行计算。</p><p> 2) GPU 设备：GPU 设备内有自己独立的 DRAM 存储，GPU 设备也是共享存储模型，在 GPU 上采用 CUDA 或 OpenCL 编程控制 GPU 众核的并行计算。CUDA 编程模式只在 NVIDIA GPU 上支持，OpenCL 编程模式在 NVIDIA GP U和 AMD GPU 都支持。</p><p>根据前面对 CPU+GPU 异构协同计算模式的描述，我们可以得到 CPU+GPU 异构协同计算的编程模型（以 MPI 和 OpenMP 为例）如表1所示。</p><p><img src="pic_1.jpg" alt="图1 CPU+GPU异构协同计算架构"></p><p><img src="pic_2.png" alt="表1 CPU+GPU异构协同计算编程模型"></p><h1 id="二-cpugpu协同计算负载均衡性设计"><a class="markdownIt-Anchor" href="#二-cpugpu协同计算负载均衡性设计"></a> 二、CPU+GPU协同计算负载均衡性设计</h1><p>下面以 模式2 为例简单介绍多节点 CPU+GPU 协同计算任务划分和负载均衡，模式2 的进程和线程与 CPU 核和 GPU 设备对应关系如 图2 所示。若采用主从式 MPI 通信机制，我们在节点 0 上多起一个进程（0号进程）作为主进程，控制其它所有进程。每个节点上启动3个计算进程，其中两个控制 GPU 设备，一个控制其余所有 CPU 核的并行，在 GPU 内采用 CUDA/OpenCL 并行，在 CPU 设备内采用 OpenMP 多线程并行。</p><p>由于 CPU+GPU 协同计算模式分为 3个层次，那么负载均衡性也需要在这 3个层次 上分别设计。在 模式2 的编程方式下，节点内和节点间均采用 MPI 进程，合二为一，设计负载均衡时，只需要做到进程间（设备之间）的负载均衡和 CPU 设备内 OpenMP 线程负载均衡、GPU 设备内 CUDA 线程负载均衡即可。</p><p>对于设备内，采用的是共享存储器模型，CPU 设备上的 OpenMP 线程可以采用 schedule(static / dynamic / guided )方式；GPU 设备上只要保证同一 warp 内的线程负载均衡即可。</p><p>对于 CPU+GPU 协同计算，由于 CPU 和 GPU 计算能力相差很大，因此，在对任务和数据划分时不能给 CPU 设备和 GPU 设备划分相同的任务/数据量，这就增加了 CPU 与 GPU 设备间负载均衡的难度。CPU 与 GPU 之间的负载均衡最好的方式是采用动态负载均衡的方法，然而有些应用无法用动态划分而只能采用静态划分的方式。下面我们分别介绍动态划分和静态划分。</p><p> 1) 动态划分：对于一些高性能计算应用程序，在 CPU 与 GPU 之间的负载均衡可以采用动态负载均衡的优化方法，例如有 N 个任务/数据，一个节点内有 2 个 GPU 卡，即三个设备（CPU 和 2个 GPU），动态负载均衡的方法是每个设备先获取一个任务/数据进行计算，计算之后立即获取下一个任务，不需要等待其他设备，直到 N 个任务/数据计算完成。这种方式只需要在集群上设定一个主进程，负责给各个计算进程分配任务/数据。</p><p> 2) 静态划分：在一些应用中，无法采用动态划分的方式，需要静态划分方法，然而静态划分方法使异构设备间的负载均衡变得困难，有时甚至无法实现。对于一些迭代应用程序，我们可以采用学习型的数据划分方法，如先让 CPU 和 GPU 分别做一次相同计算量的计算，然后通过各自的运行时间计算出 CPU 与 GPU 的计算能力比例，然后再对数据进行划分。</p><p><img src="pic_3.jpg" alt="图2 CPU+GPU协同计算示意图（以每个节点2个GPU为例）"></p><h1 id="三-cpugpu协同计算数据划分示例"><a class="markdownIt-Anchor" href="#三-cpugpu协同计算数据划分示例"></a> 三、CPU+GPU协同计算数据划分示例</h1><p>假设某一应用的数据特点如 图3 所示，从输出看，结果中的每个值的计算需要所有输入数据的信息，所有输出值的计算之间没有任何数据依赖性，可以表示成 outj=；从输入看，每个输入值对所有的输出值都产生影响，所有输入数据之间也没有任何数据依赖性。从数据特点可以看出，该应用既可以对输入进行并行数据划分也可以对输出进行数据划分。下面我们分析 CPU+GPU 协同计算时的数据划分方式。<br><img src="pic_4.jpg" alt="图3 并行数据示例"></p><p><strong>1 按输入数据划分</strong></p><p>假设按输入数据划分，我们可以采用动态的方式给每个 CPU 或 GPU 设备分配数据，做到动态负载均衡，然而这种划分方式，使所有的线程向同一个输出位置保存结果，为了正确性，需要使所有的线程对每个结果进行原子操作，这样将会严重影响性能，极端情况下，所有线程还是按顺序执行的。因此，这种方式效果很差。</p><p><strong>2 按输出数据划分</strong></p><p>按输出数据划分的话可以让每个线程做不同位置的结果计算，计算完全独立，没有依赖性。如果采用静态划分的方式，由于 CPU 和 GPU 计算能力不同，因此，很难做到负载均衡。采用动态的方式可以做到负载均衡，即把结果每次给 CPU 或 GPU 设备一块，当设备计算完本次之后，立即向主进程申请下一个分块，这样可以做到完全负载均衡。按输出数据划分，无论采用静态划分还是动态划分，都会带来另外一个问题，由于每个结果的计算都需要所有输入信息，那么所有进程（设备）都需要读取一遍所有输入数据，动态划分时还不只一次，尤其对于输入数据很大时，这将会对输入数据的IO产生很大的影响，很有可能使 IO 程序性能瓶颈。</p><p><strong>3 按输入和输出同时划分</strong></p><p>由于按输入或按输出划分都存在不同的缺点，我们可以采用输入和输出同时划分的方式进行数据划分，如 图4 所示。</p><p>从输出角度，让所有的计算进程（设备）都有一份计算结果，设备内的线程对结果进行并行计算，每个设备都有一份局部的计算结果，所有设备都计算完毕之后，利用MPI进程对所有设备的计算结果进行规约，规约最后的结果即是最终的结果。</p><p>从输入角度，按输入数据动态划分给不同的计算进程（设备），这样可以满足所有的计算进程负载均衡。<br><img src="pic_5.jpg" alt="图4 CPU+GPU协同计算数据划分示例"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自&lt;a href=&quot;https://blog.csdn.net/zhang0311/article/details/8224093&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;，主要讲述了关于基于 CPU+GPU 的混合异构计算系统的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CPU" scheme="https://taosean.github.io/tags/CPU/"/>
    
      <category term="GPU" scheme="https://taosean.github.io/tags/GPU/"/>
    
      <category term="负载均衡" scheme="https://taosean.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="异构" scheme="https://taosean.github.io/tags/%E5%BC%82%E6%9E%84/"/>
    
      <category term="协同计算" scheme="https://taosean.github.io/tags/%E5%8D%8F%E5%90%8C%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>一些 C++ 相关的概念和操作</title>
    <link href="https://taosean.github.io//2019/06/26/Cxx-Related/"/>
    <id>https://taosean.github.io//2019/06/26/Cxx-Related/</id>
    <published>2019-06-26T06:27:22.000Z</published>
    <updated>2020-10-16T08:49:48.483Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录了一些常用的 C++ 相关的概念和操作。</p><a id="more"></a><br><h3 id="string-与-char-互转"><a class="markdownIt-Anchor" href="#string-与-char-互转"></a> string 与 char* 互转</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string to char*</span></span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"name"</span>;</span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*)name.data();</span><br><span class="line"></span><br><span class="line"><span class="comment">// char* to string</span></span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">"name"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="built_in">string</span>(name);</span><br></pre></td></tr></table></figure><br><h3 id="释放-stdvector-所占用的内存"><a class="markdownIt-Anchor" href="#释放-stdvector-所占用的内存"></a> 释放 std::vector 所占用的内存</h3><blockquote><p>在容器 vector 中，其内存占用的空间是只增不减的，比如说首先分配了 10,000 个字节，然后 erase 掉后面 9999个，则虽然有效元素只有一个，但是内存占用仍为 10,000 个。所有内存空间在 vector 析构时回收。<br>一般，我们都会通过 vector 中成员函数 clear 进行一些清除操作，但它清除的是所有的元素，使 vector 的大小减少至 0，却不能减小 vector 占用的内存。要避免 vector 持有它不再需要的内存，这就需要一种方法来使得它从曾经的容量减少至它现在需要的容量，这样减少容量的方法被称为 “<strong>收缩到合适（shrink to fit）</strong>”。</p></blockquote><p>使用以下代码可以实现此功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt;().swap(X)  <span class="comment">// X 的类型为 std::vector&lt;T&gt;;</span></span><br><span class="line"><span class="comment">//其相当于</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;  temp(X);</span><br><span class="line">temp.swap(X);</span><br></pre></td></tr></table></figure><blockquote><p>其背后原理为:<strong><code>vector()</code> 使用 <code>vector</code> 的默认构造函数建立临时 <code>vector</code> 对象，再在该临时对象上调用 <code>swap</code> 成员，<code>swap</code> 调用之后对象 <code>X</code> 占用的空间就等于一个默认构造的对象的大小，临时对象就具有原来对象 <code>X</code> 的大小，而该临时对象随即就会被析构，从而其占用的空间也被释放。</strong></p></blockquote><p><a href="https://www.cnblogs.com/zhoug2020/p/4058487.html" target="_blank" rel="noopener">参考</a></p><br><h3 id="二维数组和双重指针在内存中的差别"><a class="markdownIt-Anchor" href="#二维数组和双重指针在内存中的差别"></a> 二维数组和双重指针在内存中的差别</h3><p>首先，下例是不可行的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COL 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myputs</span><span class="params">(<span class="keyword">char</span> **pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> **p;</span><br><span class="line">    <span class="keyword">char</span> a[ROW][COL]=&#123;<span class="string">"abc"</span>, <span class="string">"def"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    p = a;</span><br><span class="line">    myputs(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myputs</span><span class="params">(<span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ROW; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, p[i][j]); <span class="comment">// 试图用双重指针的方式访问二维数组，不可行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>myputs(char **p)</code> 接受双重指针作为参数，<code>main()</code> 函数将二维数组的头指针赋给双重指针，并作为 <code>myputs(char **p)</code> 的参数传入，再使用 <code>p[i][j]</code> 的方式访问某个元素。这是不行的，而这与两者的内存分布有关。</p><hr><p><strong>二维数组的内存分布</strong></p><blockquote><p>定义了二维数组后，就会在内存中分配一块逻辑上连续的内存块。<code>char c[10][10]</code>，系统就会分配一块 100 字节的连续内存。也就是说这样的二维数组跟一维数组 <code>char c[100]</code> 具有相似的内存分布。<br>二维数组的内存分布如下：<br><img src="2d_array.png" alt="二维数组的内存分布"></p></blockquote><p><strong>双重指针的内存分布</strong></p><blockquote><p>双重指针的内存分配一般采取动态方式<br><img src="2d_pointer.png" alt="双重指针的内存分布"></p></blockquote><p>可以看出，当将二维数组的头指针赋值给双重指针后，再使用 <code>p[i][j]</code> 的方式访问里面的元素，就会出现错误。这是因为，二维数组的内存是以连续的方式分配的，但是在访问时，却使用了双重指针的方式进行访问，这就会导致段错误。</p><hr><p><strong>总结</strong></p><blockquote><p><code>char **p</code> 和 <code>char p[2][3]</code> 之间不能相互传递参数，因为它们具体的内存分布不一样，这样在运行时就会出现段错误。<br>此外还需注意的一点：<br>二维数组中的 <code>a[i][j]</code> 和双重指针中的 <code>a[i][j]</code> 的意思是不一样的。<br>二维数组 <code>int a[10][10]</code> 中，<code>a[i][j]</code> 指的是第 <code>i</code> 行第 <code>j</code> 列数元素。<br>双重指针中 <code>int **a</code> 中， <code>a[i][j]</code> 指的是第 <code>i</code> 个存放 <code>int *</code> 指针所指向地址中的第 <code>j</code> 个元素。也就是 <code>*(*(a+i)+j)</code>。</p></blockquote><p><a href="https://blog.csdn.net/u013684730/article/details/46565577" target="_blank" rel="noopener">原文</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录了一些常用的 C++ 相关的概念和操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://taosean.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>进程和线程及相关概念</title>
    <link href="https://taosean.github.io//2019/06/14/Process-and-Thread/"/>
    <id>https://taosean.github.io//2019/06/14/Process-and-Thread/</id>
    <published>2019-06-14T02:50:31.000Z</published>
    <updated>2020-10-16T08:52:29.745Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录了进程，线程等相关内容。</p><a id="more"></a><blockquote><p>抛开各种技术细节，从应用程序角度讲：<br>1、在单核计算机里，有一个资源是无法被多个程序并行使用的：CPU。<br>没有操作系统的情况下，一个程序一直独占着全部 CPU。<br>如果要有两个任务来共享同一个 CPU，程序员就需要仔细地为程序安排好运行计划–某时刻 CPU 和由程序 A 来独享，下一时刻 CPU 由程序 B 来独享,而这种安排计划后来成为 OS 的核心组件，被单独名命为 “<strong>scheduler</strong>”，即“<strong>调度器</strong>”，它关心的只是怎样把单个 CPU 的运行拆分成一段一段的“运行片”，轮流分给不同的程序去使用，而在宏观上，因为分配切换的速度极快，就制造出多程序并行在一个 CPU 上的假象。</p></blockquote><blockquote><p>2、在单核计算机里，有一个资源可以被多个程序共用，然而会引出麻烦：<strong>内存</strong>。<br>在一个只有调度器，没有内存管理组件的操作系统上，程序员需要手工为每个程序安排运行的空间 – 程序A使用物理地址 <code>0x00-0xff</code>, 程序B使用物理地址<code>0x100-0x1ff</code>，等等。<br>然而这样做有个很大的问题：每个程序都要协调商量好怎样使用同一个内存上的不同空间，软件系统和硬件系统千差万别，使这种定制的方案没有可行性。<br>为了解决这个麻烦，计算机系统引入了“<strong>虚拟地址</strong>”的概念，从三方面入手来做：<br>2.1、硬件上，CPU 增加了一个专门的模块叫 MMU，负责转换虚拟地址和物理地址。<br>2.2、操作系统上，操作系统增加了另一个核心组件：<strong>memory management</strong>，即内存管理模块，它管理物理内存、虚拟内存相关的一系列事务。<br>2.3、应用程序上，发明了一个叫做【进程】的模型，（注意）每个进程都用【<strong>完全一样的</strong>】虚拟地址空间，然而经由操作系统和硬件MMU协作，映射到不同的物理地址空间上。不同的【进程】，都有各自独立的物理内存空间，不用一些特殊手段，是无法访问别的进程的物理内存的。</p></blockquote><blockquote><p>3、现在，不同的应用程序，可以不关心底层的物理内存分配，也不关心 CPU 的协调共享了。然而还有一个问题存在：有一些程序，想要共享 CPU，【并且还要共享同样的物理内存】，这时候，一个叫【线程】的模型就出现了，它们被包裹在进程里面，在调度器的管理下共享 CPU，拥有同样的虚拟地址空间，同时也共享同一个物理地址空间，然而，它们无法越过包裹自己的进程，去访问别一个进程的物理地址空间。</p></blockquote><blockquote><p>4、进程之间怎样共享同一个物理地址空间呢？不同的系统方法各异，符合 posix 规范的操作系统都提供了一个接口，叫 mmap，可以把一个物理地址空间映射到不同的进程中，由不同的进程来共享。</p></blockquote><blockquote><p>5、PS：在有的操作系统里，进程不是调度单位（即不能被调度器使用），线程是最基本的调度单位，调度器只调度线程，不调度进程，比如 VxWorks<br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html#comment-270980" target="_blank" rel="noopener">来源</a></p></blockquote><br>>CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是 CPU 和相关寄存器以及 RAM 之间的事情。**一个最最基础的事实**：CPU 太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM 和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在 CPU 看来就是轮流着来。**一个必须知道的事实**：执行一段程序代码，实现一个功能的过程介绍 ，当得到 CPU 的时候，相关的资源必须也已经就位，就是显卡啊，GPS 啊什么的必须就位，然后 CPU 开始执行。这里除了 CPU 以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的 CPU 执行时间用完了，那它就要被切换出去，等待下一次 CPU 的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被 CPU 临幸的运行环境，必须保存。**串联起来的事实**：前面讲过在 CPU 看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行 A，保存程序 A 的上下文，调入下一个要执行的程序 B 的程序上下文，然后开始执行 B,保存程序 B 的上下文。。。。<p>========= 重要的东西出现了========<br>进程和线程就是这样的背景出来的，<strong>两个名词不过是对应的CPU时间段的描述，名词就是这样的功能</strong>。<br>进程就是包换上下文切换的程序执行时间总和 = CPU 加载上下文 + CPU 执行 + CPU 保存上下文<br>**线程是什么呢？**进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序 A，实际分成 a，b，c 等多个块组合而成。那么这里具体的执行就可能变成：程序 A 得到 CPU =&gt; CPU 加载上下文，开始执行程序 A 的 a 小段，然后执行 A 的 b 小段，然后再执行 A 的 c 小段，最后 CPU 保存  A 的上下文。这里 a，b，c 的执行是共享了 A 的上下文，CPU 在执行的时候没有进行上下文切换的。这里的 a，b，c 就是线程，也就是说线程是共享了进程的上下文环境的更为细小的 CPU 时间段。到此全文结束，再一个总结：<strong>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。</strong><br><a href="https://www.zhihu.com/question/25532384/answer/81152571" target="_blank" rel="noopener">来源</a></p><blockquote><p>一、 cpu个数、核数、线程数的关系<br>cpu个数：是指物理上，也及硬件上的核心数；<br>核数：是逻辑上的，简单理解为逻辑上模拟出的核心数；<br>线程数：是同一时刻设备能并行执行的程序个数，线程数=cpu个数 * 核数【如果有超线程，再乘以超线程数】</p></blockquote><blockquote><p>二、 cpu线程数和Java多线程<br>首先明白几个概念：<br>(1) 单个cpu线程在同一时刻只能执行单一Java程序，也就是一个线程<br>(2) 单个线程同时只能在单个cpu线程中执行<br>(3) 线程是操作系统最小的调度单位，进程是资源（比如：内存）分配的最小单位<br>(4)Java中的所有线程在JVM进程中,CPU调度的是进程中的线程<br>(5)Java多线程并不是由于cpu线程数为多个才称为多线程，当Java线程数大于cpu线程数，操作系统使用时间片机制，采用线程调度算法，频繁的进行线程切换。</p></blockquote><blockquote><p>a 那么java多进程，每个进程又多线程，cpu是如何调度的呢？<br>个人理解：操作系统并不是单纯均匀的分配cpu执行不同的进程，因为线程是调度的最小单位，所以会根据不同进程中的线程个数进行时间分片，均匀的执行每个线程，也就是说A进程中有10个线程，而B进程中有2个线程，那么cpu分给进程的执行时间理论上应该是5:1才合理。</p></blockquote><blockquote><p>b cpu线程数和java线程数有直接关系吗？<br>个人理解：没有直接关系，正如上面所说，cpu采用分片机制执行线程，给每个线程划分很小的时间颗粒去执行，但是真正的项目中，一个程序要做很多的的操作，读写磁盘、数据逻辑处理、出于业务需求必要的休眠等等操作，当程序在进行I/O操作的时候，线程是阻塞的，线程由运行状态切换到等待状态，此时cpu会做上下文切换，以便处理其他的程序；当I/O操作完成后，cpu 会收到一个来自硬盘的中断信号，并进入中断处理例程，手头正在执行的线程因此被打断，回到 ready 队列。而先前因 I/O 而waiting 的线程随着 I/O 的完成也再次回到 就绪 队列，这时 cpu 可能会选择它来执行。</p></blockquote><blockquote><p>c 如何确定程序线程数？<br>个人理解：如果所有的任务都是计算密集型的，则创建的多线程数 = 处理器核心数就可以了<br>如果io操作比较耗时，则根据具体情况调整线程数，此时 多线程数 = n*处理器核心数<br>一般情况程序线程数等于cpu线程数的两到三倍就能很好的利用cpu了，过多的程序线程数不但不会提高性能，反而还会因为线程间的频繁切换而受影响，具体需要根据线程处理的业务考略，不断调整线程数个数，确定当前系统最优的线程数。<br><a href="https://blog.csdn.net/wutongyuWxc/article/details/78732287" target="_blank" rel="noopener">原文</a></p></blockquote><br><h2 id="一篇非常好的文章"><a class="markdownIt-Anchor" href="#一篇非常好的文章"></a> 一篇非常好的文章</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/1352974" target="_blank" rel="noopener">进程与线程，单核与多核</a></p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录了进程，线程等相关内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="线程" scheme="https://taosean.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程" scheme="https://taosean.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="CPU" scheme="https://taosean.github.io/tags/CPU/"/>
    
      <category term="Process" scheme="https://taosean.github.io/tags/Process/"/>
    
      <category term="Thread" scheme="https://taosean.github.io/tags/Thread/"/>
    
      <category term="阻塞" scheme="https://taosean.github.io/tags/%E9%98%BB%E5%A1%9E/"/>
    
      <category term="非阻塞" scheme="https://taosean.github.io/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    
      <category term="单核" scheme="https://taosean.github.io/tags/%E5%8D%95%E6%A0%B8/"/>
    
      <category term="多核" scheme="https://taosean.github.io/tags/%E5%A4%9A%E6%A0%B8/"/>
    
  </entry>
  
</feed>
